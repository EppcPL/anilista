<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Toolkit</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        html {
    scroll-behavior: smooth;
}

.section {
    scroll-margin-top: 80px;
}
        :root {
            --primary: #6c5ce7;
            --primary-dark: #5649c0;
            --primary-light: #a29bfe;
            --secondary: #fd79a8;
            --accent: #00cec9;
            --dark: #2d3436;
            --darker: #1e272e;
            --light: #f5f6fa;
            --lighter: #ffffff;
            --gray: #dfe6e9;
            --success: #00b894;
            --warning: #fdcb6e;
            --danger: #d63031;
            --info: #0984e3;
            
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            --card-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, var(--darker), var(--dark));
            color: var(--light);
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-left: 100px;
        }
        
        h1, h2, h3 {
            color: var(--lighter);
            margin-bottom: 1.5rem;
            font-weight: 600;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.8rem;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            padding-bottom: 1rem;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
        }
        
        .section {
            margin-bottom: 3rem;
            padding: 2rem;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray);
            font-size: 0.95rem;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 1rem;
            color: var(--lighter);
            transition: var(--transition);
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
            background: rgba(0, 0, 0, 0.3);
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
            box-shadow: 0 4px 12px rgba(214, 48, 49, 0.3);
        }
        
        .btn-success {
            background-color: var(--success);
        }
        
        .btn-success:hover {
            background-color: #00a383;
            box-shadow: 0 4px 12px rgba(0, 184, 148, 0.3);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
        }
        
        .btn-secondary:hover {
            background-color: #e84393;
            box-shadow: 0 4px 12px rgba(253, 121, 168, 0.3);
        }
        
        .btn-accent {
            background-color: var(--accent);
        }
        
        .btn-accent:hover {
            background-color: #00b5ad;
            box-shadow: 0 4px 12px rgba(0, 206, 201, 0.3);
        }
        
        .anime-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .anime-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.3;
            z-index: -1;
        }
        
        .anime-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .anime-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .anime-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .anime-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--lighter);
            position: relative;
            padding-left: 12px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .anime-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
        }
        
        .anime-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--glass-border);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .status-watching {
            color: var(--info);
            border-color: var(--info);
        }
        
        .status-completed {
            color: var(--success);
            border-color: var(--success);
        }
        
        .status-upcoming {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .rating-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .rating-label {
            font-weight: 500;
            width: 80px;
            color: var(--gray);
        }
        
        .rating-value {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: var(--lighter);
            padding-left: 8px;
            padding-right: 8px;
            flex-shrink: 0;
            word-break: break-all;
        }
        
        .tier-list {
            margin-top: 2rem;
        }
        
        .tier-row {
            display: flex;
            margin-bottom: 0.5rem;
            min-height: 70px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .tier-label {
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            position: relative;
            z-index: 1;
            font-size: 1.2rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .tier-SSS { 
            font-weight: 900;
            font-size: 1.4em;
            animation: rainbow 5s linear infinite;
        }
        
        .tier-SS { background-color: #ff4757; }
        .tier-S { background-color: #ff6b81; }
        .tier-A { background-color: #ff9f43; }
        .tier-B { background-color: #feca57; color: #333; }
        .tier-C { background-color: #fffa65; color: #333; }
        .tier-D { background-color: #1dd1a1; color: #333; }
        .tier-F { background-color: #10ac84; color: #333; }
        
        .tier-items {
            flex-grow: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            min-height: 70px;
            align-items: center;
        }
        
        .tier-item {
            background-color: var(--primary);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.9rem;
            height: fit-content;
            transition: var(--transition);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
        }
        
        .tier-item:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
            gap: 0.8rem;
            margin-top: auto;
        }
        
        .actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        
        .no-anime {
            text-align: center;
            padding: 2rem;
            color: var(--gray);
            grid-column: 1 / -1;
            font-size: 1.1rem;
        }
        
        .tier-controls {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .tier-category-btn {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--gray);
            transition: var(--transition);
            border: 1px solid var(--glass-border);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .tier-category-btn.active {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .average-rating {
            font-weight: 600;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--glass-border);
            color: var(--lighter);
            font-size: 1.1rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
        }
        
        /* Profile stats */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .stat-card {
            background: var(--glass);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .stat-card.clickable {
            cursor: pointer;
            transition: var(--transition);
        }
        
        .stat-card.clickable:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .stat-card.clickable:hover .stat-value {
            color: var(--primary-light);
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin: 1rem 0;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-label {
            font-size: 0.95rem;
            color: var(--gray);
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        /* Time display */
        .time-display {
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }
        
        .time-display:hover {
            color: var(--primary);
        }
        
        .rewatch-info {
            font-size: 0.75rem;
            color: var(--gray);
            margin-top: 2px;
            display: block;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background: var(--darker);
            color: var(--lighter);
            text-align: center;
            border-radius: 8px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            font-size: 0.85rem;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Rainbow animation for SSS tier */
        @keyframes rainbow {
            0% { background-color: #ff0000; }
            14% { background-color: #ff7f00; }
            28% { background-color: #ffff00; }
            42% { background-color: #00ff00; }
            57% { background-color: #0000ff; }
            71% { background-color: #4b0082; }
            85% { background-color: #9400d3; }
            100% { background-color: #ff0000; }
        }
        
        /* Kalendarz aktywności */
        .month-dot.clickable:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.4);
            border-color: var(--primary-light);
        }
        
        .year-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--glass-border);
        }
        
        .months-grid {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }
        
        /* Navbar styles */
        .semi-circle-nav {
            width: 80px;
            height: 100vh;
            background: rgba(30, 39, 46, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            left: 0;
            top: 0;
            border-radius: 0 24px 24px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }
        
        .nav-item {
            padding: 14px 0;
            margin: 6px 0;
            color: var(--gray);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
            text-align: center;
            width: 100%;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        
        .nav-item i {
            font-size: 1.2rem;
        }
        
        .nav-item:hover {
            color: var(--primary-light);
            transform: translateX(8px);
        }
        
        .nav-item.active {
            color: white;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            border-radius: 12px 0 0 12px;
            transform: translateX(10px) scale(1.05);
            box-shadow: 4px 0 12px rgba(108, 92, 231, 0.4);
        }
        
        /* SSS item styles */
        .sss-item {
            animation: glow 2s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 400% 400%;
            animation: rainbow 3s linear infinite, glow 2s ease-in-out infinite alternate;
            z-index: 1;
            color: white;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #ff0000, 0 0 20px #ff0000;
            }
            to {
                box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #ff0000, 0 0 40px #ff0000;
            }
        }

        .sss-item::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0) 30%,
                rgba(255, 255, 255, 0.5) 45%,
                rgba(255, 255, 255, 0) 60%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(30deg);
            animation: shine 3s infinite;
            z-index: -1;
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%) rotate(30deg);
            }
            100% {
                transform: translateX(100%) rotate(30deg);
            }
        }
        
        /* Floating action button */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 20px rgba(108, 92, 231, 0.4);
            cursor: pointer;
            z-index: 100;
            transition: var(--transition);
            border: none;
        }
        
        .fab:hover {
            transform: translateY(-5px) scale(1.1);
            background: var(--primary-dark);
            box-shadow: 0 6px 24px rgba(108, 92, 231, 0.5);
        }
        
        /* Image upload styles */
        .image-upload-container {
            margin-bottom: 1.5rem;
        }
        
        .image-preview {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px dashed var(--glass-border);
            border-radius: 8px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .image-preview-placeholder {
            text-align: center;
            color: var(--gray);
            padding: 20px;
        }
        
        .image-preview-placeholder i {
            font-size: 3rem;
            margin-bottom: 10px;
            display: block;
            color: var(--primary-light);
        }
        
        .remove-image-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.8;
            transition: var(--transition);
            z-index: 2;
        }
        
        .remove-image-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        /* Responsive styles */
        @media (max-width: 992px) {
            .container {
                padding-left: 90px;
            }
            
            .semi-circle-nav {
                width: 70px;
            }
            
            .nav-item {
                font-size: 0;
                padding: 16px 0;
            }
            
            .nav-item i {
                font-size: 1.3rem;
            }
            
            .nav-item.active {
                transform: translateX(8px);
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding-left: 0;
            }
            
            .container {
                padding: 15px;
                padding-bottom: 80px;
            }
            
            .semi-circle-nav {
                width: 100%;
                height: 60px;
                bottom: 0;
                top: auto;
                flex-direction: row;
                border-radius: 24px 24px 0 0;
                justify-content: space-around;
                padding: 0 10px;
            }
            
            .nav-item {
                font-size: 0.7rem;
                padding: 8px 4px;
                margin: 0;
                width: auto;
            }
            
            .nav-item i {
                font-size: 1.1rem;
            }
            
            .nav-item.active {
                transform: translateY(-8px);
                border-radius: 12px 12px 0 0;
            }
            
            .anime-list {
                grid-template-columns: 1fr;
            }
            
            .tier-controls {
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 10px;
                scrollbar-width: none;
            }
            
            .tier-controls::-webkit-scrollbar {
                display: none;
            }
            
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            
            .fab {
                bottom: 80px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }
        
            .anime-card {
                min-height: 350px;
            }
        }
    
        @media (max-width: 480px) {
            .section {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .tier-label {
                width: 60px;
                font-size: 1rem;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .actions button {
                width: 100%;
            }
        }
        .seasons-progress {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .odcinki-row:hover {
            background: rgba(255,255,255,0.05);
        }
        #collection-controls {
            padding: 16px 0 0 0;
            min-height: 48px;
        }
        
        /* Planner styles */
        .planner-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }
        
        .planner-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .planner-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .planner-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }
        
        /* Activity Calendar Styles */
        .activity-calendar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .calendar-year {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .calendar-nav {
            display: flex;
            gap: 0.5rem;
        }
        
        .calendar-nav-btn {
            background: var(--primary);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .calendar-nav-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px;
            align-items: start;
        }
        
        .calendar-labels {
            display: grid;
            grid-template-rows: repeat(7, 1fr);
            gap: 4px;
            font-size: 0.8rem;
            color: var(--gray);
            text-align: right;
            padding-right: 8px;
        }
        
        .calendar-months {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 4px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            color: var(--gray);
            text-align: center;
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            gap: 2px;
        }
        
        .calendar-day {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            border: 1px solid transparent;
        }
        
        .calendar-day:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        
        .calendar-day.empty {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .calendar-day.level-0 {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .calendar-day.level-1 {
            background: var(--primary-light);
        }
        
        .calendar-day.level-2 {
            background: var(--primary);
        }
        
        .calendar-day.level-3 {
            background: var(--primary-dark);
        }
        
        .calendar-day.level-4 {
            background: var(--accent);
        }
        
        .calendar-day.level-5 {
            background: var(--secondary);
        }
        
        .calendar-tooltip {
            position: absolute;
            background: var(--darker);
            color: var(--lighter);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .calendar-day:hover .calendar-tooltip {
            opacity: 1;
        }
        
        /* Episode counter modal */
        .episode-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .episode-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .episode-modal-content {
            background: var(--darker);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
        }
        
        .episode-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .episode-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .episode-modal-close:hover {
            color: var(--lighter);
        }
        
        .episode-counter {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .episode-counter-btn {
            background: var(--primary);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: var(--transition);
        }
        
        .episode-counter-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }
        
        .episode-counter-value {
            font-size: 1.5rem;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .add-episode-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .add-episode-btn:hover {
            background: #00a383;
            transform: translateY(-1px);
        }
        
        /* Day summary modal */
        .day-summary-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .day-summary-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .day-summary-content {
            background: var(--darker);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .day-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .day-summary-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .day-summary-close:hover {
            color: var(--lighter);
        }
        
        .day-summary-date {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .day-summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .day-summary-stat {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            border: 1px solid var(--glass-border);
        }
        
        .day-summary-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-stat-label {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-list {
            margin-top: 1.5rem;
        }
        
        .day-summary-anime-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .day-summary-anime-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
        }
        
        .day-summary-anime-title {
            font-weight: 600;
            color: var(--lighter);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-anime-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-episodes {
            color: var(--primary);
            font-weight: 500;
        }
        
        .day-summary-anime-time {
            color: var(--accent);
            font-weight: 500;
        }
        
        .day-summary-empty {
            text-align: center;
            color: var(--gray);
            font-style: italic;
            padding: 2rem;
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge.priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-badge.priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-badge.priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .planner-notes {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 1rem 0;
            font-style: italic;
            color: var(--gray);
            border-left: 3px solid var(--primary);
        }
        
        .planner-actions {
            display: flex;
            gap: 0.8rem;
            margin-top: 1rem;
        }
        
        .planner-actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        .anime-tag {background: var(--primary-light); color: var(--dark); border-radius: 12px; padding: 2px 10px; font-size: 0.85em; font-weight: 500; margin-right: 2px;}
    </style>
</head>
<body>
    <nav class="semi-circle-nav">
        <a href="#profil" class="nav-item"><i class="fas fa-user"></i><span>Profil</span></a>
        <a href="#dodaj" class="nav-item active"><i class="fas fa-plus"></i><span>Dodaj</span></a>
        <a href="#lista" class="nav-item"><i class="fas fa-list"></i><span>Lista</span></a>
        <a href="#tier-lista" class="nav-item"><i class="fas fa-layer-group"></i><span>Tier Lista</span></a>
        <a href="#planer" class="nav-item"><i class="fas fa-calendar-alt"></i><span>Planer</span></a>
        <a href="#eksport" class="nav-item"><i class="fas fa-file-export"></i><span>Eksport</span></a>
    </nav>

    <div class="container">
        <h1><i class="fas fa-film"></i> Anime Toolkit</h1>
        
        <div class="section" id="profil">
            <h2><i class="fas fa-chart-line"></i> Twoje statystyki</h2>
            <div class="stats-container" id="profile-stats">
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-star"></i> Ocena ogólna</div>
                    <div class="stat-value" id="average-rating">0.0</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="average-rating-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-clock"></i> Czas oglądania</div>
                    <div class="stat-value time-display" id="total-time">0h</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-check-circle"></i> Obejrzane</div>
                    <div class="stat-value" id="total-completed">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-bookmark"></i> Planowane</div>
                    <div class="stat-value" id="total-upcoming">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-eye"></i> Oglądane</div>
                    <div class="stat-value" id="total-watching">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-database"></i> Wszystkie</div>
                    <div class="stat-value" id="total-all">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-tasks"></i> Postęp</div>
                    <div class="stat-value" id="watch-progress">0%</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="watch-progress-bar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div id="profile-tags-stats" style="margin-top:2rem;"></div>
            
            <!-- Kalendarz aktywności -->
            <div class="activity-calendar">
                <h3><i class="fas fa-calendar-alt"></i> Kalendarz aktywności</h3>
                <div id="calendar-container"></div>
            </div>
        </div>
        
        <div id="profile-anime-list" style="display:none;margin-top:1.5rem;"></div>
        
        <div class="section" id="dodaj">
            <h2 id="form-title"><i class="fas fa-plus-circle"></i> Dodaj nowe anime</h2>
            <form id="anime-form">
                <input type="hidden" id="edit-id">
                
                <div class="form-group">
                    <label for="title"><i class="fas fa-heading"></i> Tytuł anime</label>
                    <input type="text" id="title" required placeholder="Wpisz tytuł anime">
                </div>
                
                <div class="form-group">
                    <label for="anime-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                    <input type="text" id="anime-tags" placeholder="np. isekai; komedia; sport">
                </div>
                
                <div class="form-group">
                    <label for="status"><i class="fas fa-bookmark"></i> Status</label>
                    <select id="status" required>
                        <option value="watching">Oglądane</option>
                        <option value="completed">Obejrzane</option>
                        <option value="upcoming">Nadchodzące</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                    <input type="number" id="season-count" min="1" value="1">
                </div>
                <div class="form-group" id="seasons-container" style="display:none;"></div>
                <div class="form-group">
                    <label for="total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                    <input type="number" id="total-episodes" min="1" value="12">
                </div>
                
                <div class="form-group">
                    <label for="episode-length"><i class="fas fa-clock"></i> Długość odcinka (minuty)</label>
                    <input type="number" id="episode-length" min="1" value="24">
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="watched-episodes"><i class="fas fa-eye"></i> Obejrzane odcinki</label>
                    <input type="number" id="watched-episodes" min="0" value="0">
                </div>
                
                <div class="form-group">
                    <label for="watch-date"><i class="fas fa-calendar"></i> Data oglądania</label>
                    <div style="display:flex;gap:0.5rem;align-items:center;">
                        <input type="date" id="watch-date" style="flex:1;">
                        <button type="button" id="no-date-btn" class="btn-secondary" style="white-space:nowrap;">
                            <i class="fas fa-question-circle"></i> Nie pamiętam
                        </button>
                    </div>
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Możesz dodać datę oglądania lub kliknąć "Nie pamiętam" jeśli nie pamiętasz kiedy oglądałeś.
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="activity-episodes"><i class="fas fa-calendar-check"></i> Aktywność oglądania (opcjonalne)</label>
                    <div style="display:flex;gap:0.5rem;align-items:center;">
                        <input type="number" id="activity-episodes" min="1" placeholder="Liczba odcinków" style="flex:1;">
                        <input type="date" id="activity-date" style="flex:1;">
                    </div>
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Możesz dodać ile odcinków obejrzałeś w konkretnym dniu. To pomoże w śledzeniu aktywności.
                    </small>
                </div>
                
                <div class="form-group image-upload-container">
                    <label><i class="fas fa-image"></i> Obrazek anime</label>
                    <input type="file" id="image-upload" accept="image/*" style="display: none;">
                    <button type="button" id="upload-btn" class="btn-accent" style="width: 100%;"><i class="fas fa-upload"></i> Wybierz obrazek</button>
                    <div class="image-preview" id="image-preview">
                        <div class="image-preview-placeholder">
                            <i class="fas fa-image"></i>
                            <span>Brak wybranego obrazka</span>
                        </div>
                    </div>
                </div>
                
                <h3><i class="fas fa-star"></i> Oceny (1-11)</h3>
                <div class="rating-container">
                    <span class="rating-label">Grafika:</span>
                    <input type="number" id="graphics" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Muzyka:</span>
                    <input type="number" id="music" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Postacie:</span>
                    <input type="number" id="characters" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Fabuła:</span>
                    <input type="number" id="story" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Śmieszność:</span>
                    <input type="number" id="fun" min="1" max="11" value="5" required>
                </div>
                
                <div class="average-rating">
                    <i class="fas fa-calculator"></i> Średnia ocena: <span id="average-display">5</span>
                </div>
                
                <div class="actions">
                    <button type="submit" class="btn-success" id="submit-btn"><i class="fas fa-plus"></i> Dodaj anime</button>
                    <button type="button" class="btn-secondary" id="cancel-edit" style="display: none;"><i class="fas fa-times"></i> Anuluj</button>
                </div>
            </form>
        </div>
        
        <div class="section" id="lista">
            <h2><i class="fas fa-list-ul"></i> Twoja kolekcja</h2>
            <div style="display:flex;align-items:center;gap:1rem;margin-bottom:1rem;flex-wrap:wrap;">
                <label for="sort-select" style="font-weight:500;">Sortuj po:</label>
                <select id="sort-select" style="padding:8px 16px;border-radius:8px;">
                    <option value="title">Tytule (A-Z)</option>
                    <option value="averageRating">Średniej ocenie</option>
                    <option value="graphics">Grafice</option>
                    <option value="music">Muzyce</option>
                    <option value="characters">Postaciach</option>
                    <option value="story">Fabule</option>
                    <option value="fun">Śmieszności</option>
                </select>
                <input type="text" id="search-input" placeholder="Szukaj anime..." style="flex:1;min-width:180px;padding:8px 16px;border-radius:8px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.2);color:var(--lighter);">
            </div>
            <div class="anime-list" id="anime-list">
                <div class="no-anime">Nie dodałeś jeszcze żadnego anime. Dodaj pierwsze używając formularza powyżej!</div>
            </div>
            <div id="collection-controls" style="display:flex;gap:1rem;justify-content:center;margin-top:1.5rem;"></div>
        </div>
        
        <div class="section tier-list" id="tier-lista">
            <h2><i class="fas fa-trophy"></i> Tier Lista</h2>
            
            <div class="tier-controls">
                <button class="tier-category-btn active" data-category="average"><i class="fas fa-star"></i> Średnia</button>
                <button class="tier-category-btn" data-category="graphics"><i class="fas fa-paint-brush"></i> Grafika</button>
                <button class="tier-category-btn" data-category="music"><i class="fas fa-music"></i> Muzyka</button>
                <button class="tier-category-btn" data-category="characters"><i class="fas fa-users"></i> Postacie</button>
                <button class="tier-category-btn" data-category="story"><i class="fas fa-book"></i> Fabuła</button>
                <button class="tier-category-btn" data-category="fun"><i class="fas fa-laugh"></i> Śmieszność</button>
            </div>
            
            <div id="tier-list-container">
                <div class="tier-row">
                    <div class="tier-label tier-SSS">SSS</div>
                    <div class="tier-items" id="tier-SSS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-SS">SS</div>
                    <div class="tier-items" id="tier-SS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-S">S</div>
                    <div class="tier-items" id="tier-S"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-A">A</div>
                    <div class="tier-items" id="tier-A"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-B">B</div>
                    <div class="tier-items" id="tier-B"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-C">C</div>
                    <div class="tier-items" id="tier-C"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-D">D</div>
                    <div class="tier-items" id="tier-D"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-F">F</div>
                    <div class="tier-items" id="tier-F"></div>
                </div>
            </div>
        </div>
        
        <div class="section" id="planer">
            <h2><i class="fas fa-calendar-alt"></i> Planer anime</h2>
            <div style="color:var(--gray);margin-bottom:1rem;font-size:1rem;">Dodaj anime do planera i ustaw priorytet oglądania.</div>
            
            <div class="form-group">
                <label for="planner-title"><i class="fas fa-heading"></i> Tytuł anime</label>
                <input type="text" id="planner-title" placeholder="Wpisz tytuł anime do planera">
            </div>
            <div class="form-group">
                <label for="planner-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                <input type="text" id="planner-tags" placeholder="np. akcja; dramat; fantasy">
            </div>
            
            <div class="form-group">
                <label for="planner-season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                <input type="number" id="planner-season-count" min="1" value="1">
            </div>
            <div class="form-group" id="planner-seasons-container" style="display:none;"></div>
            <div class="form-group">
                <label for="planner-total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                <input type="number" id="planner-total-episodes" min="1" value="12">
                <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                    <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                </small>
            </div>
            
            <div class="form-group">
                <label for="planner-priority"><i class="fas fa-flag"></i> Priorytet</label>
                <select id="planner-priority">
                    <option value="niski">Niski</option>
                    <option value="średni" selected>Średni</option>
                    <option value="duży">Duży</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="planner-notes"><i class="fas fa-sticky-note"></i> Notatki (opcjonalnie)</label>
                <textarea id="planner-notes" placeholder="Dodaj notatki o anime..." rows="3" style="width:100%;padding:12px 16px;background:rgba(0,0,0,0.2);border:1px solid var(--glass-border);border-radius:8px;font-size:1rem;color:var(--lighter);resize:vertical;"></textarea>
            </div>
            
            <div class="actions">
                <button type="button" id="add-to-planner" class="btn-accent"><i class="fas fa-plus"></i> Dodaj do planera</button>
            </div>
            
            <div style="margin-top:2rem;">
                <h3><i class="fas fa-list"></i> Lista planowanych anime</h3>
                <div id="planner-list">
                    <div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>
                </div>
            </div>
        </div>
        
        <div class="section" id="eksport">
            <h2><i class="fas fa-file-export"></i> Zarządzanie danymi</h2>
            <div class="actions">
                <button id="export-btn" class="btn-accent"><i class="fas fa-file-export"></i> Eksportuj dane</button>
                <button id="import-btn" class="btn-accent"><i class="fas fa-file-import"></i> Importuj dane</button>
                <input type="file" id="import-file" accept=".json" style="display: none;">
                <button id="clear-btn" class="btn-danger"><i class="fas fa-trash"></i> Wyczyść dane</button>
            </div>
        </div>
    </div>

    <button class="fab" id="scroll-top-btn" title="Przewiń do góry"><i class="fas fa-arrow-up"></i></button>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Load anime list from localStorage
            let animeList = JSON.parse(localStorage.getItem('animeList')) || [];
            let plannerList = JSON.parse(localStorage.getItem('plannerList')) || [];
            let activityData = JSON.parse(localStorage.getItem('activityData')) || {};
            let activityDetails = JSON.parse(localStorage.getItem('activityDetails')) || {};
            let currentTierCategory = 'average';
            let collectionPage = 1;
            const collectionPageSize = 3;
            let showAllCollection = false;
            let currentSort = 'title';
            let currentSearch = '';
            let currentYear = new Date().getFullYear();
            
            // Form elements
            const animeForm = document.getElementById('anime-form');
            const formTitle = document.getElementById('form-title');
            const submitBtn = document.getElementById('submit-btn');
            const cancelEditBtn = document.getElementById('cancel-edit');
            const editIdInput = document.getElementById('edit-id');
            
            // Image upload elements
            const uploadBtn = document.getElementById('upload-btn');
            const imageUpload = document.getElementById('image-upload');
            const imagePreview = document.getElementById('image-preview');
            let currentImageData = null;
            
            // Rating inputs
            const ratingInputs = [
                document.getElementById('graphics'),
                document.getElementById('music'),
                document.getElementById('characters'),
                document.getElementById('story'),
                document.getElementById('fun')
            ];
            
            // Average display
            const averageDisplay = document.getElementById('average-display');
            
            // Tier category buttons
            const tierCategoryBtns = document.querySelectorAll('.tier-category-btn');
            
            // Export/Import buttons
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const clearBtn = document.getElementById('clear-btn');
            
            // Scroll to top button
            const scrollTopBtn = document.getElementById('scroll-top-btn');

            // Anime list container (przeniesione na górę)
            const animeListContainer = document.getElementById('anime-list');
            
            // Format time function
            function formatTime(minutes, format = 'hours') {
                const hours = minutes / 60;
                const days = hours / 24;
                const months = days / 30;
                const years = days / 365;
                
                switch(format) {
                    case 'hours':
                        const roundedHours = Math.round(hours * 10) / 10;
                        return roundedHours % 1 === 0 ? `${roundedHours}h` : `${roundedHours.toFixed(1)}h`;
                    case 'days':
                        return `${Math.round(days * 10) / 10}d`;
                    case 'months':
                        return `${Math.round(months * 10) / 10}m`;
                    case 'years':
                        return `${Math.round(years * 10) / 10}y`;
                    default:
                        const h = Math.floor(minutes / 60);
                        const m = minutes % 60;
                        return `${h}h ${m}m`;
                }
            }

            // Calculate average rating
            function calculateAverage() {
                let sum = 0;
                let count = 0;
                
                ratingInputs.forEach(input => {
                    const value = parseInt(input.value);
                    if (!isNaN(value) && value >= 1 && value <= 11) {
                        sum += value;
                        count++;
                    }
                });
                
                const average = count > 0 ? Math.round(sum / count) : 0;
                averageDisplay.textContent = average;
                return average;
            }
            
            // Update average when any rating changes
            ratingInputs.forEach(input => {
                input.addEventListener('change', calculateAverage);
                input.addEventListener('input', calculateAverage);
            });
            
            // Obsługa zdjęć anime
            uploadBtn.addEventListener('click', function() {
                imageUpload.value = '';
                imageUpload.click();
            });

            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!file.type.startsWith('image/')) {
                    showNotification('Proszę wybrać plik obrazu!', 'danger');
                    imageUpload.value = '';
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(ev) {
                    currentImageData = ev.target.result;
                    showImagePreview(currentImageData);
                };
                reader.readAsDataURL(file);
            });

            function showImagePreview(imageData) {
                imagePreview.innerHTML = `
                    <img src="${imageData}" alt="Podgląd obrazka">
                `;
            }

            function showImagePlaceholder() {
                imagePreview.innerHTML = `
                    <div class="image-preview-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Brak wybranego obrazka</span>
                    </div>
                `;
            }

            function resetImageUpload() {
                currentImageData = null;
                showImagePlaceholder();
                imageUpload.value = '';
            }

            // Form submission
            animeForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                const title = document.getElementById('title').value.trim();
                if (!title) {
                    alert('Proszę wprowadzić tytuł anime');
                    return;
                }
                
                const status = document.getElementById('status').value;
                const seasonCount = parseInt(document.getElementById('season-count').value);
                let seasons = [];
                let seasonRewatches = [];
                let seasonEpisodeLengths = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#seasons-container .season-episodes');
                    const rewatchInputs = document.querySelectorAll('#seasons-container .season-rewatch');
                    const episodeLengthInputs = document.querySelectorAll('#seasons-container .season-episode-length');
                    seasonInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                    });
                    rewatchInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonRewatches.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v); // domyślnie 24 minuty
                    });
                }
                const totalEpisodes = parseInt(document.getElementById('total-episodes').value) || 12;
                const episodeLength = parseInt(document.getElementById('episode-length').value) || 24;
                const watchedEpisodes = parseInt(document.getElementById('watched-episodes').value) || 0;
                const watchDate = document.getElementById('watch-date').value;
                const graphics = parseInt(document.getElementById('graphics').value);
                const music = parseInt(document.getElementById('music').value);
                const characters = parseInt(document.getElementById('characters').value);
                const story = parseInt(document.getElementById('story').value);
                const fun = parseInt(document.getElementById('fun').value);
                const averageRating = calculateAverage();
                
                const tagsRaw = document.getElementById('anime-tags').value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                
                // Sprawdź aktywność oglądania
                const activityEpisodes = parseInt(document.getElementById('activity-episodes').value) || 0;
                const activityDate = document.getElementById('activity-date').value;
                
                if (activityEpisodes > 0 && activityDate) {
                    addActivity(activityDate, activityEpisodes);
                }
                
                const animeData = {
                    id: editIdInput.value ? parseInt(editIdInput.value) : Date.now(),
                    title,
                    status,
                    totalEpisodes,
                    episodeLength,
                    watchedEpisodes,
                    watchDate: watchDate || null,
                    ratings: {
                        graphics,
                        music,
                        characters,
                        story,
                        fun
                    },
                    averageRating,
                    createdAt: new Date().toISOString(),
                    tags
                };
                
                if (seasons.length > 1) {
                    animeData.seasons = seasons;
                    animeData.seasonRewatches = seasonRewatches;
                    animeData.seasonEpisodeLengths = seasonEpisodeLengths;
                }
                
                // Add image data if available
                if (currentImageData) {
                    animeData.image = currentImageData;
                } else if (editIdInput.value) {
                    // If editing and no new image selected, keep the existing one
                    const existingAnime = animeList.find(a => a.id === parseInt(editIdInput.value));
                    if (existingAnime && existingAnime.image) {
                        animeData.image = existingAnime.image;
                    }
                }
                
                if (editIdInput.value) {
                    // Update existing anime
                    const index = animeList.findIndex(a => a.id === animeData.id);
                    if (index !== -1) {
                        animeList[index] = animeData;
                    }
                    cancelEdit();
                } else {
                    // Add new anime
                    animeList.push(animeData);
                    
                    // If adding new anime with image, refresh the page
                    if (currentImageData) {
                        saveAnimeList();
                        window.location.reload();
                        return;
                    }
                }
                
                // Sort by title
                animeList.sort((a, b) => a.title.localeCompare(b.title));
                
                saveAnimeList();
                renderAnimeList();
                renderTierList();
                updateProfileStats();
                
                // Reset form (except when editing)
                if (!editIdInput.value) {
                    animeForm.reset();
                    document.getElementById('total-episodes').value = 12;
                    document.getElementById('episode-length').value = 24;
                    document.getElementById('watched-episodes').value = 0;
                    document.getElementById('watch-date').value = '';
                    document.getElementById('season-count').value = 1;
                    document.getElementById('graphics').value = 5;
                    document.getElementById('music').value = 5;
                    document.getElementById('characters').value = 5;
                    document.getElementById('story').value = 5;
                    document.getElementById('fun').value = 5;
                    calculateAverage();
                    
                    // Clear activity fields
                    document.getElementById('activity-episodes').value = '';
                    document.getElementById('activity-date').value = '';
                    
                    // Clear image
                    resetImageUpload();
                    
                    // Reset seasons container
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                    
                    // Show success notification
                    showNotification('Anime zostało dodane!', 'success');
                } else {
                    showNotification('Zmiany zostały zapisane!', 'success');
                }
            });
            
            // Obsługa przycisku "Nie pamiętam"
            document.getElementById('no-date-btn').addEventListener('click', function() {
                document.getElementById('watch-date').value = '';
            });
            
            // Cancel edit
            cancelEditBtn.addEventListener('click', cancelEdit);
            
            function cancelEdit() {
                editIdInput.value = '';
                formTitle.innerHTML = '<i class="fas fa-plus-circle"></i> Dodaj nowe anime';
                submitBtn.innerHTML = '<i class="fas fa-plus"></i> Dodaj anime';
                cancelEditBtn.style.display = 'none';
                animeForm.reset();
                document.getElementById('total-episodes').value = 12;
                document.getElementById('episode-length').value = 24;
                document.getElementById('watched-episodes').value = 0;
                document.getElementById('watch-date').value = '';
                document.getElementById('season-count').value = 1;
                document.getElementById('graphics').value = 5;
                document.getElementById('music').value = 5;
                document.getElementById('characters').value = 5;
                document.getElementById('story').value = 5;
                document.getElementById('fun').value = 5;
                calculateAverage();
                // Clear image
                resetImageUpload();
                // Reset seasons container
                seasonsContainer.innerHTML = '';
                seasonsContainer.style.display = 'none';
                totalEpisodesInput.readOnly = false;
            }
            
            // Save anime list to localStorage
            function saveAnimeList() {
                localStorage.setItem('animeList', JSON.stringify(animeList));
            }
            
            // Save planner list to localStorage
            function savePlannerList() {
                localStorage.setItem('plannerList', JSON.stringify(plannerList));
            }
            
            // Update profile statistics
            function updateProfileStats() {
                const completedAnime = animeList.filter(a => a.status === 'completed');
                const watchingAnime = animeList.filter(a => a.status === 'watching');
                const ratedAnime = animeList.filter(a => a.status !== 'upcoming');
                const upcomingAnime = animeList.filter(a => a.status === 'upcoming');
                const allAnime = animeList;
                
                // Total completed anime
                document.getElementById('total-completed').textContent = completedAnime.length;
                document.getElementById('total-upcoming').textContent = plannerList.length;
                document.getElementById('total-watching').textContent = watchingAnime.length;
                document.getElementById('total-all').textContent = allAnime.length;

                // Calculate average rating
                const ratedAnimeForAvg = animeList.filter(a => a.averageRating > 0);
                let averageRating = 0;
                if (ratedAnimeForAvg.length > 0) {
                    const totalRating = ratedAnimeForAvg.reduce((sum, anime) => sum + anime.averageRating, 0);
                    averageRating = Math.round((totalRating / ratedAnimeForAvg.length) * 10) / 10; // Zaokrąglenie do 1 miejsca po przecinku
                }
                
                // Update average rating display
                document.getElementById('average-rating').textContent = averageRating.toFixed(1);
                const averageRatingBar = document.getElementById('average-rating-bar');
                const percentage = (averageRating / 11) * 100; // 11 to maksymalna ocena
                averageRatingBar.style.width = percentage + '%';

                // Calculate watch progress
                const totalEpisodes = animeList.reduce((sum, anime) => sum + anime.totalEpisodes, 0);
                const watchedEpisodes = animeList.reduce((sum, anime) => {
                    if (anime.status === 'completed') {
                        return sum + anime.totalEpisodes;
                    } else {
                        return sum + anime.watchedEpisodes;
                    }
                }, 0);
                
                const watchProgress = totalEpisodes > 0 ? Math.round((watchedEpisodes / totalEpisodes) * 100) : 0;
                document.getElementById('watch-progress').textContent = watchProgress + '%';
                const watchProgressBar = document.getElementById('watch-progress-bar');
                watchProgressBar.style.width = watchProgress + '%';

                
                // Total watch time (including rewatches)
                let totalMinutes = 0;
                let totalRewatchMinutes = 0;
                
                animeList.forEach(anime => {
                    let animeTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            animeTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        animeTime = watchedEpisodes * anime.episodeLength;
                    }
                    
                    totalMinutes += animeTime;
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((rewatchCount, index) => {
                            if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                totalRewatchMinutes += rewatchCount * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych
                        totalRewatchMinutes += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                });

                const totalTimeElement = document.getElementById('total-time');
                let timeFormat = localStorage.getItem('timeFormat') || 'hours';
                
                totalTimeElement.textContent = formatTime(totalMinutes + totalRewatchMinutes, timeFormat);
                totalTimeElement.title = `Podstawowy czas: ${formatTime(totalMinutes)}\nRewatche: ${formatTime(totalRewatchMinutes)}`;
                totalTimeElement.dataset.minutes = totalMinutes + totalRewatchMinutes;
                
                // Kliknięcie na kafelki statystyk - przewijanie do odpowiednich sekcji
                const statsCards = document.querySelectorAll('#profile-stats .stat-card');
                
                // Ocena ogólna - pokazuje szczegółowe statystyki ocen
                if (statsCards[0]) {
                    statsCards[0].classList.add('clickable');
                    statsCards[0].title = 'Kliknij, aby zobaczyć szczegółowe statystyki ocen';
                    statsCards[0].addEventListener('click', function() {
                        renderRatingBreakdown();
                    });
                }
                
                // Czas oglądania - pokazuje szczegółowy breakdown
                if (statsCards[1]) {
                    statsCards[1].classList.add('clickable');
                    statsCards[1].title = 'Kliknij, aby zobaczyć szczegółowy breakdown czasu oglądania';
                    statsCards[1].addEventListener('click', function() {
                        renderTimeBreakdown();
                    });
                }
                
                // Obejrzane - pokazuje listę obejrzanych anime
                if (statsCards[2]) {
                    statsCards[2].classList.add('clickable');
                    statsCards[2].title = 'Kliknij, aby zobaczyć listę obejrzanych anime';
                    statsCards[2].addEventListener('click', function() {
                        renderProfileAnimeList('completed');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Planowane - pokazuje listę planowanych anime
                if (statsCards[3]) {
                    statsCards[3].classList.add('clickable');
                    statsCards[3].title = 'Kliknij, aby zobaczyć listę planowanych anime';
                    statsCards[3].addEventListener('click', function() {
                        renderProfileAnimeList('upcoming');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Oglądane - pokazuje listę oglądanych anime
                if (statsCards[4]) {
                    statsCards[4].classList.add('clickable');
                    statsCards[4].title = 'Kliknij, aby zobaczyć listę oglądanych anime';
                    statsCards[4].addEventListener('click', function() {
                        renderProfileAnimeList('watching');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Wszystkie - pokazuje wszystkie anime
                if (statsCards[5]) {
                    statsCards[5].classList.add('clickable');
                    statsCards[5].title = 'Kliknij, aby zobaczyć wszystkie anime';
                    statsCards[5].addEventListener('click', function() {
                        renderProfileAnimeList('all');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Postęp - pokazuje listę anime z postępem
                if (statsCards[6]) {
                    statsCards[6].classList.add('clickable');
                    statsCards[6].title = 'Kliknij, aby zobaczyć postęp oglądania';
                    statsCards[6].addEventListener('click', function() {
                        renderProgressBreakdown();
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }

                // Renderuj statystyki tagów
                renderTagsStats();
                
                // Renderuj kalendarz aktywności
                renderActivityCalendar();
            }

            // Statystyki tagów na profilu
            function renderTagsStats() {
                const container = document.getElementById('profile-tags-stats');
                if (!animeList.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                // Zbierz wszystkie tagi
                const tagMap = {};
                animeList.forEach(anime => {
                    if (anime.tags && Array.isArray(anime.tags)) {
                        anime.tags.forEach(tag => {
                            if (!tagMap[tag]) tagMap[tag] = {count:0, totalMinutes:0, ratings:[], animeCount:0};
                            tagMap[tag].animeCount++;
                            // Czas oglądania
                            let animeTime = 0;
                            
                            if (anime.seasons && anime.seasons.length > 1) {
                                // Oblicz czas dla każdego sezonu osobno
                                let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                anime.seasons.forEach((episodeCount, index) => {
                                    const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                                    const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                        ? anime.seasonEpisodeLengths[index] 
                                        : anime.episodeLength;
                                    animeTime += watchedThis * episodeLength;
                                    watched -= watchedThis;
                                });
                            } else {
                                const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                animeTime = watchedEpisodes * anime.episodeLength;
                            }
                            
                            // Rewatche
                            if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                                anime.seasonRewatches.forEach((rewatchCount, index) => {
                                    if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                        const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                            ? anime.seasonEpisodeLengths[index] 
                                            : anime.episodeLength;
                                        animeTime += rewatchCount * anime.seasons[index] * episodeLength;
                                    }
                                });
                            } else if (anime.rewatchCount) {
                                animeTime += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                            }
                            tagMap[tag].totalMinutes += animeTime;
                            tagMap[tag].ratings.push(anime.averageRating);
                        });
                    }
                });
                const tags = Object.keys(tagMap).sort((a,b)=>a.localeCompare(b));
                if (!tags.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                let html = `<h3 style='margin-bottom:1rem;'><i class="fas fa-tags"></i> Statystyki tagów</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tag</th>
                    <th style='text-align:left;padding:8px 4px;'>Liczba anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Czas łącznie</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                tags.forEach(tag => {
                    const t = tagMap[tag];
                    const avg = t.ratings.length ? (t.ratings.reduce((a,b)=>a+b,0)/t.ratings.length).toFixed(2) : '-';
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;'><span class='anime-tag tag-clickable' data-tag="${encodeURIComponent(tag)}">${tag}</span></td>
                        <td style='padding:8px 4px;'>${t.animeCount}</td>
                        <td style='padding:8px 4px;'>${formatTime(t.totalMinutes)}</td>
                        <td style='padding:8px 4px;'>${avg}</td>
                    </tr>`;
                });
                html += `</tbody></table></div>`;
                container.innerHTML = html;

                // Dodaj obsługę kliknięcia na tag
                container.querySelectorAll('.tag-clickable').forEach(el => {
                    el.style.cursor = 'pointer';
                    el.title = 'Pokaż anime z tym tagiem';
                    el.addEventListener('click', function(e) {
                        const tag = decodeURIComponent(this.dataset.tag);
                        renderProfileAnimeListByTag(tag);
                    });
                });
            }
            
            // Kalendarz aktywności
            function renderActivityCalendar() {
                const container = document.getElementById('calendar-container');
                if (!animeList.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak danych aktywności do wyświetlenia</div>';
                    return;
                }
                
                // Zbierz anime z datami oglądania
                const animeWithDates = animeList.filter(anime => anime.watchDate);
                if (!animeWithDates.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Dodaj daty oglądania do swoich anime, aby zobaczyć kalendarz aktywności</div>';
                    return;
                }
                
                // Grupuj anime według roku i miesiąca
                const activityData = {};
                animeWithDates.forEach(anime => {
                    const date = new Date(anime.watchDate);
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    
                    if (!activityData[year]) {
                        activityData[year] = {};
                    }
                    if (!activityData[year][month]) {
                        activityData[year][month] = {
                            count: 0,
                            anime: [],
                            totalMinutes: 0
                        };
                    }
                    
                    activityData[year][month].count++;
                    activityData[year][month].anime.push(anime);
                    
                    // Oblicz czas oglądania
                    let animeTime = 0;
                    if (anime.seasons && anime.seasons.length > 1) {
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            animeTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        animeTime = watchedEpisodes * anime.episodeLength;
                    }
                    
                    // Dodaj rewatche
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((rewatchCount, index) => {
                            if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                animeTime += rewatchCount * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        animeTime += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    activityData[year][month].totalMinutes += animeTime;
                });
                
                // Znajdź maksymalną aktywność dla normalizacji
                let maxActivity = 0;
                Object.values(activityData).forEach(yearData => {
                    Object.values(yearData).forEach(monthData => {
                        maxActivity = Math.max(maxActivity, monthData.count);
                    });
                });
                
                // Renderuj kalendarz
                const years = Object.keys(activityData).sort((a, b) => parseInt(b) - parseInt(a));
                let html = '';
                
                years.forEach(year => {
                    html += `<div class="year-section" style="margin-bottom:2rem;">
                        <h4 style="margin-bottom:1rem;color:var(--primary);">${year}</h4>
                        <div class="months-grid" style="display:grid;grid-template-columns:repeat(12,1fr);gap:0.5rem;margin-bottom:1rem;">`;
                    
                    const months = ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'];
                    
                    for (let month = 0; month < 12; month++) {
                        const monthData = activityData[year][month];
                        if (monthData) {
                            const intensity = maxActivity > 0 ? (monthData.count / maxActivity) : 0;
                            const opacity = 0.3 + (intensity * 0.7); // 0.3 do 1.0
                            const backgroundColor = `rgba(108, 92, 231, ${opacity})`; // var(--primary)
                            
                            html += `<div class="month-dot clickable" 
                                data-year="${year}" 
                                data-month="${month}" 
                                style="
                                    width:30px;height:30px;border-radius:50%;background:${backgroundColor};
                                    display:flex;align-items:center;justify-content:center;cursor:pointer;
                                    border:2px solid var(--glass-border);transition:var(--transition);
                                    font-size:0.8rem;font-weight:500;color:white;
                                "
                                title="${months[month]} ${year} - ${monthData.count} anime (${formatTime(monthData.totalMinutes)})">
                                ${monthData.count}
                            </div>`;
                        } else {
                            html += `<div class="month-dot" 
                                style="
                                    width:30px;height:30px;border-radius:50%;background:rgba(255,255,255,0.1);
                                    display:flex;align-items:center;justify-content:center;
                                    border:2px solid var(--glass-border);font-size:0.8rem;color:var(--gray);
                                ">
                                -
                            </div>`;
                        }
                    }
                    
                    html += `</div></div>`;
                });
                
                container.innerHTML = html;
                
                // Dodaj obsługę kliknięcia na miesiąc
                container.querySelectorAll('.month-dot.clickable').forEach(dot => {
                    dot.addEventListener('click', function() {
                        const year = this.dataset.year;
                        const month = this.dataset.month;
                        const monthData = activityData[year][month];
                        showMonthSummary(year, month, monthData);
                    });
                });
            }
            
            // Podsumowanie miesiąca
            function showMonthSummary(year, month, monthData) {
                const months = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                
                // Analiza tagów
                const tagStats = {};
                monthData.anime.forEach(anime => {
                    if (anime.tags && Array.isArray(anime.tags)) {
                        anime.tags.forEach(tag => {
                            if (!tagStats[tag]) tagStats[tag] = 0;
                            tagStats[tag]++;
                        });
                    }
                });
                
                // Analiza dni tygodnia
                const dayStats = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}; // 0 = niedziela
                monthData.anime.forEach(anime => {
                    const date = new Date(anime.watchDate);
                    const dayOfWeek = date.getDay();
                    dayStats[dayOfWeek]++;
                });
                
                const daysOfWeek = ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'];
                const mostActiveDay = Object.keys(dayStats).reduce((a, b) => dayStats[a] > dayStats[b] ? a : b);
                
                // Top tagi
                const topTags = Object.entries(tagStats)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([tag, count]) => `${tag} (${count})`)
                    .join(', ');
                
                let html = `<div class="month-summary-modal" style="
                    position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);
                    display:flex;align-items:center;justify-content:center;z-index:1000;
                ">
                    <div style="
                        background:var(--glass);backdrop-filter:blur(10px);border-radius:16px;
                        padding:2rem;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;
                        border:1px solid var(--glass-border);box-shadow:var(--shadow);
                    ">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="color:var(--primary);">${months[month]} ${year}</h3>
                            <button class="btn-secondary" onclick="this.closest('.month-summary-modal').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <h4 style="margin-bottom:0.5rem;color:var(--accent);">📊 Statystyki</h4>
                            <p><strong>Obejrzane anime:</strong> ${monthData.count}</p>
                            <p><strong>Czas oglądania:</strong> ${formatTime(monthData.totalMinutes)}</p>
                            <p><strong>Średnio na anime:</strong> ${formatTime(Math.round(monthData.totalMinutes / monthData.count))}</p>
                        </div>
                        
                        ${topTags ? `<div style="margin-bottom:1.5rem;">
                            <h4 style="margin-bottom:0.5rem;color:var(--accent);">🏷️ Najpopularniejsze tagi</h4>
                            <p>${topTags}</p>
                        </div>` : ''}
                        
                        <div style="margin-bottom:1.5rem;">
                            <h4 style="margin-bottom:0.5rem;color:var(--accent);">📅 Aktywność w dni tygodnia</h4>
                            <div style="display:grid;grid-template-columns:repeat(7,1fr);gap:0.5rem;margin-top:0.5rem;">
                                ${daysOfWeek.map((day, index) => {
                                    const count = dayStats[index];
                                    const isMostActive = index == mostActiveDay;
                                    return `<div style="
                                        text-align:center;padding:0.5rem;border-radius:8px;
                                        background:${isMostActive ? 'var(--primary)' : 'rgba(255,255,255,0.1)'};
                                        color:${isMostActive ? 'white' : 'var(--light)'};
                                        font-weight:${isMostActive ? '600' : '400'};
                                    ">
                                        <div style="font-size:0.8rem;">${day.slice(0, 3)}</div>
                                        <div style="font-size:1.2rem;font-weight:600;">${count}</div>
                                    </div>`;
                                }).join('')}
                            </div>
                            <p style="margin-top:0.5rem;font-size:0.9rem;color:var(--gray);">
                                <i class="fas fa-star"></i> Najbardziej aktywny dzień: <strong>${daysOfWeek[mostActiveDay]}</strong>
                            </p>
                        </div>
                        
                        <div>
                            <h4 style="margin-bottom:0.5rem;color:var(--accent);">📺 Lista obejrzanych anime</h4>
                            <div style="max-height:200px;overflow-y:auto;">
                                ${monthData.anime.map(anime => `
                                    <div style="
                                        padding:0.5rem;margin-bottom:0.5rem;border-radius:8px;
                                        background:rgba(255,255,255,0.05);border:1px solid var(--glass-border);
                                    ">
                                        <div style="font-weight:500;">${anime.title}</div>
                                        <div style="font-size:0.8rem;color:var(--gray);">
                                            ${new Date(anime.watchDate).toLocaleDateString('pl-PL')} • 
                                            ${anime.tags ? anime.tags.join(', ') : 'Brak tagów'}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>`;
                
                document.body.insertAdjacentHTML('beforeend', html);
            }
            
            // Render anime list
            function renderAnimeList() {
                let sortedList = [...animeList];
                // Filtrowanie po wyszukiwaniu
                if (currentSearch.trim() !== '') {
                    const searchLower = currentSearch.trim().toLowerCase();
                    // Obsługa wyszukiwania po tagach: tag:nazwa
                    const tagMatch = searchLower.match(/^tag:(.+)$/);
                    if (tagMatch) {
                        const tagQuery = tagMatch[1].trim();
                        sortedList = sortedList.filter(anime => anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(tagQuery)));
                    } else {
                        sortedList = sortedList.filter(anime =>
                            anime.title.toLowerCase().includes(searchLower)
                            || (anime.status && anime.status.toLowerCase().includes(searchLower))
                            || (anime.ratings && Object.values(anime.ratings).some(val => (val+''||'').includes(searchLower)))
                            || (anime.averageRating+''||'').includes(searchLower)
                            || (anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(searchLower)))
                        );
                    }
                }
                // Sortowanie
                switch(currentSort) {
                    case 'averageRating':
                        sortedList.sort((a, b) => b.averageRating - a.averageRating || a.title.localeCompare(b.title));
                        break;
                    case 'graphics':
                        sortedList.sort((a, b) => b.ratings.graphics - a.ratings.graphics || a.title.localeCompare(b.title));
                        break;
                    case 'music':
                        sortedList.sort((a, b) => b.ratings.music - a.ratings.music || a.title.localeCompare(b.title));
                        break;
                    case 'characters':
                        sortedList.sort((a, b) => b.ratings.characters - a.ratings.characters || a.title.localeCompare(b.title));
                        break;
                    case 'story':
                        sortedList.sort((a, b) => b.ratings.story - a.ratings.story || a.title.localeCompare(b.title));
                        break;
                    case 'fun':
                        sortedList.sort((a, b) => b.ratings.fun - a.ratings.fun || a.title.localeCompare(b.title));
                        break;
                    case 'title':
                    default:
                        sortedList.sort((a, b) => a.title.localeCompare(b.title));
                        break;
                }
                // Paginacja
                let toShow;
                if (showAllCollection) {
                    toShow = sortedList;
                } else {
                    toShow = sortedList.slice(0, collectionPage * collectionPageSize);
                }
                if (sortedList.length === 0) {
                    animeListContainer.innerHTML = '<div class="no-anime">Nie znaleziono anime.' + (currentSearch ? ' Spróbuj innego hasła.' : ' Dodaj pierwsze używając formularza powyżej!') + '</div>';
                    document.getElementById('collection-controls').innerHTML = '';
                    return;
                }
                animeListContainer.innerHTML = '';
                toShow.forEach(anime => {
                    const animeCard = document.createElement('div');
                    animeCard.className = 'anime-card';
                    animeCard.dataset.id = anime.id;
                    
                    // Ustawianie tła tylko jeśli jest zdjęcie
                    if (anime.image) {
                        animeCard.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(${anime.image})`;
                        animeCard.style.backgroundSize = 'cover';
                        animeCard.style.backgroundPosition = 'center';
                    } else {
                        animeCard.style.backgroundImage = '';
                        animeCard.style.background = '';
                    }
                    
                    let statusClass = '';
                    let statusText = '';
                    
                    switch(anime.status) {
                        case 'watching':
                            statusClass = 'status-watching';
                            statusText = 'Oglądane';
                            break;
                        case 'completed':
                            statusClass = 'status-completed';
                            statusText = 'Obejrzane';
                            break;
                        case 'upcoming':
                            statusClass = 'status-upcoming';
                            statusText = 'Nadchodzące';
                            break;
                    }
                    
                    // Calculate watch progress
                    const watchProgress = anime.status === 'completed' ? 100 : 
                                        Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    
                    // Calculate watch time (including rewatches)
                    let mainTime = 0;
                    let rewatchTime = 0;
                    let rewatchCount = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        mainTime = anime.watchedEpisodes * anime.episodeLength;
                    }
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                                rewatchCount += count;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych - rewatchCount to liczba odcinków, nie liczba pełnych rewatchów
                        rewatchTime = anime.rewatchCount * anime.episodeLength;
                        rewatchCount = anime.rewatchCount;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    let episodesText = `${anime.watchedEpisodes}/${anime.totalEpisodes} (${watchProgress}%)`;
                    if (anime.rewatchCount && anime.rewatchCount > 0) {
                        episodesText += ` <span class="rewatch-info">(+${anime.rewatchCount} rewatch)</span>`;
                    }
                    let seasonsProgressHtml = '';
                    let hasSeasons = anime.seasons && anime.seasons.length > 1;
                    if (hasSeasons) {
                        // Przygotuj HTML z progressem sezonów (ukryty domyślnie)
                        let watched = anime.watchedEpisodes;
                        seasonsProgressHtml = `<div class='seasons-progress' id='seasons-progress-${anime.id}' style='display:none;margin-top:8px;transition:max-height 0.3s;overflow:hidden;'>`;
                        anime.seasons.forEach((count, idx) => {
                            let watchedThis = Math.max(0, Math.min(watched, count));
                            let percent = Math.round((watchedThis/count)*100);
                            let rewatchInfo = '';
                            if (anime.seasonRewatches && anime.seasonRewatches[idx] > 0) {
                                rewatchInfo = ` <span style='color:var(--primary);font-size:0.8em;'>(+${anime.seasonRewatches[idx]}x rewatch)</span>`;
                            }
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[idx] 
                                ? anime.seasonEpisodeLengths[idx] 
                                : anime.episodeLength;
                            seasonsProgressHtml += `<div>Sezon ${idx+1}: ${watchedThis}/${count} (${percent}%) - ${episodeLength}min${rewatchInfo}</div>`;
                            watched -= watchedThis;
                        });
                        seasonsProgressHtml += `</div>`;
                    }
                    
                    let tagHtml = '';
                    if (anime.tags && anime.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${anime.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    animeCard.innerHTML = `
                        <div class="anime-title">${anime.title}</div>
                        <span class="anime-status ${statusClass}">${statusText}</span>
                        ${tagHtml}
                        <div class="rating-container odcinki-row" data-id="${anime.id}" style="cursor:${hasSeasons ? 'pointer' : 'default'};">
                            <span class="rating-label">Odcinki:</span>
                            <span class="rating-value">${episodesText}${hasSeasons ? " <span style=\"font-size:0.8em;opacity:0.7;\">(kliknij)</span>" : ''}</span>
                        </div>
                        ${seasonsProgressHtml}
                        
                        <div class="rating-container">
                            <span class="rating-label">Czas:</span>
                            <span class="tooltip rating-value time-display" 
                                  title="Podstawowy: ${formatTime(mainTime)}\n${rewatchCount > 0 ? `Rewatch: ${formatTime(rewatchTime)}` : ''}">
                                ${formatTime(totalTime, 'hours')}
                                ${rewatchCount > 0 ? `<span class="rewatch-info">(${rewatchCount}x rewatch)</span>` : ''}
                            </span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Grafika:</span>
                            <span class="rating-value">${anime.ratings.graphics}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Muzyka:</span>
                            <span class="rating-value">${anime.ratings.music}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Postacie:</span>
                            <span class="rating-value">${anime.ratings.characters}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Fabuła:</span>
                            <span class="rating-value">${anime.ratings.story}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Śmieszność:</span>
                            <span class="rating-value">${anime.ratings.fun}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Średnia:</span>
                            <span class="rating-value">${anime.averageRating}</span>
                        </div>
                        
                        <div class="actions">
                            <button class="add-episodes-btn btn-success" data-id="${anime.id}" title="Dodaj odcinki">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button class="edit-btn" data-id="${anime.id}"><i class="fas fa-edit"></i> Edytuj</button>
                            <button class="delete-btn btn-danger" data-id="${anime.id}"><i class="fas fa-trash"></i> Usuń</button>
                        </div>
                    `;
                    
                    // NIE dodaję podglądu obrazka ani przycisku usuwania zdjęcia
                    animeListContainer.appendChild(animeCard);
                });
                
                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        if (confirm('Czy na pewno chcesz usunąć to anime z listy?')) {
                            const id = parseInt(this.dataset.id);
                            animeList = animeList.filter(anime => anime.id !== id);
                            saveAnimeList();
                            renderAnimeList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Anime zostało usunięte!', 'danger');
                        }
                    });
                });
                
                // Add event listeners for add episodes buttons
                document.querySelectorAll('.add-episodes-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        showEpisodeModal(id);
                    });
                });
                
                // Add event listeners for edit buttons
                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const animeToEdit = animeList.find(anime => anime.id === id);
                        
                        if (animeToEdit) {
                            document.getElementById('title').value = animeToEdit.title;
                            document.getElementById('status').value = animeToEdit.status;
                            document.getElementById('total-episodes').value = animeToEdit.totalEpisodes;
                            document.getElementById('episode-length').value = animeToEdit.episodeLength;
                            document.getElementById('watched-episodes').value = animeToEdit.watchedEpisodes;
                            document.getElementById('watch-date').value = animeToEdit.watchDate || '';
                            document.getElementById('graphics').value = animeToEdit.ratings.graphics;
                            document.getElementById('music').value = animeToEdit.ratings.music;
                            document.getElementById('characters').value = animeToEdit.ratings.characters;
                            document.getElementById('story').value = animeToEdit.ratings.story;
                            document.getElementById('fun').value = animeToEdit.ratings.fun;
                            document.getElementById('anime-tags').value = animeToEdit.tags ? animeToEdit.tags.join('; ') : '';
                            editIdInput.value = animeToEdit.id;
                            
                            // Set image preview if available
                            if (animeToEdit.image) {
                                currentImageData = animeToEdit.image;
                                showImagePreview(currentImageData);
                                // Dodaję przycisk Usuń zdjęcie pod podglądem
                                imagePreview.innerHTML += `<button type='button' id='remove-image-btn' class='btn-danger' style='width:100%;margin-top:8px;'><i class='fas fa-trash'></i> Usuń zdjęcie</button>`;
                                document.getElementById('remove-image-btn').onclick = function() {
                                    if (confirm('Czy na pewno chcesz usunąć zdjęcie?')) {
                                        animeToEdit.image = null;
                                        currentImageData = null;
                                        showImagePlaceholder();
                                    }
                                };
                            } else {
                                currentImageData = null;
                                showImagePlaceholder();
                            }

                            // Fill season inputs if needed
                            fillSeasonInputsIfNeeded(animeToEdit);
                            
                            formTitle.innerHTML = '<i class="fas fa-edit"></i> Edytuj anime';
                            submitBtn.innerHTML = '<i class="fas fa-save"></i> Zapisz zmiany';
                            cancelEditBtn.style.display = 'inline-block';
                            
                            calculateAverage();
                            
                            // Scroll to form
                            document.getElementById('dodaj').scrollIntoView({ behavior: 'smooth' });
                        }
                    });
                });

                // Paginacja - pokaż przycisk "Załaduj więcej" jeśli są jeszcze anime do załadowania
                const collectionControls = document.getElementById('collection-controls');
                if (sortedList.length > collectionPage * collectionPageSize) {
                    collectionControls.innerHTML = `<button id="load-more-btn" class="btn-accent"><i class="fas fa-plus"></i> Załaduj więcej (${sortedList.length - (collectionPage * collectionPageSize)} pozostałych)</button>`;
                } else {
                    collectionControls.innerHTML = '';
                }
                const loadMoreBtn = document.getElementById('load-more-btn');
                if (loadMoreBtn) {
                    loadMoreBtn.onclick = function() {
                        collectionPage++;
                        renderAnimeList();
                    };
                }

                // Dodaj event listener na animeListContainer
                animeListContainer.addEventListener('click', function(event) {
                    const target = event.target;
                    if (target.classList.contains('rating-value')) {
                        const row = target.closest('.odcinki-row');
                        const id = parseInt(row.dataset.id);
                        const anime = animeList.find(a => a.id === id);
                        if (anime && anime.seasons && anime.seasons.length > 1) {
                            const seasonsProgress = document.getElementById(`seasons-progress-${id}`);
                            if (seasonsProgress) {
                                seasonsProgress.style.display = seasonsProgress.style.display === 'none' ? 'block' : 'none';
                            }
                        }
                    }
                });
            }
            
            // Render tier list
            function renderTierList() {
                // Clear all tiers
                document.getElementById('tier-SSS').innerHTML = '';
                document.getElementById('tier-SS').innerHTML = '';
                document.getElementById('tier-S').innerHTML = '';
                document.getElementById('tier-A').innerHTML = '';
                document.getElementById('tier-B').innerHTML = '';
                document.getElementById('tier-C').innerHTML = '';
                document.getElementById('tier-D').innerHTML = '';
                document.getElementById('tier-F').innerHTML = '';
                
                animeList.forEach(anime => {
                    const tierItem = document.createElement('div');
                    tierItem.className = 'tier-item';
                    tierItem.textContent = anime.title;
                    tierItem.title = `Średnia: ${anime.averageRating}\nGrafika: ${anime.ratings.graphics}\nMuzyka: ${anime.ratings.music}\nPostacie: ${anime.ratings.characters}\nFabuła: ${anime.ratings.story}\nŚmieszność: ${anime.ratings.fun}`;
                    
                    // Determine which tier to place the anime in based on current category
                    let rating;
                    if (currentTierCategory === 'average') {
                        rating = anime.averageRating;
                    } else {
                        rating = anime.ratings[currentTierCategory];
                    }
                    
                    if (rating === 11) {
                        tierItem.classList.add('sss-item');
                        document.getElementById('tier-SSS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 10) {
                        document.getElementById('tier-SS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 9) {
                        document.getElementById('tier-S').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 8) {
                        document.getElementById('tier-A').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 6 && rating <= 7) {
                        document.getElementById('tier-B').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 5) {
                        document.getElementById('tier-C').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 3 && rating <= 4) {
                        document.getElementById('tier-D').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 1 && rating <= 2) {
                        document.getElementById('tier-F').appendChild(tierItem.cloneNode(true));
                    }
                });
            }
            
            // Render planner list
            function renderPlannerList() {
                const plannerContainer = document.getElementById('planner-list');
                
                if (plannerList.length === 0) {
                    plannerContainer.innerHTML = '<div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>';
                    return;
                }
                
                // Sort by priority (duży -> średni -> niski)
                const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                const sortedPlanner = [...plannerList].sort((a, b) => {
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                });
                
                plannerContainer.innerHTML = '';
                
                sortedPlanner.forEach(item => {
                    const plannerCard = document.createElement('div');
                    plannerCard.className = 'planner-card';
                    plannerCard.dataset.id = item.id;
                    
                    let notesHtml = '';
                    if (item.notes && item.notes.trim()) {
                        notesHtml = `<div class="planner-notes"><i class="fas fa-sticky-note"></i> ${item.notes}</div>`;
                    }
                    
                    let tagHtml = '';
                    if (item.tags && item.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${item.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    plannerCard.innerHTML = `
                        <div class="anime-title">${item.title}</div>
                        ${tagHtml}
                        <span class="priority-badge priority-${item.priority}">Priorytet: ${item.priority}</span>
                        <div style="margin-bottom:8px;color:var(--gray);font-size:0.95em;">
                            ${item.seasonCount ? `Sezony: <b>${item.seasonCount}</b>` : ''}
                            ${item.totalEpisodes ? `&nbsp;Odcinki: <b>${item.totalEpisodes}</b>` : ''}
                            ${item.seasonEpisodeLengths && item.seasonEpisodeLengths.length > 1 ? 
                                `<br><span style="font-size:0.85em;">Długości: ${item.seasonEpisodeLengths.map((len, idx) => `S${idx+1}: ${len}min`).join(', ')}</span>` : ''}
                        </div>
                        ${notesHtml}
                        <div class="planner-actions">
                            <button class="start-watching-btn btn-success" data-id="${item.id}">
                                <i class="fas fa-play"></i> Zacznij oglądać
                            </button>
                            <button class="edit-planner-btn btn-secondary" data-id="${item.id}">
                                <i class="fas fa-edit"></i> Edytuj
                            </button>
                            <button class="delete-planner-btn btn-danger" data-id="${item.id}">
                                <i class="fas fa-trash"></i> Usuń
                            </button>
                        </div>
                    `;
                    
                    plannerContainer.appendChild(plannerCard);
                });
                
                // Add event listeners
                document.querySelectorAll('.start-watching-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            // Add to anime list as "upcoming" (Nadchodzące)
const animeData = {
    id: Date.now(),
    title: plannerItem.title,
    status: 'watching',
    totalEpisodes: (plannerItem.seasons && plannerItem.seasons.length > 1)
        ? plannerItem.seasons.reduce((a, b) => a + b, 0)
        : (plannerItem.totalEpisodes || 12),
    episodeLength: 24,
    watchedEpisodes: 0,
    rewatchCount: 0,
    ratings: {
        graphics: 5,
        music: 5,
        characters: 5,
        story: 5,
        fun: 5
    },
    averageRating: 5,
    createdAt: new Date().toISOString(),
    seasons: plannerItem.seasons,
    seasonEpisodeLengths: plannerItem.seasonEpisodeLengths
};
                            
                            animeList.push(animeData);
                            saveAnimeList();
                            
                            // Remove from planner
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            
                            // Update displays
                            renderAnimeList();
                            renderPlannerList();
                            updateProfileStats();
                            
                            showNotification(`"${plannerItem.title}" zostało dodane do nadchodzących!`, 'success');
                        }
                    });
                });
                
                document.querySelectorAll('.edit-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            document.getElementById('planner-title').value = plannerItem.title;
                            document.getElementById('planner-priority').value = plannerItem.priority;
                            document.getElementById('planner-notes').value = plannerItem.notes || '';
                            plannerTagsInput.value = plannerItem.tags ? plannerItem.tags.join('; ') : '';
                            
                            // Fill season inputs if needed
                            if (plannerItem.seasons && plannerItem.seasons.length > 1) {
                                plannerSeasonCountInput.value = plannerItem.seasons.length;
                                plannerSeasonCountInput.dispatchEvent(new Event('input'));
                                const episodeLengthValues = plannerItem.seasonEpisodeLengths || [];
                                setTimeout(() => {
                                    const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                                    const episodeLengthInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episode-length');
                                    seasonInputs.forEach((input, index) => {
                                        if (plannerItem.seasons[index]) {
                                            input.value = plannerItem.seasons[index];
                                        }
                                    });
                                    episodeLengthInputs.forEach((input, index) => {
                                        if (episodeLengthValues[index] !== undefined) {
                                            input.value = episodeLengthValues[index];
                                        } else {
                                            input.value = 24; // domyślna długość
                                        }
                                    });
                                    updatePlannerTotalEpisodesFromSeasons();
                                }, 10);
                            } else {
                                plannerSeasonCountInput.value = 1;
                                plannerSeasonsContainer.innerHTML = '';
                                plannerSeasonsContainer.style.display = 'none';
                                plannerTotalEpisodesInput.readOnly = false;
                            }
                            
                            // Change button text
                            const addBtn = document.getElementById('add-to-planner');
                            addBtn.innerHTML = '<i class="fas fa-save"></i> Zapisz zmiany';
                            addBtn.dataset.editId = id;
                            
                            // Scroll to planner form
                            const plannerSection = document.getElementById('planer');
                            plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                });
                
                document.querySelectorAll('.delete-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem && confirm(`Czy na pewno chcesz usunąć "${plannerItem.title}" z planera?`)) {
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            renderPlannerList();
                            showNotification('Anime zostało usunięte z planera!', 'danger');
                        }
                    });
                });
            }
            
            // Tier category switching
            tierCategoryBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentTierCategory = this.dataset.category;
                    
                    // Update active button
                    tierCategoryBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tier list
                    renderTierList();
                });
            });
            
            // Export data
            exportBtn.addEventListener('click', function() {
                const exportData = {
                    animeList: animeList,
                    plannerList: plannerList
                };
                const dataStr = JSON.stringify(exportData);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'anime-toolkit-data-'+new Date().toISOString().slice(0,10)+'.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showNotification('Dane zostały wyeksportowane!', 'success');
            });
            
            // Import data
            importBtn.addEventListener('click', function() {
                importFile.click();
            });
            
            importFile.addEventListener('change', function(event) {
                const file = event.target.files[0];
                
                if (!file) {
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (confirm('Czy na pewno chcesz zaimportować nowe dane? Obecne dane zostaną zastąpione.')) {
                            // Handle both old format (array) and new format (object)
                            if (Array.isArray(importedData)) {
                                // Old format - just anime list
                                animeList = importedData;
                                plannerList = [];
                            } else if (importedData.animeList && importedData.plannerList) {
                                // New format - both anime and planner data
                                animeList = importedData.animeList;
                                plannerList = importedData.plannerList;
                            } else {
                                showNotification('Nieprawidłowy format pliku!', 'danger');
                                return;
                            }
                            
                            saveAnimeList();
                            savePlannerList();
                            renderAnimeList();
                            renderPlannerList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Dane zostały zaimportowane!', 'success');
                        }
                    } catch (error) {
                        showNotification('Błąd podczas importowania pliku: ' + error.message, 'danger');
                    }
                    
                    // Reset file input
                    importFile.value = '';
                };
                reader.readAsText(file);
            });
            
            // Clear all data
            clearBtn.addEventListener('click', function() {
                if (confirm('Czy na pewno chcesz usunąć wszystkie dane? Tej operacji nie można cofnąć.')) {
                    animeList = [];
                    plannerList = [];
                    saveAnimeList();
                    savePlannerList();
                    renderAnimeList();
                    renderPlannerList();
                    renderTierList();
                    updateProfileStats();
                    showNotification('Wszystkie dane zostały usunięte!', 'danger');
                }
            });
            
            // Scroll to top button
            scrollTopBtn.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollTopBtn.style.display = 'flex';
                } else {
                    scrollTopBtn.style.display = 'none';
                }
            });
            
            // Navbar functionality
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);

                    // Przewiń do wybranej sekcji
                    window.scrollTo({top: targetSection.offsetTop - 80, behavior: 'smooth'});
                });
            });

            // Show notification
            function showNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 300);
                }, 3000);
            }
            
            // Add notification styles
            const style = document.createElement('style');
            style.textContent = `
                .notification {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    padding: 15px 25px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    transform: translateY(100px);
                    opacity: 0;
                    transition: all 0.3s ease;
                    z-index: 1000;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                }
                
                .notification.show {
                    transform: translateY(0);
                    opacity: 1;
                }
                
                .notification-success {
                    background: linear-gradient(90deg, var(--success), #00a383);
                    border-left: 5px solid #00a383;
                }
                
                .notification-danger {
                    background: linear-gradient(90deg, var(--danger), #c0392b);
                    border-left: 5px solid #c0392b;
                }
            `;
            document.head.appendChild(style);
            
            // Funkcja do śledzenia aktywnej sekcji
            function trackActiveSection() {
                const sections = document.querySelectorAll('.section');
                const navItems = document.querySelectorAll('.nav-item');
                
                let currentSection = '';
                
                sections.forEach(section => {
                    const sectionTop = section.offsetTop - 100;
                    const sectionBottom = sectionTop + section.offsetHeight;
                    
                    if (window.scrollY >= sectionTop && window.scrollY < sectionBottom) {
                        currentSection = section.id;
                    }
                });
                
                
                navItems.forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('href') === `#${currentSection}`) {
                        item.classList.add('active');
                    }
                });
            }

            // Nasłuchuj zdarzenia scroll
            window.addEventListener('scroll', trackActiveSection);

            // Wywołaj na początku, aby ustawić początkową sekcję
            trackActiveSection();
            
            // Initial render
            calculateAverage();
            renderAnimeList();
            renderPlannerList();
            renderTierList();
            updateProfileStats();

            const seasonCountInput = document.getElementById('season-count');
            const seasonsContainer = document.getElementById('seasons-container');
            const totalEpisodesInput = document.getElementById('total-episodes');

            function renderSeasonInputs(count, values=[], rewatchValues=[], episodeLengths=[]) {
                seasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const rewatchVal = rewatchValues[i] || 0;
                    const episodeLength = episodeLengths[i] || '';
                    seasonsContainer.innerHTML += `
                        <div style='margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:8px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                            <div style='margin-left:20px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-redo"></i> Rewatch:</label>
                                <input type='number' class='season-rewatch' min='0' value='${rewatchVal}' style='width:60px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);font-size:0.8rem;'>
                                <span style='margin-left:4px;color:var(--gray);font-size:0.8rem;'>razy</span>
                            </div>
                        </div>
                    `;
                }
                seasonsContainer.style.display = count > 1 ? '' : 'none';
                // Ustaw readonly na totalEpisodes jeśli jest więcej niż 1 sezon
                totalEpisodesInput.readOnly = count > 1;
            }

            function updateTotalEpisodesFromSeasons() {
                const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                totalEpisodesInput.value = sum > 0 ? sum : '';
            }

            seasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderSeasonInputs(count);
                } else {
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
                updateTotalEpisodesFromSeasons();
            });

            seasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('season-episodes')) {
                    updateTotalEpisodesFromSeasons();
                }
            });

            // Przy edycji anime, jeśli są sezony, wypełnij pola
            function fillSeasonInputsIfNeeded(anime) {
                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    seasonCountInput.value = anime.seasons.length;
                    // Trigger the input event to ensure the season inputs are rendered
                    seasonCountInput.dispatchEvent(new Event('input'));
                    const rewatchValues = anime.seasonRewatches || [];
                    const episodeLengthValues = anime.seasonEpisodeLengths || [];
                    // After the inputs are rendered, set the values
                    setTimeout(() => {
                        const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                        const rewatchInputs = seasonsContainer.querySelectorAll('.season-rewatch');
                        const episodeLengthInputs = seasonsContainer.querySelectorAll('.season-episode-length');
                        seasonInputs.forEach((input, index) => {
                            if (anime.seasons[index]) {
                                input.value = anime.seasons[index];
                            }
                        });
                        rewatchInputs.forEach((input, index) => {
                            if (rewatchValues[index] !== undefined) {
                                input.value = rewatchValues[index];
                            }
                        });
                        episodeLengthInputs.forEach((input, index) => {
                            if (episodeLengthValues[index] !== undefined) {
                                input.value = episodeLengthValues[index];
                            } else {
                                input.value = anime.episodeLength || 24; // fallback do głównej długości odcinka
                            }
                        });
                        updateTotalEpisodesFromSeasons();
                    }, 10);
                } else {
                    seasonCountInput.value = 1;
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
            }

            // Obsługa przycisku 'Pokaż sezony' (toggle)
            animeListContainer.addEventListener('click', function(e) {
                const row = e.target.closest('.odcinki-row');
                if (row) {
                    const id = row.dataset.id;
                    const el = document.getElementById('seasons-progress-' + id);
                    if (el) {
                        const isCurrentlyVisible = el.style.display !== 'none' && el.style.display !== '' ? true : el.style.display === '';
                        // Chowamy wszystkie inne
                        document.querySelectorAll("[id^='seasons-progress-']").forEach(function(other) {
                            if (other !== el) {
                                other.style.display = 'none';
                            }
                        });
                        // Jeśli kliknięty był widoczny, chowamy go; jeśli nie, pokazujemy
                        if (isCurrentlyVisible) {
                            el.style.display = 'none';
                        } else {
                            el.style.display = '';
                        }
                    }
                }
            });

            const sortSelect = document.getElementById('sort-select');
            const searchInput = document.getElementById('search-input');
            const collectionControls = document.getElementById('collection-controls');

            // Sortowanie select
            sortSelect.addEventListener('change', function() {
                currentSort = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Wyszukiwarka na bieżąco
            searchInput.addEventListener('input', function() {
                currentSearch = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Obsługa przycisków
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.onclick = function() {
                    collectionPage++;
                    renderAnimeList();
                };
            }
            const showAllBtn = document.getElementById('show-all-btn');
            if (showAllBtn) {
                showAllBtn.onclick = function() {
                    showAllCollection = true;
                    renderAnimeList();
                };
            }
            const showLessBtn = document.getElementById('show-less-btn');
            if (showLessBtn) {
                showLessBtn.onclick = function() {
                    showAllCollection = false;
                    collectionPage = 1;
                    renderAnimeList();
                };
            }

            // Obsługa kliknięcia na statystyki profilu
            function renderProfileAnimeList(type) {
                let list = [];
                let label = '';
                let sortBy = 'title';
                let sortDir = 'asc';
                // Zapamiętaj sortowanie dla tej listy
                if (!renderProfileAnimeList.sortState) renderProfileAnimeList.sortState = {};
                if (renderProfileAnimeList.sortState[type]) {
                    sortBy = renderProfileAnimeList.sortState[type].by;
                    sortDir = renderProfileAnimeList.sortState[type].dir;
                }
                if (type === 'completed') {
                    list = animeList.filter(a => a.status === 'completed');
                    label = 'Obejrzane';
                } else if (type === 'watching') {
                    list = animeList.filter(a => a.status === 'watching');
                    label = 'Oglądane';
                } else if (type === 'upcoming') {
                    list = plannerList;
                    label = 'Planowane';
                } else if (type === 'all') {
                    list = animeList;
                    label = 'Wszystkie';
                }
                // Sortowanie
                if (type === 'upcoming') {
                    // Dla planera sortuj po priorytecie
                    const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                    list = [...list].sort((a, b) => {
                        const cmp = priorityOrder[a.priority] - priorityOrder[b.priority];
                        return sortDir === 'asc' ? cmp : -cmp;
                    });
                } else {
                    // Dla głównej listy anime
                    if (sortBy === 'averageRating') {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.averageRating - b.averageRating : b.averageRating - a.averageRating);
                    } else if (sortBy === 'status') {
                        const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                        list = [...list].sort((a, b) => {
                            const cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            return sortDir === 'asc' ? cmp : -cmp;
                        });
                    } else {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.title.localeCompare(b.title) : b.title.localeCompare(a.title));
                    }
                }
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kategorii "${label}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label} anime</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                
                if (type === 'upcoming') {
                    // Dla planera
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-priority'>Priorytet ${sortBy==='priority'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;'>Notatki</th>
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        const priorityClass = `priority-${a.priority}`;
                        const notes = a.notes && a.notes.trim() ? a.notes : '-';
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'><span class='priority-badge ${priorityClass}' style='font-size:0.7rem;padding:2px 8px;'>${a.priority}</span></td>
                            <td style='padding:8px 4px;font-size:0.9rem;color:var(--gray);'>${notes}</td>
                        </tr>`;
                    });
                } else {
                    // Dla głównej listy anime
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-avg-rating'>Średnia ocena ${sortBy==='averageRating'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                            <td style='padding:8px 4px;'>${a.averageRating}</td>
                        </tr>`;
                    });
                }
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania po średniej ocenie
                document.getElementById('sort-avg-rating').onclick = function() {
                    if (sortBy === 'averageRating') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'averageRating';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-title').onclick = function() {
                    if (sortBy === 'title') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'title';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-status').onclick = function() {
                    if (sortBy === 'status') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'status';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                
                // Dla planera dodaj sortowanie po priorytecie
                if (type === 'upcoming') {
                    document.getElementById('sort-priority').onclick = function() {
                        if (sortBy === 'priority') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'priority';
                            sortDir = 'asc';
                        }
                        renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                        renderProfileAnimeList(type);
                    };
                }
            }
            
            // Render rating breakdown
            function renderRatingBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz statystyki ocen
                const ratedAnime = animeList.filter(a => a.averageRating > 0);
                
                if (ratedAnime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak ocenionych anime</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Oblicz średnie dla każdej kategorii
                const categories = ['graphics', 'music', 'characters', 'story', 'fun'];
                const categoryNames = {
                    'graphics': 'Grafika',
                    'music': 'Muzyka', 
                    'characters': 'Postacie',
                    'story': 'Fabuła',
                    'fun': 'Śmieszność'
                };
                
                const averages = {};
                categories.forEach(cat => {
                    const sum = ratedAnime.reduce((acc, anime) => acc + anime.ratings[cat], 0);
                    averages[cat] = (sum / ratedAnime.length).toFixed(2);
                });
                
                // Sortuj kategorie po średniej
                const sortedCategories = categories.sort((a, b) => parseFloat(averages[b]) - parseFloat(averages[a]));
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowe statystyki ocen</h3>`;
                html += `<div style='display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:1rem;margin-bottom:1rem;'>`;
                
                sortedCategories.forEach(cat => {
                    const avg = parseFloat(averages[cat]);
                    const percentage = (avg / 11) * 100;
                    const color = avg >= 8 ? 'var(--success)' : avg >= 6 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<div style='background:rgba(0,0,0,0.3);border-radius:8px;padding:1rem;text-align:center;'>
                        <div style='font-size:1.2rem;font-weight:600;color:${color};'>${avg}</div>
                        <div style='font-size:0.9rem;color:var(--gray);margin-bottom:0.5rem;'>${categoryNames[cat]}</div>
                        <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:6px;width:100%;'>
                            <div style='background:${color};height:100%;border-radius:4px;width:${percentage}%;'></div>
                        </div>
                    </div>`;
                });
                
                html += `</div>`;
                
                // Dodaj tabelę z najlepszymi anime w każdej kategorii
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Kategoria</th>
                    <th style='text-align:left;padding:8px 4px;'>Najlepsze anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Ocena</th>
                </tr></thead><tbody>`;
                
                categories.forEach(cat => {
                    const bestAnime = ratedAnime.reduce((best, current) => 
                        current.ratings[cat] > best.ratings[cat] ? current : best
                    );
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${categoryNames[cat]}</td>
                        <td style='padding:8px 4px;'>${bestAnime.title}</td>
                        <td style='padding:8px 4px;color:var(--primary);font-weight:600;'>${bestAnime.ratings[cat]}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render progress breakdown
            function renderProgressBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz postęp dla każdego anime
                const animeWithProgress = animeList.map(anime => {
                    const progress = anime.status === 'completed' ? 100 : 
                                   Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    return {
                        ...anime,
                        progress
                    };
                });
                
                if (animeWithProgress.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Sortuj po postępie (malejąco)
                animeWithProgress.sort((a, b) => b.progress - a.progress);
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Postęp oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Odcinki</th>
                    <th style='text-align:left;padding:8px 4px;'>Postęp</th>
                </tr></thead><tbody>`;
                
                animeWithProgress.forEach(anime => {
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : 
                                     anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const progressColor = anime.progress === 100 ? 'var(--success)' : 
                                        anime.progress >= 50 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${anime.watchedEpisodes}/${anime.totalEpisodes}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressColor};height:100%;border-radius:4px;width:${anime.progress}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${anime.progress}%</span>
                            </div>
                        </td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render time breakdown
            function renderTimeBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz czas dla każdego anime
                const animeWithTime = animeList.map(anime => {
                    let mainTime = 0;
                    let fullTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            fullTime += episodeCount * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        mainTime = watchedEpisodes * anime.episodeLength;
                        fullTime = anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    let rewatchTime = 0;
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        rewatchTime = anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    return {
                        ...anime,
                        mainTime,
                        rewatchTime,
                        totalTime,
                        fullTime
                    };
                }); // Pokaż wszystkie anime
                
                if (animeWithTime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                

                
                // Sortowanie dla czasu oglądania
                if (!renderTimeBreakdown.sortState) {
                    renderTimeBreakdown.sortState = { sortBy: 'totalTime', sortDir: 'desc' };
                }
                let sortBy = renderTimeBreakdown.sortState.sortBy;
                let sortDir = renderTimeBreakdown.sortState.sortDir;
                
                // Sortuj listę
                animeWithTime.sort((a, b) => {
                    let cmp = 0;
                    switch(sortBy) {
                        case 'title':
                            cmp = a.title.localeCompare(b.title);
                            break;
                        case 'status':
                            const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                            cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            break;
                        case 'totalTime':
                            cmp = a.totalTime - b.totalTime;
                            break;
                        case 'fullTime':
                            cmp = a.fullTime - b.fullTime;
                            break;
                        case 'progress':
                            const progressA = a.totalTime > 0 ? (a.totalTime / a.fullTime) * 100 : 0;
                            const progressB = b.totalTime > 0 ? (b.totalTime / b.fullTime) * 100 : 0;
                            cmp = progressA - progressB;
                            break;
                        case 'percentOfTotal':
                            cmp = a.percentOfTotal - b.percentOfTotal;
                            break;
                        default:
                            cmp = b.totalTime - a.totalTime;
                    }
                    return sortDir === 'asc' ? cmp : -cmp;
                });
                
                let totalWatchTime = animeWithTime.reduce((sum, anime) => sum + anime.totalTime, 0);
                // Dodaj percentOfTotal do każdego anime PRZED sortowaniem
                animeWithTime.forEach(anime => {
                    anime.percentOfTotal = totalWatchTime > 0 ? (anime.totalTime / totalWatchTime) * 100 : 0;
                });
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowy czas oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-total-time'>Czas oglądany ${sortBy==='totalTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-full-time'>Pełna długość ${sortBy==='fullTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-progress'>Postęp ${sortBy==='progress'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;'>% całości</th>
                </tr></thead><tbody>`;
                
                animeWithTime.forEach(anime => {
                    const progressPercent = anime.totalTime > 0 ? Math.round((anime.totalTime / anime.fullTime) * 100) : 0;
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const rewatchInfo = anime.rewatchTime > 0 ? ` <span style='color:var(--primary);font-size:0.8em;'>(+${formatTime(anime.rewatchTime)} rewatch)</span>` : '';
                    
                    // Dla anime z czasem 0, pokaż specjalny tekst
                    const timeDisplay = anime.totalTime > 0 ? `${formatTime(anime.totalTime)}${rewatchInfo}` : '0h';
                    const progressBarColor = anime.totalTime > 0 ? 'linear-gradient(90deg, var(--primary), var(--accent))' : 'rgba(255,255,255,0.2)';
                    const percentOfTotal = totalWatchTime > 0 ? ((anime.totalTime / totalWatchTime) * 100).toFixed(1) : '0.0';
                    anime.percentOfTotal = parseFloat(percentOfTotal); // for sorting
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${timeDisplay}</td>
                        <td style='padding:8px 4px;'>${formatTime(anime.fullTime)}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressBarColor};height:100%;border-radius:4px;width:${progressPercent}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${progressPercent}%</span>
                            </div>
                        </td>
                        <td style='padding:8px 4px;'>${anime.percentOfTotal.toFixed(1)}%</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania
                function assignTimeBreakdownSortHandlers() {
                    document.getElementById('sort-title').onclick = function() {
                        if (sortBy === 'title') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'title';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-status').onclick = function() {
                        if (sortBy === 'status') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'status';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-total-time').onclick = function() {
                        if (sortBy === 'totalTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'totalTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-full-time').onclick = function() {
                        if (sortBy === 'fullTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'fullTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-progress').onclick = function() {
                        if (sortBy === 'progress') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'progress';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                }
                assignTimeBreakdownSortHandlers();
            }
            
            // Podpinam kliknięcia na statystyki
            setTimeout(() => {
                document.getElementById('total-completed').parentElement.onclick = () => renderProfileAnimeList('completed');
                document.getElementById('total-upcoming').parentElement.onclick = () => renderProfileAnimeList('upcoming');
                document.getElementById('total-watching').parentElement.onclick = () => renderProfileAnimeList('watching');
                document.getElementById('total-all').parentElement.onclick = () => renderProfileAnimeList('all');

            }, 0);

            // Po wygenerowaniu kart anime w renderAnimeList:
            animeListContainer.querySelectorAll('.odcinki-row').forEach(row => {
                const clickable = row.querySelector('.rating-value');
                if (clickable) {
                    clickable.style.cursor = 'pointer';
                    clickable.onclick = function(e) {
                        e.stopPropagation();
                        const id = row.dataset.id;
                        const el = document.getElementById('seasons-progress-' + id);
                        if (el) {
                            el.style.display = (el.style.display === 'block') ? 'none' : 'block';
                        }
                    };
                }
            });
            
            // Planner functionality
            const addToPlannerBtn = document.getElementById('add-to-planner');
            const plannerTitleInput = document.getElementById('planner-title');
            const plannerPrioritySelect = document.getElementById('planner-priority');
            const plannerNotesTextarea = document.getElementById('planner-notes');
            const plannerTagsInput = document.getElementById('planner-tags');
            
            addToPlannerBtn.addEventListener('click', function() {
                const title = plannerTitleInput.value.trim();
                const priority = plannerPrioritySelect.value;
                const notes = plannerNotesTextarea.value.trim();
                const tagsRaw = plannerTagsInput.value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                const seasonCount = parseInt(plannerSeasonCountInput.value);
                let seasons = [];
                let seasonEpisodeLengths = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episodes');
                    const episodeLengthInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episode-length');
                    seasonInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v);
                    });
                }
                const totalEpisodes = parseInt(plannerTotalEpisodesInput.value) || 12;
                if (!title) {
                    showNotification('Proszę wprowadzić tytuł anime!', 'danger');
                    return;
                }
                // Check if editing
                const editId = this.dataset.editId;
                if (editId) {
                    // Update existing item
                    const index = plannerList.findIndex(item => item.id === parseInt(editId));
                    if (index !== -1) {
                        plannerList[index] = {
                            ...plannerList[index],
                            title,
                            priority,
                            notes,
                            seasonCount,
                            seasons: seasons.length > 1 ? seasons : undefined,
                            seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                            totalEpisodes,
                            tags
                        };
                        savePlannerList();
                        renderPlannerList();
                        showNotification('Anime zostało zaktualizowane w planerze!', 'success');
                    }
                    // Reset form
                    this.innerHTML = '<i class="fas fa-plus"></i> Dodaj do planera';
                    delete this.dataset.editId;
                } else {
                    // Add new item
                    const plannerItem = {
                        id: Date.now(),
                        title,
                        priority,
                        notes,
                        createdAt: new Date().toISOString(),
                        seasonCount,
                        seasons: seasons.length > 1 ? seasons : undefined,
                        seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                        totalEpisodes,
                        tags
                    };
                    plannerList.push(plannerItem);
                    savePlannerList();
                    renderPlannerList();
                    showNotification('Anime zostało dodane do planera!', 'success');
                }
                // Clear form
                plannerTitleInput.value = '';
                plannerPrioritySelect.value = 'średni';
                plannerNotesTextarea.value = '';
                plannerTagsInput.value = '';
                plannerSeasonCountInput.value = 1;
                plannerSeasonsContainer.innerHTML = '';
                plannerSeasonsContainer.style.display = 'none';
                plannerTotalEpisodesInput.value = 12;
            });
            
            // Initial render of planner
            renderPlannerList();
            
            // Initial render of activity calendar
            renderActivityCalendar();

            const plannerSeasonCountInput = document.getElementById('planner-season-count');
            const plannerSeasonsContainer = document.getElementById('planner-seasons-container');
            const plannerTotalEpisodesInput = document.getElementById('planner-total-episodes');

            function renderPlannerSeasonInputs(count, values=[], episodeLengths=[]) {
                plannerSeasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const episodeLength = episodeLengths[i] || '';
                    plannerSeasonsContainer.innerHTML += `
                        <div style='margin-bottom:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:4px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='planner-season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='planner-season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                        </div>
                    `;
                }
                plannerSeasonsContainer.style.display = count > 1 ? '' : 'none';
                plannerTotalEpisodesInput.readOnly = count > 1;
            }

            plannerSeasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderPlannerSeasonInputs(count);
                } else {
                    plannerSeasonsContainer.innerHTML = '';
                    plannerSeasonsContainer.style.display = 'none';
                    plannerTotalEpisodesInput.readOnly = false;
                }
                updatePlannerTotalEpisodesFromSeasons();
            });

            plannerSeasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('planner-season-episodes')) {
                    updatePlannerTotalEpisodesFromSeasons();
                }
            });

            function updatePlannerTotalEpisodesFromSeasons() {
                const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                plannerTotalEpisodesInput.value = sum > 0 ? sum : '';
            }

            // Funkcje kalendarza aktywności
            function saveActivityData() {
                localStorage.setItem('activityData', JSON.stringify(activityData));
                localStorage.setItem('activityDetails', JSON.stringify(activityDetails));
            }
            
            function getActivityLevel(episodes) {
                if (episodes === 0) return 0;
                if (episodes <= 2) return 1;
                if (episodes <= 4) return 2;
                if (episodes <= 6) return 3;
                if (episodes <= 8) return 4;
                return 5;
            }
            
            function renderActivityCalendar() {
                const container = document.getElementById('calendar-container');
                if (!container) return;
                
                const months = ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'];
                const days = ['Nie', 'Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-year">${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-year">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-year">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <div class="calendar-grid">
                        <div class="calendar-labels">
                            ${days.map(day => `<div>${day}</div>`).join('')}
                        </div>
                        <div>
                            <div class="calendar-months">
                                ${months.map(month => `<div>${month}</div>`).join('')}
                            </div>
                            <div class="calendar-days" id="calendar-days">
                            </div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-year').addEventListener('click', () => {
                    currentYear--;
                    renderActivityCalendar();
                });
                
                document.getElementById('next-year').addEventListener('click', () => {
                    currentYear++;
                    renderActivityCalendar();
                });
                
                // Renderuj dni
                renderCalendarDays();
            }
            
            function renderCalendarDays() {
                const daysContainer = document.getElementById('calendar-days');
                if (!daysContainer) return;
                
                const startDate = new Date(currentYear, 0, 1);
                const endDate = new Date(currentYear, 11, 31);
                
                // Znajdź pierwszy poniedziałek roku
                const firstMonday = new Date(startDate);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }
                
                let html = '';
                let currentDate = new Date(firstMonday);
                
                while (currentDate <= endDate) {
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const episodes = activityData[dateStr] || 0;
                    const level = getActivityLevel(episodes);
                    const isCurrentYear = currentDate.getFullYear() === currentYear;
                    
                    if (isCurrentYear) {
                        const tooltip = episodes > 0 ? 
                            `${dateStr}: ${episodes} odcinków` : 
                            `${dateStr}: Brak aktywności`;
                        
                        html += `
                            <div class="calendar-day level-${level}" data-date="${dateStr}" data-episodes="${episodes}">
                                <div class="calendar-tooltip">${tooltip}</div>
                            </div>
                        `;
                    } else {
                        html += `<div class="calendar-day empty"></div>`;
                    }
                    
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.calendar-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
            }
            
            function showDayDetails(date, episodes) {
                const modal = document.getElementById('day-summary-modal');
                const dateEl = document.getElementById('day-summary-date');
                const statsEl = document.getElementById('day-summary-stats');
                const animeListEl = document.getElementById('day-summary-anime-list');
                
                // Formatuj datę
                const dateObj = new Date(date);
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                dateEl.textContent = dateObj.toLocaleDateString('pl-PL', options);
                
                if (episodes > 0) {
                    const level = getActivityLevel(episodes);
                    const details = activityDetails[date] || [];
                    
                    // Oblicz rzeczywisty czas oglądania na podstawie szczegółów
                    let totalMinutes = 0;
                    details.forEach(detail => {
                        const anime = animeList.find(a => a.id === detail.animeId);
                        const episodeLength = anime ? anime.episodeLength : 24;
                        totalMinutes += detail.episodes * episodeLength;
                    });
                    
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    const timeString = hours > 0 ? 
                        `${hours}h ${minutes > 0 ? minutes + 'm' : ''}` : 
                        `${minutes}m`;
                    
                    // Statystyki
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${episodes}</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${timeString}</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${details.length}</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                    `;
                    
                    // Lista anime - grupuj według tytułu
                    if (details.length > 0) {
                        // Grupuj odcinki według tytułu anime
                        const groupedAnime = {};
                        details.forEach(detail => {
                            const title = detail.title;
                            if (!groupedAnime[title]) {
                                groupedAnime[title] = {
                                    title: title,
                                    episodes: 0,
                                    animeId: detail.animeId
                                };
                            }
                            groupedAnime[title].episodes += detail.episodes;
                        });
                        
                        let animeHtml = '';
                        Object.values(groupedAnime).forEach(group => {
                            const anime = animeList.find(a => a.id === group.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            const animeTime = group.episodes * episodeLength;
                            const animeHours = Math.floor(animeTime / 60);
                            const animeMinutes = animeTime % 60;
                            const animeTimeString = animeHours > 0 ? 
                                `${animeHours}h ${animeMinutes > 0 ? animeMinutes + 'm' : ''}` : 
                                `${animeMinutes}m`;
                            
                            animeHtml += `
                                <div class="day-summary-anime-item">
                                    <div class="day-summary-anime-title">${group.title}</div>
                                    <div class="day-summary-anime-details">
                                        <span class="day-summary-anime-episodes">
                                            <i class="fas fa-play-circle"></i> ${group.episodes} odcinków
                                        </span>
                                        <span class="day-summary-anime-time">
                                            <i class="fas fa-clock"></i> ${animeTimeString}
                                        </span>
                                    </div>
                                </div>
                            `;
                        });
                        animeListEl.innerHTML = animeHtml;
                    } else {
                        animeListEl.innerHTML = `
                            <div class="day-summary-empty">
                                <i class="fas fa-info-circle"></i>
                                Brak szczegółów oglądanych anime
                            </div>
                        `;
                    }
                } else {
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0h</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>

                    `;
                    
                    animeListEl.innerHTML = `
                        <div class="day-summary-empty">
                            <i class="fas fa-calendar-times"></i>
                            Brak aktywności tego dnia
                        </div>
                    `;
                }
                
                modal.classList.add('show');
            }
            
            function getAnimeForDate(date) {
                // Zwraca dane aktywności dla danego dnia
                const episodes = activityData[date] || 0;
                if (episodes > 0) {
                    return [{
                        title: 'Aktywność oglądania',
                        episodes: episodes
                    }];
                }
                return [];
            }
            
            function addActivity(date, episodes, animeId = null) {
                console.log('addActivity:', { date, episodes, animeId }); // Debug
                
                if (!activityData[date]) {
                    activityData[date] = 0;
                    activityDetails[date] = [];
                }
                activityData[date] += episodes;
                
                // Dodaj szczegóły aktywności
                if (animeId) {
                    const anime = animeList.find(a => a.id === animeId);
                    if (anime) {
                        activityDetails[date].push({
                            animeId: animeId,
                            title: anime.title,
                            episodes: episodes
                        });
                    }
                } else {
                    activityDetails[date].push({
                        animeId: null,
                        title: 'Dodane ręcznie',
                        episodes: episodes
                    });
                }
                
                saveActivityData();
                renderActivityCalendar();
            }
            
            // Modal do dodawania odcinków
            let currentAnimeId = null;
            
            function showEpisodeModal(animeId) {
                currentAnimeId = animeId;
                const modal = document.getElementById('episode-modal');
                const anime = animeList.find(a => a.id === animeId);
                
                if (anime) {
                    document.getElementById('episode-modal-title').textContent = `Dodaj odcinki - ${anime.title}`;
                }
                
                // Ustaw dzisiejszą datę w lokalnej strefie czasowej
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const todayString = `${year}-${month}-${day}`;
                document.getElementById('episode-date').value = todayString;
                document.getElementById('episode-count').textContent = '1';
                document.getElementById('activity-only').checked = false;
                
                modal.classList.add('show');
            }
            
            function hideEpisodeModal() {
                document.getElementById('episode-modal').classList.remove('show');
                currentAnimeId = null;
            }
            
            // Event listeners dla modala
            document.getElementById('episode-modal-close').addEventListener('click', hideEpisodeModal);
            document.getElementById('day-summary-close').addEventListener('click', () => {
                document.getElementById('day-summary-modal').classList.remove('show');
            });

            document.getElementById('episode-decrease').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                if (count > 1) {
                    countEl.textContent = count - 1;
                }
            });
            
            document.getElementById('episode-increase').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                countEl.textContent = count + 1;
            });
            
            document.getElementById('add-episode-btn').addEventListener('click', () => {
                const count = parseInt(document.getElementById('episode-count').textContent);
                const date = document.getElementById('episode-date').value;
                const activityOnly = document.getElementById('activity-only').checked;
                
                console.log('Dodawanie odcinków:', { count, date, currentAnimeId, activityOnly }); // Debug
                
                if (!date) {
                    alert('Proszę wybrać datę');
                    return;
                }
                
                addActivity(date, count, currentAnimeId);
                
                // Zaktualizuj anime tylko jeśli NIE jest zaznaczony "tylko aktywność"
                if (currentAnimeId && !activityOnly) {
                    const anime = animeList.find(a => a.id === currentAnimeId);
                    if (anime) {
                        // Sprawdź czy to nie jest rewatch (anime już ukończone)
                        if (anime.watchedEpisodes >= anime.totalEpisodes) {
                            // To jest rewatch - dodaj do rewatchCount
                            if (!anime.rewatchCount) {
                                anime.rewatchCount = 0;
                            }
                            anime.rewatchCount += count;
                        } else {
                            // Normalne dodawanie odcinków
                            anime.watchedEpisodes += count;
                            if (anime.watchedEpisodes > anime.totalEpisodes) {
                                anime.watchedEpisodes = anime.totalEpisodes;
                            }
                            
                            // Sprawdź czy anime zostało ukończone
                            if (anime.watchedEpisodes >= anime.totalEpisodes && anime.status === 'watching') {
                                anime.status = 'completed';
                            }
                        }
                        
                        saveAnimeList();
                        renderAnimeList();
                        renderTierList();
                        updateProfileStats();
                    }
                }
                
                hideEpisodeModal();
                const message = activityOnly ? 'Aktywność została dodana!' : 'Odcinki zostały dodane!';
                showNotification(message, 'success');
            });
            
            // Dodaj funkcję do wyświetlania anime z danym tagiem
            function renderProfileAnimeListByTag(tag) {
                const list = animeList.filter(a => a.tags && a.tags.includes(tag));
                const label = `Anime z tagiem: <span class='anime-tag'>${tag}</span>`;
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime z tagiem "${tag}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label}</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                list.forEach(a => {
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                        <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                        <td style='padding:8px 4px;'>${a.averageRating}</td>
                    </tr>`;
                });
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
        });
    </script>
    
    <!-- Modal do dodawania odcinków -->
    <div class="episode-modal" id="episode-modal">
        <div class="episode-modal-content">
            <div class="episode-modal-header">
                <h3 id="episode-modal-title">Dodaj odcinki</h3>
                <button class="episode-modal-close" id="episode-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="episode-counter">
                <button class="episode-counter-btn" id="episode-decrease">
                    <i class="fas fa-minus"></i>
                </button>
                <div class="episode-counter-value" id="episode-count">1</div>
                <button class="episode-counter-btn" id="episode-increase">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div class="form-group">
                <label for="episode-date">Data oglądania</label>
                <input type="date" id="episode-date" required>
            </div>
            <div class="form-group" style="margin-bottom: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="activity-only" style="width: auto; margin: 0;">
                    <span style="color: var(--gray); font-size: 0.9rem;">
                        <i class="fas fa-calendar-check"></i> Tylko aktywność (nie zmieniaj postępu anime)
                    </span>
                </label>
            </div>
            <button class="add-episode-btn" id="add-episode-btn">
                <i class="fas fa-plus"></i>
                Dodaj odcinki
            </button>
        </div>
    </div>
    
    <!-- Modal podsumowania dnia -->
    <div class="day-summary-modal" id="day-summary-modal">
        <div class="day-summary-content">
            <div class="day-summary-header">
                <div class="day-summary-date" id="day-summary-date">Data</div>
                <button class="day-summary-close" id="day-summary-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="day-summary-stats" id="day-summary-stats">
                <!-- Statystyki będą dodawane dynamicznie -->
            </div>
            <div class="day-summary-anime-list" id="day-summary-anime-list">
                <!-- Lista anime będzie dodawana dynamicznie -->
            </div>
        </div>
    </div>
</body>
</html>
