<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Toolkit</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        html {
    scroll-behavior: smooth;
}

.section {
    scroll-margin-top: 80px;
}
        :root {
            --primary: #6c5ce7;
            --primary-dark: #5649c0;
            --primary-light: #a29bfe;
            --secondary: #fd79a8;
            --accent: #00cec9;
            --dark: #2d3436;
            --darker: #1e272e;
            --light: #f5f6fa;
            --lighter: #ffffff;
            --gray: #dfe6e9;
            --success: #00b894;
            --warning: #fdcb6e;
            --danger: #d63031;
            --info: #0984e3;
            
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            --card-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, var(--darker), var(--dark));
            color: var(--light);
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-left: 100px;
        }
        
        h1, h2, h3 {
            color: var(--lighter);
            margin-bottom: 1.5rem;
            font-weight: 600;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.8rem;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            padding-bottom: 1rem;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
        }
        
        .section {
            margin-bottom: 3rem;
            padding: 2rem;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray);
            font-size: 0.95rem;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 1rem;
            color: var(--lighter);
            transition: var(--transition);
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
            background: rgba(0, 0, 0, 0.3);
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
            box-shadow: 0 4px 12px rgba(214, 48, 49, 0.3);
        }
        
        .btn-success {
            background-color: var(--success);
        }
        
        .btn-success:hover {
            background-color: #00a383;
            box-shadow: 0 4px 12px rgba(0, 184, 148, 0.3);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
        }
        
        .btn-secondary:hover {
            background-color: #e84393;
            box-shadow: 0 4px 12px rgba(253, 121, 168, 0.3);
        }
        
        .btn-accent {
            background-color: var(--accent);
        }
        
        .btn-accent:hover {
            background-color: #00b5ad;
            box-shadow: 0 4px 12px rgba(0, 206, 201, 0.3);
        }
        
        .anime-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .anime-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.3;
            z-index: -1;
        }
        
        .anime-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .anime-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .anime-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .anime-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--lighter);
            position: relative;
            padding-left: 12px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .anime-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
        }
        
        .anime-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--glass-border);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .status-watching {
            color: var(--info);
            border-color: var(--info);
        }
        
        .status-completed {
            color: var(--success);
            border-color: var(--success);
        }
        
        .status-upcoming {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .rating-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .rating-label {
            font-weight: 500;
            width: 80px;
            color: var(--gray);
        }
        
        .rating-value {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: var(--lighter);
            padding-left: 8px;
            padding-right: 8px;
            flex-shrink: 0;
            word-break: break-all;
        }
        
        .tier-list {
            margin-top: 2rem;
        }
        
        .tier-row {
            display: flex;
            margin-bottom: 0.5rem;
            min-height: 70px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .tier-label {
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            position: relative;
            z-index: 1;
            font-size: 1.2rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .tier-SSS { 
            font-weight: 900;
            font-size: 1.4em;
            animation: rainbow 5s linear infinite;
        }
        
        .tier-SS { background-color: #ff4757; }
        .tier-S { background-color: #ff6b81; }
        .tier-A { background-color: #ff9f43; }
        .tier-B { background-color: #feca57; color: #333; }
        .tier-C { background-color: #fffa65; color: #333; }
        .tier-D { background-color: #1dd1a1; color: #333; }
        .tier-F { background-color: #10ac84; color: #333; }
        
        .tier-items {
            flex-grow: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            min-height: 70px;
            align-items: center;
        }
        
        .tier-item {
            background-color: var(--primary);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.9rem;
            height: fit-content;
            transition: var(--transition);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
        }
        
        .tier-item:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
            gap: 0.8rem;
            margin-top: auto;
        }
        
        .actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        
        .no-anime {
            text-align: center;
            padding: 2rem;
            color: var(--gray);
            grid-column: 1 / -1;
            font-size: 1.1rem;
        }
        
        .tier-controls {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .tier-category-btn {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--gray);
            transition: var(--transition);
            border: 1px solid var(--glass-border);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .tier-category-btn.active {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .average-rating {
            font-weight: 600;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--glass-border);
            color: var(--lighter);
            font-size: 1.1rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
        }
        
        /* Profile stats */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .stat-card {
            background: var(--glass);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .stat-card.clickable {
            cursor: pointer;
            transition: var(--transition);
        }
        
        .stat-card.clickable:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .stat-card.clickable:hover .stat-value {
            color: var(--primary-light);
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin: 1rem 0;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-label {
            font-size: 0.95rem;
            color: var(--gray);
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        /* Time display */
        .time-display {
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }
        
        .time-display:hover {
            color: var(--primary);
        }
        
        .rewatch-info {
            font-size: 0.75rem;
            color: var(--gray);
            margin-top: 2px;
            display: block;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background: var(--darker);
            color: var(--lighter);
            text-align: center;
            border-radius: 8px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            font-size: 0.85rem;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Rainbow animation for SSS tier */
        @keyframes rainbow {
            0% { background-color: #ff0000; }
            14% { background-color: #ff7f00; }
            28% { background-color: #ffff00; }
            42% { background-color: #00ff00; }
            57% { background-color: #0000ff; }
            71% { background-color: #4b0082; }
            85% { background-color: #9400d3; }
            100% { background-color: #ff0000; }
        }
        
        /* Kalendarz aktywności */
        .month-dot.clickable:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.4);
            border-color: var(--primary-light);
        }
        
        .year-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--glass-border);
        }
        
        .months-grid {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }
        
        /* Navbar styles */
        .semi-circle-nav {
            width: 80px;
            height: 100vh;
            background: rgba(30, 39, 46, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            left: 0;
            top: 0;
            border-radius: 0 24px 24px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }
        
        .nav-item {
            padding: 14px 0;
            margin: 6px 0;
            color: var(--gray);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
            text-align: center;
            width: 100%;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        
        .nav-item i {
            font-size: 1.2rem;
        }
        
        .nav-item:hover {
            color: var(--primary-light);
            transform: translateX(8px);
        }
        
        .nav-item.active {
            color: white;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            border-radius: 12px 0 0 12px;
            transform: translateX(10px) scale(1.05);
            box-shadow: 4px 0 12px rgba(108, 92, 231, 0.4);
        }
        
        /* SSS item styles */
        .sss-item {
            animation: glow 2s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 400% 400%;
            animation: rainbow 3s linear infinite, glow 2s ease-in-out infinite alternate;
            z-index: 1;
            color: white;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #ff0000, 0 0 20px #ff0000;
            }
            to {
                box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #ff0000, 0 0 40px #ff0000;
            }
        }

        .sss-item::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0) 30%,
                rgba(255, 255, 255, 0.5) 45%,
                rgba(255, 255, 255, 0) 60%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(30deg);
            animation: shine 3s infinite;
            z-index: -1;
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%) rotate(30deg);
            }
            100% {
                transform: translateX(100%) rotate(30deg);
            }
        }
        
        /* Floating action button */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 20px rgba(108, 92, 231, 0.4);
            cursor: pointer;
            z-index: 100;
            transition: var(--transition);
            border: none;
        }
        
        .fab:hover {
            transform: translateY(-5px) scale(1.1);
            background: var(--primary-dark);
            box-shadow: 0 6px 24px rgba(108, 92, 231, 0.5);
        }
        
        /* Image upload styles */
        .image-upload-container {
            margin-bottom: 1.5rem;
        }
        
        .image-preview {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px dashed var(--glass-border);
            border-radius: 8px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .image-preview-placeholder {
            text-align: center;
            color: var(--gray);
            padding: 20px;
        }
        
        .image-preview-placeholder i {
            font-size: 3rem;
            margin-bottom: 10px;
            display: block;
            color: var(--primary-light);
        }
        
        .remove-image-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.8;
            transition: var(--transition);
            z-index: 2;
        }
        
        .remove-image-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        /* Responsive styles */
        @media (max-width: 992px) {
            .container {
                padding-left: 90px;
            }
            
            .semi-circle-nav {
                width: 70px;
            }
            
            .nav-item {
                font-size: 0;
                padding: 16px 0;
            }
            
            .nav-item i {
                font-size: 1.3rem;
            }
            
            .nav-item.active {
                transform: translateX(8px);
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding-left: 0;
            }
            
            .container {
                padding: 15px;
                padding-bottom: 80px;
            }
            
            .semi-circle-nav {
                width: 100%;
                height: 60px;
                bottom: 0;
                top: auto;
                flex-direction: row;
                border-radius: 24px 24px 0 0;
                justify-content: space-around;
                padding: 0 10px;
            }
            
            .nav-item {
                font-size: 0.7rem;
                padding: 8px 4px;
                margin: 0;
                width: auto;
            }
            
            .nav-item i {
                font-size: 1.1rem;
            }
            
            .nav-item.active {
                transform: translateY(-8px);
                border-radius: 12px 12px 0 0;
            }
            
            .anime-list {
                grid-template-columns: 1fr;
            }
            
            .tier-controls {
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 10px;
                scrollbar-width: none;
            }
            
            .tier-controls::-webkit-scrollbar {
                display: none;
            }
            
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            
            .fab {
                bottom: 80px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }
        
            .anime-card {
                min-height: 350px;
            }
        }
    
        @media (max-width: 480px) {
            .section {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .tier-label {
                width: 60px;
                font-size: 1rem;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .actions button {
                width: 100%;
            }
        }
        .seasons-progress {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .odcinki-row:hover {
            background: rgba(255,255,255,0.05);
        }
        #collection-controls {
            padding: 16px 0 0 0;
            min-height: 48px;
        }
        
        /* Planner styles */
        .planner-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }
        
        .planner-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .planner-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .planner-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }
        
        /* Activity Calendar Styles */
        .activity-calendar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .calendar-year {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .calendar-year.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            position: relative;
        }
        
        .calendar-year.clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        .calendar-year.clickable:active {
            transform: translateY(0);
        }
        
        .calendar-month-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--lighter);
            text-align: center;
        }
        
        .calendar-month-title.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem 1rem;
            border-radius: 6px;
        }
        
        .calendar-month-title.clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        .calendar-month-title.clickable:active {
            transform: translateY(0);
        }
        
        .calendar-nav {
            display: flex;
            gap: 0.5rem;
        }
        

        
        /* Desktop widok miesięczny */
        .calendar-back-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            margin-left: 1rem;
        }
        
        .calendar-back-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-1px);
        }
        
        .desktop-month-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            align-items: start;
            margin-top: 1rem;
        }
        
        .desktop-month-labels {
            display: grid;
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
            font-size: 0.85rem;
            color: var(--gray);
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
        }
        
        .desktop-month-label {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .desktop-month-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 3px;
        }
        
        .desktop-month-day {
            aspect-ratio: 1;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .desktop-month-day:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .desktop-month-day.empty {
            background: rgba(255, 255, 255, 0.05);
            color: var(--gray);
            cursor: default;
        }
        
        .desktop-month-day.other-month {
            color: var(--gray);
            opacity: 0.5;
        }
        
        .desktop-month-day.level-0 { background: rgba(255, 255, 255, 0.1); }
        .desktop-month-day.level-1 { background: rgba(108, 92, 231, 0.3); }
        .desktop-month-day.level-2 { background: rgba(108, 92, 231, 0.5); }
        .desktop-month-day.level-3 { background: rgba(108, 92, 231, 0.7); }
        .desktop-month-day.level-4 { background: rgba(108, 92, 231, 0.9); }
        
        .desktop-month-tooltip {
            position: absolute;
            background: var(--darker);
            color: var(--lighter);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
        }
        
        .desktop-month-day:hover .desktop-month-tooltip {
            opacity: 1;
        }
        
        /* Animacje przejścia dla kalendarza */
        .calendar-grid {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-days {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-day {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-day:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* Animacja fade dla przełączania widoków */
        .calendar-days.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .calendar-days.fade-in {
            opacity: 1;
            transform: translateY(0);
        }
        
        .calendar-nav-btn {
            background: var(--primary);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .calendar-nav-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            align-items: start;
        }
        
        .calendar-labels {
            display: grid;
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
            font-size: 0.85rem;
            color: var(--gray);
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            margin-top: 32px; /* Przesunięcie w dół, żeby wyrównać z kwadratami */
        }
        

        
        .calendar-labels > div {
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            cursor: pointer;
            transition: var(--transition);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .calendar-labels > div:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--lighter);
        }
        
        .calendar-months > div {
            transition: var(--transition);
            padding: 2px 4px;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }
        
        .calendar-months > div:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--lighter);
        }
        

        
        .calendar-day.dimmed {
            opacity: 0.3;
            filter: grayscale(0.5);
        }
        
        .calendar-months {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 4px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            color: var(--gray);
            text-align: center;
        }
        
        .calendar-month {
            position: relative;
        }
        
        .calendar-month:not(:last-child)::after {
            content: '';
            position: absolute;
            right: -2px;
            top: 0;
            bottom: 0;
            width: 1px;
            background: var(--glass-border);
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
            position: relative;
        }
        

        
        .calendar-day {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            border: 1px solid transparent;
        }
        
        .calendar-day:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        
        .calendar-day.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .calendar-day.level-0 {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .calendar-day.level-1 {
            background: var(--primary-light);
        }
        
        .calendar-day.level-2 {
            background: var(--primary);
        }
        
        .calendar-day.level-3 {
            background: var(--primary-dark);
        }
        
        .calendar-day.level-4 {
            background: var(--accent);
        }
        
        .calendar-day.level-5 {
            background: var(--secondary);
        }
        
        .calendar-tooltip {
            position: absolute;
            background: var(--darker);
            color: var(--lighter);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .calendar-day:hover .calendar-tooltip {
            opacity: 1;
        }
        
        /* Mobile Calendar Improvements */
        @media (max-width: 768px) {
            .activity-calendar {
                padding: 1rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            

            
            .activity-calendar::-webkit-scrollbar {
                display: none;
            }
            
            .calendar-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .calendar-year {
                font-size: 1.2rem;
                text-align: center;
            }
            
            .calendar-month-title {
                font-size: 1.2rem;
                font-weight: 600;
                color: var(--lighter);
                text-align: center;
            }
            
            .calendar-nav {
                justify-content: center;
            }
            
            .calendar-nav-btn {
                padding: 12px 16px;
                font-size: 1rem;
                min-width: 50px;
                min-height: 50px;
                touch-action: manipulation;
            }
            
            /* Mobile Calendar Grid */
            .mobile-calendar-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .mobile-calendar-labels {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 4px;
                margin-bottom: 0.5rem;
            }
            
            .mobile-calendar-label {
                text-align: center;
                font-size: 0.8rem;
                color: var(--gray);
                font-weight: 500;
                padding: 4px;
            }
            
            .mobile-calendar-days {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 4px;
            }
            
            .mobile-calendar-day {
                aspect-ratio: 1;
                border-radius: 4px;
                cursor: pointer;
                transition: var(--transition);
                position: relative;
                border: 1px solid transparent;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.8rem;
                font-weight: 500;
                min-height: 32px;
            }
            
            .mobile-calendar-day:hover {
                transform: scale(1.1);
                z-index: 10;
            }
            
            .mobile-calendar-day.empty {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .mobile-calendar-day.other-month {
                opacity: 0.3;
                color: var(--gray);
            }
            
            .mobile-calendar-day.level-0 {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--lighter);
            }
            
            .mobile-calendar-day.level-1 {
                background: var(--primary-light);
                color: var(--dark);
            }
            
            .mobile-calendar-day.level-2 {
                background: var(--primary);
                color: white;
            }
            
            .mobile-calendar-day.level-3 {
                background: var(--primary-dark);
                color: white;
            }
            
            .mobile-calendar-day.level-4 {
                background: var(--accent);
                color: white;
            }
            
            .mobile-calendar-day.level-5 {
                background: var(--secondary);
                color: white;
            }
            
            .mobile-calendar-tooltip {
                position: absolute;
                background: var(--darker);
                color: var(--lighter);
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.8rem;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: var(--shadow);
                border: 1px solid var(--glass-border);
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-bottom: 5px;
            }
            
            .mobile-calendar-day:hover .mobile-calendar-tooltip {
                opacity: 1;
            }
            
            /* Ukryj desktop calendar na mobile */
            .calendar-grid {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .mobile-calendar-day {
                min-height: 28px;
                font-size: 0.7rem;
            }
            
            .mobile-calendar-label {
                font-size: 0.7rem;
            }
            
            .calendar-month-title {
                font-size: 1rem;
            }
            
            .calendar-nav-btn {
                padding: 10px 12px;
                min-width: 45px;
                min-height: 45px;
            }
        }
        
        /* Episode counter modal */
        .episode-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .episode-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .episode-modal-content {
            background: var(--darker);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
        }
        
        .episode-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .episode-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .episode-modal-close:hover {
            color: var(--lighter);
        }
        
        .episode-counter {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .episode-counter-btn {
            background: var(--primary);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: var(--transition);
        }
        
        .episode-counter-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }
        
        .episode-counter-value {
            font-size: 1.5rem;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .add-episode-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .add-episode-btn:hover {
            background: #00a383;
            transform: translateY(-1px);
        }
        
        /* Day summary modal */
        .day-summary-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .day-summary-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .day-summary-content {
            background: var(--darker);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .day-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .day-summary-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .day-summary-close:hover {
            color: var(--lighter);
        }
        
        .day-summary-date {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .day-summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .day-summary-stat {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            border: 1px solid var(--glass-border);
        }
        
        .day-summary-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-stat-label {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-list {
            margin-top: 1.5rem;
        }
        
        .day-summary-anime-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .day-summary-anime-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
        }
        
        .day-summary-anime-title {
            font-weight: 600;
            color: var(--lighter);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-anime-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-episodes {
            color: var(--primary);
            font-weight: 500;
        }
        
        .day-summary-anime-time {
            color: var(--accent);
            font-weight: 500;
        }
        
        .day-summary-empty {
            text-align: center;
            color: var(--gray);
            font-style: italic;
            padding: 2rem;
        }
        
        .day-summary-tag-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 150px;
        }
        
        .day-summary-tag-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
        }
        
        .day-summary-tag-stats {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .day-summary-tag-episodes {
            color: var(--primary);
            font-weight: 500;
        }
        
        .day-summary-tag-anime {
            color: var(--accent);
            font-weight: 500;
        }
        
        .day-summary-tag-time {
            color: var(--secondary);
            font-weight: 500;
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge.priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-badge.priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-badge.priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .planner-notes {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 1rem 0;
            font-style: italic;
            color: var(--gray);
            border-left: 3px solid var(--primary);
        }
        
        .planner-actions {
            display: flex;
            gap: 0.8rem;
            margin-top: 1rem;
        }
        
        .planner-actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        .anime-tag {background: var(--primary-light); color: var(--dark); border-radius: 12px; padding: 2px 10px; font-size: 0.85em; font-weight: 500; margin-right: 2px;}
        
        /* Transfer system styles */
        .transfer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .transfer-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .transfer-modal-content {
            background: var(--darker);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            text-align: center;
        }
        
        .transfer-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .transfer-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .transfer-modal-close:hover {
            color: var(--lighter);
        }
        
        .transfer-code-display {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: var(--primary-light);
            font-family: 'Courier New', monospace;
            text-align: center;
            position: relative;
        }
        
        .transfer-code-input {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: 0.2em;
            color: var(--lighter);
            font-family: 'Courier New', monospace;
            text-align: center;
            width: 100%;
            outline: none;
            transition: var(--transition);
        }
        
        .transfer-code-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
        }
        
        .transfer-code-input.error {
            border-color: var(--danger);
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .transfer-timer {
            font-size: 0.9rem;
            color: var(--warning);
            margin-top: 0.5rem;
            font-weight: 500;
        }
        
        .transfer-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            color: var(--gray);
            border-left: 3px solid var(--info);
        }
        
        .copy-button {
            background: var(--success);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            margin-top: 1rem;
        }
        
        .copy-button:hover {
            background: #00a383;
            transform: translateY(-1px);
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            max-width: 400px;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification-success {
            background: linear-gradient(90deg, var(--success), #00a383);
            border-left: 5px solid #00a383;
        }
        
        .notification-danger {
            background: linear-gradient(90deg, var(--danger), #c0392b);
            border-left: 5px solid #c0392b;
        }
        
        .notification-info {
            background: linear-gradient(90deg, var(--info), #0652dd);
            border-left: 5px solid #0652dd;
        }
        
        .notification-warning {
            background: linear-gradient(90deg, var(--warning), #e55039);
            border-left: 5px solid #e55039;
        }
        
        /* Loading spinner */
        .fa-spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <nav class="semi-circle-nav">
        <a href="#profil" class="nav-item"><i class="fas fa-user"></i><span>Profil</span></a>
        <a href="#dodaj" class="nav-item active"><i class="fas fa-plus"></i><span>Dodaj</span></a>
        <a href="#lista" class="nav-item"><i class="fas fa-list"></i><span>Lista</span></a>
        <a href="#tier-lista" class="nav-item"><i class="fas fa-layer-group"></i><span>Tier Lista</span></a>
        <a href="#planer" class="nav-item"><i class="fas fa-calendar-alt"></i><span>Planer</span></a>
        <a href="#eksport" class="nav-item"><i class="fas fa-file-export"></i><span>Eksport</span></a>
    </nav>

    <div class="container">
        <h1><i class="fas fa-film"></i> Anime Toolkit</h1>
        
        <div class="section" id="profil">
            <h2><i class="fas fa-chart-line"></i> Twoje statystyki</h2>
            <div class="stats-container" id="profile-stats">
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-star"></i> Ocena ogólna</div>
                    <div class="stat-value" id="average-rating">0.0</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="average-rating-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-clock"></i> Czas oglądania</div>
                    <div class="stat-value time-display" id="total-time">0h</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-check-circle"></i> Obejrzane</div>
                    <div class="stat-value" id="total-completed">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-bookmark"></i> Planowane</div>
                    <div class="stat-value" id="total-upcoming">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-eye"></i> Oglądane</div>
                    <div class="stat-value" id="total-watching">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-database"></i> Wszystkie</div>
                    <div class="stat-value" id="total-all">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-tasks"></i> Postęp</div>
                    <div class="stat-value" id="watch-progress">0%</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="watch-progress-bar" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stat-card clickable" id="generate-code-card">
                    <div class="stat-label"><i class="fas fa-qrcode"></i> Generuj kod</div>
                    <div class="stat-value" style="font-size: 1.5rem; color: var(--success);">
                        <i class="fas fa-upload"></i>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;">
                        Kliknij aby wygenerować kod transferu
                    </div>
                </div>

                <div class="stat-card clickable" id="import-code-card">
                    <div class="stat-label"><i class="fas fa-download"></i> Wgraj kod</div>
                    <div class="stat-value" style="font-size: 1.5rem; color: var(--accent);">
                        <i class="fas fa-download"></i>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;">
                        Kliknij aby wgrać kod transferu
                    </div>
                </div>


            </div>
            <div id="profile-tags-stats" style="margin-top:2rem;"></div>
            
            <!-- Kalendarz aktywności -->
            <div class="activity-calendar">
                <h3><i class="fas fa-calendar-alt"></i> Kalendarz aktywności</h3>
                <div id="calendar-container"></div>
            </div>
        </div>
        
        <div id="profile-anime-list" style="display:none;margin-top:1.5rem;"></div>
        
        <div class="section" id="dodaj">
            <h2 id="form-title"><i class="fas fa-plus-circle"></i> Dodaj nowe anime</h2>
            <form id="anime-form">
                <input type="hidden" id="edit-id">
                
                <div class="form-group">
                    <label for="title"><i class="fas fa-heading"></i> Tytuł anime</label>
                    <input type="text" id="title" required placeholder="Wpisz tytuł anime">
                </div>
                
                <div class="form-group">
                    <label for="anime-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                    <input type="text" id="anime-tags" placeholder="np. isekai; komedia; sport">
                </div>
                
                <div class="form-group">
                    <label for="status"><i class="fas fa-bookmark"></i> Status</label>
                    <select id="status" required>
                        <option value="watching">Oglądane</option>
                        <option value="completed">Obejrzane</option>
                        <option value="upcoming">Nadchodzące</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                    <input type="number" id="season-count" min="1" value="1">
                </div>
                <div class="form-group" id="seasons-container" style="display:none;"></div>
                <div class="form-group">
                    <label for="total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                    <input type="number" id="total-episodes" min="1" value="12">
                </div>
                
                <div class="form-group">
                    <label for="episode-length"><i class="fas fa-clock"></i> Długość odcinka (minuty)</label>
                    <input type="number" id="episode-length" min="1" value="24">
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="watched-episodes"><i class="fas fa-eye"></i> Obejrzane odcinki</label>
                    <input type="number" id="watched-episodes" min="0" value="0">
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Daty ukończenia i ostatniego oglądania będą automatycznie śledzone przy zwiększaniu aktywności.
                    </small>
                </div>
                
                <div class="form-group" id="completed-date-group" style="display:none;">
                    <label for="completed-date"><i class="fas fa-calendar-check"></i> Data ukończenia</label>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="date" id="completed-date">
                        <button type="button" id="clear-completed-date" class="btn-secondary" style="padding:6px 12px;font-size:0.9em;">Nie pamiętam daty</button>
                    </div>
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Możesz ręcznie ustawić datę ukończenia anime lub wyczyścić to pole.
                    </small>
                </div>
                

                
                <div class="form-group image-upload-container">
                    <label><i class="fas fa-image"></i> Obrazek anime</label>
                    <input type="file" id="image-upload" accept="image/*" style="display: none;">
                    <button type="button" id="upload-btn" class="btn-accent" style="width: 100%;"><i class="fas fa-upload"></i> Wybierz obrazek</button>
                    <div class="image-preview" id="image-preview">
                        <div class="image-preview-placeholder">
                            <i class="fas fa-image"></i>
                            <span>Brak wybranego obrazka</span>
                        </div>
                    </div>
                </div>
                
                <h3><i class="fas fa-star"></i> Oceny (1-11)</h3>
                <div class="rating-container">
                    <span class="rating-label">Grafika:</span>
                    <input type="number" id="graphics" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Muzyka:</span>
                    <input type="number" id="music" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Postacie:</span>
                    <input type="number" id="characters" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Fabuła:</span>
                    <input type="number" id="story" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Śmieszność:</span>
                    <input type="number" id="fun" min="1" max="11" value="5" required>
                </div>
                
                <div class="average-rating">
                    <i class="fas fa-calculator"></i> Średnia ocena: <span id="average-display">5</span>
                </div>
                
                <div class="actions">
                    <button type="submit" class="btn-success" id="submit-btn"><i class="fas fa-plus"></i> Dodaj anime</button>
                    <button type="button" class="btn-secondary" id="cancel-edit" style="display: none;"><i class="fas fa-times"></i> Anuluj</button>
                </div>
            </form>
        </div>
        
        <div class="section" id="lista">
            <h2><i class="fas fa-list-ul"></i> Twoja kolekcja</h2>
            <div style="display:flex;align-items:center;gap:1rem;margin-bottom:1rem;flex-wrap:wrap;">
                <label for="sort-select" style="font-weight:500;">Sortuj po:</label>
                <select id="sort-select" style="padding:8px 16px;border-radius:8px;">
                    <option value="title">Tytule (A-Z)</option>
                    <option value="averageRating">Średniej ocenie</option>
                    <option value="graphics">Grafice</option>
                    <option value="music">Muzyce</option>
                    <option value="characters">Postaciach</option>
                    <option value="story">Fabule</option>
                    <option value="fun">Śmieszności</option>
                </select>
                <input type="text" id="search-input" placeholder="Szukaj anime..." style="flex:1;min-width:180px;padding:8px 16px;border-radius:8px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.2);color:var(--lighter);">
            </div>
            <div class="anime-list" id="anime-list">
                <div class="no-anime">Nie dodałeś jeszcze żadnego anime. Dodaj pierwsze używając formularza powyżej!</div>
            </div>
            <div id="collection-controls" style="display:flex;gap:1rem;justify-content:center;margin-top:1.5rem;"></div>
        </div>
        
        <div class="section tier-list" id="tier-lista">
            <h2><i class="fas fa-trophy"></i> Tier Lista</h2>
            
            <div class="tier-controls">
                <button class="tier-category-btn active" data-category="average"><i class="fas fa-star"></i> Średnia</button>
                <button class="tier-category-btn" data-category="graphics"><i class="fas fa-paint-brush"></i> Grafika</button>
                <button class="tier-category-btn" data-category="music"><i class="fas fa-music"></i> Muzyka</button>
                <button class="tier-category-btn" data-category="characters"><i class="fas fa-users"></i> Postacie</button>
                <button class="tier-category-btn" data-category="story"><i class="fas fa-book"></i> Fabuła</button>
                <button class="tier-category-btn" data-category="fun"><i class="fas fa-laugh"></i> Śmieszność</button>
            </div>
            
            <div id="tier-list-container">
                <div class="tier-row">
                    <div class="tier-label tier-SSS">SSS</div>
                    <div class="tier-items" id="tier-SSS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-SS">SS</div>
                    <div class="tier-items" id="tier-SS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-S">S</div>
                    <div class="tier-items" id="tier-S"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-A">A</div>
                    <div class="tier-items" id="tier-A"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-B">B</div>
                    <div class="tier-items" id="tier-B"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-C">C</div>
                    <div class="tier-items" id="tier-C"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-D">D</div>
                    <div class="tier-items" id="tier-D"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-F">F</div>
                    <div class="tier-items" id="tier-F"></div>
                </div>
            </div>
        </div>
        
        <div class="section" id="planer">
            <h2><i class="fas fa-calendar-alt"></i> Planer anime</h2>
            <div style="color:var(--gray);margin-bottom:1rem;font-size:1rem;">Dodaj anime do planera i ustaw priorytet oglądania.</div>
            
            <div class="form-group">
                <label for="planner-title"><i class="fas fa-heading"></i> Tytuł anime</label>
                <input type="text" id="planner-title" placeholder="Wpisz tytuł anime do planera">
            </div>
            <div class="form-group">
                <label for="planner-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                <input type="text" id="planner-tags" placeholder="np. akcja; dramat; fantasy">
            </div>
            
            <div class="form-group">
                <label for="planner-season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                <input type="number" id="planner-season-count" min="1" value="1">
            </div>
            <div class="form-group" id="planner-seasons-container" style="display:none;"></div>
            <div class="form-group">
                <label for="planner-total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                <input type="number" id="planner-total-episodes" min="1" value="12">
                <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                    <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                </small>
            </div>
            
            <div class="form-group">
                <label for="planner-priority"><i class="fas fa-flag"></i> Priorytet</label>
                <select id="planner-priority">
                    <option value="niski">Niski</option>
                    <option value="średni" selected>Średni</option>
                    <option value="duży">Duży</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="planner-notes"><i class="fas fa-sticky-note"></i> Notatki (opcjonalnie)</label>
                <textarea id="planner-notes" placeholder="Dodaj notatki o anime..." rows="3" style="width:100%;padding:12px 16px;background:rgba(0,0,0,0.2);border:1px solid var(--glass-border);border-radius:8px;font-size:1rem;color:var(--lighter);resize:vertical;"></textarea>
            </div>
            
            <div class="actions">
                <button type="button" id="add-to-planner" class="btn-accent"><i class="fas fa-plus"></i> Dodaj do planera</button>
            </div>
            
            <div style="margin-top:2rem;">
                <h3><i class="fas fa-list"></i> Lista planowanych anime</h3>
                <div id="planner-list">
                    <div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>
                </div>
            </div>
        </div>
        
        <div class="section" id="eksport">
            <h2><i class="fas fa-file-export"></i> Zarządzanie danymi</h2>
            <div class="actions">
                <button id="export-btn" class="btn-accent"><i class="fas fa-file-export"></i> Eksportuj dane</button>
                <button id="import-btn" class="btn-accent"><i class="fas fa-file-import"></i> Importuj dane</button>
                <input type="file" id="import-file" accept=".json" style="display: none;">
                <button id="clear-btn" class="btn-danger"><i class="fas fa-trash"></i> Wyczyść dane</button>
            </div>
        </div>
    </div>

    <button class="fab" id="scroll-top-btn" title="Przewiń do góry"><i class="fas fa-arrow-up"></i></button>

    <script>
        // --- GLOBALNE FUNKCJE ---
        function checkAnimeCompletion(anime) {
            if (anime.seasons && anime.seasons.length > 1) {
                // Dla anime z wieloma sezonami
                let totalEpisodes = 0;
                let watchedEpisodes = 0;
                anime.seasons.forEach((episodeCount, index) => {
                    totalEpisodes += episodeCount;
                    const watchedThis = Math.min(anime.watchedEpisodes - watchedEpisodes, episodeCount);
                    watchedEpisodes += watchedThis;
                });
                console.log('checkAnimeCompletion dla sezonów:', { 
                    title: anime.title, 
                    watchedEpisodes: anime.watchedEpisodes, 
                    totalEpisodes, 
                    watchedEpisodes, 
                    isCompleted: watchedEpisodes >= totalEpisodes,
                    seasons: anime.seasons
                });
                return watchedEpisodes >= totalEpisodes;
            } else {
                // Dla pojedynczego sezonu
                console.log('checkAnimeCompletion dla pojedynczego sezonu:', { 
                    title: anime.title, 
                    watchedEpisodes: anime.watchedEpisodes, 
                    totalEpisodes: anime.totalEpisodes, 
                    isCompleted: anime.watchedEpisodes >= anime.totalEpisodes 
                });
                return anime.watchedEpisodes >= anime.totalEpisodes;
            }
        }
        function checkSeasonCompletion(anime, seasonIndex) {
            if (anime.seasons && anime.seasons[seasonIndex]) {
                const seasonEpisodes = anime.seasons[seasonIndex];
                let watchedInSeason = 0;
                // Oblicz ile odcinków zostało obejrzanych w tym sezonie
                let remainingWatched = anime.watchedEpisodes;
                for (let i = 0; i < seasonIndex; i++) {
                    if (anime.seasons[i]) {
                        remainingWatched -= anime.seasons[i];
                    }
                }
                watchedInSeason = Math.max(0, Math.min(remainingWatched, seasonEpisodes));
                return watchedInSeason >= seasonEpisodes;
            }
            return false;
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Load anime list from localStorage
            let animeList = JSON.parse(localStorage.getItem('animeList')) || [];
            console.log('Initial animeList length:', animeList.length);
            console.log('Initial animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
            let plannerList = JSON.parse(localStorage.getItem('plannerList')) || [];
            let activityData = JSON.parse(localStorage.getItem('activityData')) || {};
            let activityDetails = JSON.parse(localStorage.getItem('activityDetails')) || {};
            let currentTierCategory = 'average';
            let collectionPage = 1;
            const collectionPageSize = 3;
            let showAllCollection = false;
            let currentSort = 'title';
            let currentSearch = '';
            let currentYear = new Date().getFullYear();
            
            // Form elements
            const animeForm = document.getElementById('anime-form');
            const formTitle = document.getElementById('form-title');
            const submitBtn = document.getElementById('submit-btn');
            const cancelEditBtn = document.getElementById('cancel-edit');
            const editIdInput = document.getElementById('edit-id');
            
            // Image upload elements
            const uploadBtn = document.getElementById('upload-btn');
            const imageUpload = document.getElementById('image-upload');
            const imagePreview = document.getElementById('image-preview');
            let currentImageData = null;
            
            // Rating inputs
            const ratingInputs = [
                document.getElementById('graphics'),
                document.getElementById('music'),
                document.getElementById('characters'),
                document.getElementById('story'),
                document.getElementById('fun')
            ];
            
            // Average display
            const averageDisplay = document.getElementById('average-display');
            
            // Tier category buttons
            const tierCategoryBtns = document.querySelectorAll('.tier-category-btn');
            
            // Export/Import buttons
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const clearBtn = document.getElementById('clear-btn');
            
            // Scroll to top button
            const scrollTopBtn = document.getElementById('scroll-top-btn');

            // Anime list container (przeniesione na górę)
            const animeListContainer = document.getElementById('anime-list');
            
            // Format time function
            function formatTime(minutes, format = 'hours') {
                const hours = minutes / 60;
                const days = hours / 24;
                const months = days / 30;
                const years = days / 365;
                
                switch(format) {
                    case 'hours':
                        const roundedHours = Math.round(hours * 10) / 10;
                        return roundedHours % 1 === 0 ? `${roundedHours}h` : `${roundedHours.toFixed(1)}h`;
                    case 'days':
                        return `${Math.round(days * 10) / 10}d`;
                    case 'months':
                        return `${Math.round(months * 10) / 10}m`;
                    case 'years':
                        return `${Math.round(years * 10) / 10}y`;
                    default:
                        const h = Math.floor(minutes / 60);
                        const m = minutes % 60;
                        return `${h}h ${m}m`;
                }
            }
            
            // Funkcja do formatowania dat
            function formatDate(dateString) {
                if (!dateString) return '';
                const date = new Date(dateString);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (date.toDateString() === today.toDateString()) {
                    return 'Dzisiaj';
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return 'Wczoraj';
                } else {
                    return date.toLocaleDateString('pl-PL');
                }
            }

            // Obsługa pokazywania/ukrywania pola daty ukończenia
            const statusSelect = document.getElementById('status');
            const completedDateGroup = document.getElementById('completed-date-group');
            const completedDateInput = document.getElementById('completed-date');

            function toggleCompletedDateField() {
                if (statusSelect.value === 'completed') {
                    completedDateGroup.style.display = '';
                } else {
                    completedDateGroup.style.display = 'none';
                    completedDateInput.value = '';
                }
            }

            statusSelect.addEventListener('change', toggleCompletedDateField);
            // Wywołaj na początku, żeby ustawić początkowy stan
            toggleCompletedDateField();

            // Calculate average rating
            function calculateAverage() {
                let sum = 0;
                let count = 0;
                
                ratingInputs.forEach(input => {
                    const value = parseInt(input.value);
                    if (!isNaN(value) && value >= 1 && value <= 11) {
                        sum += value;
                        count++;
                    }
                });
                
                const average = count > 0 ? Math.round(sum / count) : 0;
                averageDisplay.textContent = average;
                return average;
            }
            
            // Update average when any rating changes
            ratingInputs.forEach(input => {
                input.addEventListener('change', calculateAverage);
                input.addEventListener('input', calculateAverage);
            });
            
            // Obsługa zdjęć anime
            uploadBtn.addEventListener('click', function() {
                imageUpload.value = '';
                imageUpload.click();
            });

            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!file.type.startsWith('image/')) {
                    showNotification('Proszę wybrać plik obrazu!', 'danger');
                    imageUpload.value = '';
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(ev) {
                    currentImageData = ev.target.result;
                    showImagePreview(currentImageData);
                };
                reader.readAsDataURL(file);
            });

            function showImagePreview(imageData) {
                imagePreview.innerHTML = `
                    <img src="${imageData}" alt="Podgląd obrazka">
                `;
            }

            function showImagePlaceholder() {
                imagePreview.innerHTML = `
                    <div class="image-preview-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Brak wybranego obrazka</span>
                    </div>
                `;
            }

            function resetImageUpload() {
                currentImageData = null;
                showImagePlaceholder();
                imageUpload.value = '';
            }

            // Form submission
            animeForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                const title = document.getElementById('title').value.trim();
                if (!title) {
                    alert('Proszę wprowadzić tytuł anime');
                    return;
                }
                
                const status = document.getElementById('status').value;
                const seasonCount = parseInt(document.getElementById('season-count').value);
                console.log('Debug - seasonCount from form:', seasonCount);
                console.log('Debug - season-count element value:', document.getElementById('season-count').value);
                let seasons = [];
                let seasonRewatches = [];
                let seasonEpisodeLengths = [];
                let seasonCompletedDates = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#seasons-container .season-episodes');
                    const rewatchInputs = document.querySelectorAll('#seasons-container .season-rewatch');
                    const episodeLengthInputs = document.querySelectorAll('#seasons-container .season-episode-length');
                    const seasonDateInputs = document.querySelectorAll('#seasons-container .season-completed-date');
                    
                    console.log('Debug - seasonCount:', seasonCount);
                    console.log('Debug - seasonInputs found:', seasonInputs.length);
                    
                    seasonInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                        console.log(`Debug - Season ${index + 1}: ${input.value} -> ${isNaN(v) ? 0 : v}`);
                    });
                    rewatchInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonRewatches.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v); // domyślnie 24 minuty
                    });
                    seasonDateInputs.forEach((input, index) => {
                        const date = input.value;
                        seasonCompletedDates.push(date || null);
                    });
                    
                    console.log('Debug - seasons array:', seasons);
                    console.log('Debug - seasonRewatches array:', seasonRewatches);
                    console.log('Debug - seasonEpisodeLengths array:', seasonEpisodeLengths);
                }
                const totalEpisodes = parseInt(document.getElementById('total-episodes').value) || 12;
                const episodeLength = parseInt(document.getElementById('episode-length').value) || 24;
                const watchedEpisodes = parseInt(document.getElementById('watched-episodes').value) || 0;
                const graphics = parseInt(document.getElementById('graphics').value);
                const music = parseInt(document.getElementById('music').value);
                const characters = parseInt(document.getElementById('characters').value);
                const story = parseInt(document.getElementById('story').value);
                const fun = parseInt(document.getElementById('fun').value);
                const averageRating = calculateAverage();
                
                const tagsRaw = document.getElementById('anime-tags').value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                
                const animeData = {
                    id: editIdInput.value ? parseInt(editIdInput.value) : Date.now(),
                    title,
                    status,
                    totalEpisodes,
                    episodeLength,
                    watchedEpisodes,
                    ratings: {
                        graphics,
                        music,
                        characters,
                        story,
                        fun
                    },
                    averageRating,
                    createdAt: new Date().toISOString(),
                    tags
                };

                // Dodaj datę ukończenia jeśli status to 'completed'
                if (status === 'completed') {
                    const completedDate = document.getElementById('completed-date').value;
                    animeData.completedDate = completedDate || null;
                }
                
                if (seasons.length > 1) {
                    animeData.seasons = seasons;
                    animeData.seasonRewatches = seasonRewatches;
                    animeData.seasonEpisodeLengths = seasonEpisodeLengths;
                    animeData.seasonCompletedDates = seasonCompletedDates;
                    console.log('Debug - animeData with seasons:', {
                        title: animeData.title,
                        seasons: animeData.seasons,
                        seasonRewatches: animeData.seasonRewatches,
                        seasonEpisodeLengths: animeData.seasonEpisodeLengths
                    });
                }
                
                // Add image data if available
                if (currentImageData) {
                    animeData.image = currentImageData;
                } else if (editIdInput.value) {
                    // If editing and no new image selected, keep the existing one
                    const existingAnime = animeList.find(a => a.id === parseInt(editIdInput.value));
                    if (existingAnime && existingAnime.image) {
                        animeData.image = existingAnime.image;
                    }
                }
                
                if (editIdInput.value) {
                    // Update existing anime
                    const index = animeList.findIndex(a => a.id === animeData.id);
                    if (index !== -1) {
                        const oldAnime = animeList[index];
                        animeList[index] = animeData;
                        
                        // Jeśli status zmienił się na 'completed' i nie ma daty ukończenia, dodaj ją
                        // if (animeData.status === 'completed' && !animeData.completedDate) {
                        //     animeData.completedDate = new Date().toISOString().split('T')[0];
                        // }
                    }
                    cancelEdit();
                } else {
                    // Add new anime
                    // Nie ustawiamy dat dla nowych anime - tylko przy zwiększaniu aktywności
                    animeList.push(animeData);
                    
                    // If adding new anime with image, refresh the page
                    if (currentImageData) {
                        saveAnimeList();
                        window.location.reload();
                        return;
                    }
                }
                
                // Sort by title
                animeList.sort((a, b) => a.title.localeCompare(b.title));
                
                console.log('Przed saveAnimeList (form submit) - animeList length:', animeList.length);
                saveAnimeList();
                console.log('Po saveAnimeList (form submit) - animeList length:', animeList.length);
                renderAnimeList();
                renderTierList();
                updateProfileStats();
                
                // Reset form (except when editing)
                if (!editIdInput.value) {
                    animeForm.reset();
                                    document.getElementById('total-episodes').value = 12;
                document.getElementById('episode-length').value = 24;
                document.getElementById('watched-episodes').value = 0;
                document.getElementById('season-count').value = 1;
                document.getElementById('graphics').value = 5;
                document.getElementById('music').value = 5;
                document.getElementById('characters').value = 5;
                document.getElementById('story').value = 5;
                document.getElementById('fun').value = 5;
                calculateAverage();
                    
                    // Clear image
                    resetImageUpload();
                    
                    // Reset seasons container
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                    
                    // Show success notification
                    showNotification('Anime zostało dodane!', 'success');
                } else {
                    showNotification('Zmiany zostały zapisane!', 'success');
                }
            });
            

            
            // Cancel edit
            cancelEditBtn.addEventListener('click', cancelEdit);
            
            function cancelEdit() {
                editIdInput.value = '';
                formTitle.innerHTML = '<i class="fas fa-plus-circle"></i> Dodaj nowe anime';
                submitBtn.innerHTML = '<i class="fas fa-plus"></i> Dodaj anime';
                cancelEditBtn.style.display = 'none';
                animeForm.reset();
                document.getElementById('total-episodes').value = 12;
                document.getElementById('episode-length').value = 24;
                document.getElementById('watched-episodes').value = 0;
                document.getElementById('season-count').value = 1;
                document.getElementById('graphics').value = 5;
                document.getElementById('music').value = 5;
                document.getElementById('characters').value = 5;
                document.getElementById('story').value = 5;
                document.getElementById('fun').value = 5;
                document.getElementById('completed-date').value = '';
                toggleCompletedDateField();
                calculateAverage();
                // Clear image
                resetImageUpload();
                // Reset seasons container
                seasonsContainer.innerHTML = '';
                seasonsContainer.style.display = 'none';
                totalEpisodesInput.readOnly = false;
            }
            
            // Save anime list to localStorage
            function saveAnimeList() {
                console.log('saveAnimeList - animeList length:', animeList.length);
                console.log('saveAnimeList - animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
                localStorage.setItem('animeList', JSON.stringify(animeList));
            }
            
            // Save planner list to localStorage
            function savePlannerList() {
                localStorage.setItem('plannerList', JSON.stringify(plannerList));
            }
            
            // Update profile statistics
            function updateProfileStats() {
                console.log('updateProfileStats - animeList length:', animeList.length);
                console.log('updateProfileStats - animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
                
                const completedAnime = animeList.filter(a => a.status === 'completed');
                const watchingAnime = animeList.filter(a => a.status === 'watching');
                const ratedAnime = animeList.filter(a => a.status !== 'upcoming');
                const upcomingAnime = animeList.filter(a => a.status === 'upcoming');
                const allAnime = animeList;
                
                // Total completed anime
                document.getElementById('total-completed').textContent = completedAnime.length;
                document.getElementById('total-upcoming').textContent = plannerList.length;
                document.getElementById('total-watching').textContent = watchingAnime.length;
                document.getElementById('total-all').textContent = allAnime.length;

                // Calculate average rating
                const ratedAnimeForAvg = animeList.filter(a => a.averageRating > 0);
                let averageRating = 0;
                if (ratedAnimeForAvg.length > 0) {
                    const totalRating = ratedAnimeForAvg.reduce((sum, anime) => sum + anime.averageRating, 0);
                    averageRating = Math.round((totalRating / ratedAnimeForAvg.length) * 10) / 10; // Zaokrąglenie do 1 miejsca po przecinku
                }
                
                // Update average rating display
                document.getElementById('average-rating').textContent = averageRating.toFixed(1);
                const averageRatingBar = document.getElementById('average-rating-bar');
                const percentage = (averageRating / 11) * 100; // 11 to maksymalna ocena
                averageRatingBar.style.width = percentage + '%';

                // Calculate watch progress
                const totalEpisodes = animeList.reduce((sum, anime) => sum + anime.totalEpisodes, 0);
                const watchedEpisodes = animeList.reduce((sum, anime) => {
                    if (anime.status === 'completed') {
                        return sum + anime.totalEpisodes;
                    } else {
                        return sum + anime.watchedEpisodes;
                    }
                }, 0);
                
                const watchProgress = totalEpisodes > 0 ? Math.round((watchedEpisodes / totalEpisodes) * 100) : 0;
                document.getElementById('watch-progress').textContent = watchProgress + '%';
                const watchProgressBar = document.getElementById('watch-progress-bar');
                watchProgressBar.style.width = watchProgress + '%';

                
                // Total watch time (including rewatches)
                let totalMinutes = 0;
                let totalRewatchMinutes = 0;
                
                animeList.forEach(anime => {
                    let animeTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            animeTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        animeTime = watchedEpisodes * anime.episodeLength;
                    }
                    
                    totalMinutes += animeTime;
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((rewatchCount, index) => {
                            if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                totalRewatchMinutes += rewatchCount * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych
                        totalRewatchMinutes += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                });

                const totalTimeElement = document.getElementById('total-time');
                let timeFormat = localStorage.getItem('timeFormat') || 'hours';
                
                totalTimeElement.textContent = formatTime(totalMinutes + totalRewatchMinutes, timeFormat);
                totalTimeElement.title = `Podstawowy czas: ${formatTime(totalMinutes)}\nRewatche: ${formatTime(totalRewatchMinutes)}`;
                totalTimeElement.dataset.minutes = totalMinutes + totalRewatchMinutes;
                
                // Kliknięcie na kafelki statystyk - przewijanie do odpowiednich sekcji
                const statsCards = document.querySelectorAll('#profile-stats .stat-card');
                
                // Ocena ogólna - pokazuje szczegółowe statystyki ocen
                if (statsCards[0]) {
                    statsCards[0].classList.add('clickable');
                    statsCards[0].title = 'Kliknij, aby zobaczyć szczegółowe statystyki ocen';
                    statsCards[0].addEventListener('click', function() {
                        renderRatingBreakdown();
                    });
                }
                
                // Czas oglądania - pokazuje szczegółowy breakdown
                if (statsCards[1]) {
                    statsCards[1].classList.add('clickable');
                    statsCards[1].title = 'Kliknij, aby zobaczyć szczegółowy breakdown czasu oglądania';
                    statsCards[1].addEventListener('click', function() {
                        renderTimeBreakdown();
                    });
                }

                // Obejrzane - pokazuje listę obejrzanych anime
                if (statsCards[2]) {
                    statsCards[2].classList.add('clickable');
                    statsCards[2].title = 'Kliknij, aby zobaczyć listę obejrzanych anime';
                    statsCards[2].addEventListener('click', function() {
                        renderProfileAnimeList('completed');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Planowane - pokazuje listę planowanych anime
                if (statsCards[3]) {
                    statsCards[3].classList.add('clickable');
                    statsCards[3].title = 'Kliknij, aby zobaczyć listę planowanych anime';
                    statsCards[3].addEventListener('click', function() {
                        renderProfileAnimeList('upcoming');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Oglądane - pokazuje listę oglądanych anime
                if (statsCards[4]) {
                    statsCards[4].classList.add('clickable');
                    statsCards[4].title = 'Kliknij, aby zobaczyć listę oglądanych anime';
                    statsCards[4].addEventListener('click', function() {
                        renderProfileAnimeList('watching');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Wszystkie - pokazuje wszystkie anime
                if (statsCards[5]) {
                    statsCards[5].classList.add('clickable');
                    statsCards[5].title = 'Kliknij, aby zobaczyć wszystkie anime';
                    statsCards[5].addEventListener('click', function() {
                        renderProfileAnimeList('all');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Postęp - pokazuje listę anime z postępem
                if (statsCards[6]) {
                    statsCards[6].classList.add('clickable');
                    statsCards[6].title = 'Kliknij, aby zobaczyć postęp oglądania';
                    statsCards[6].addEventListener('click', function() {
                        renderProgressBreakdown();
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }

                // Renderuj statystyki tagów
                renderTagsStats();
            }

            // Statystyki tagów na profilu
            function renderTagsStats() {
                const container = document.getElementById('profile-tags-stats');
                if (!animeList.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                // Zbierz wszystkie tagi
                const tagMap = {};
                animeList.forEach(anime => {
                    if (anime.tags && Array.isArray(anime.tags)) {
                        anime.tags.forEach(tag => {
                            if (!tagMap[tag]) tagMap[tag] = {count:0, totalMinutes:0, ratings:[], animeCount:0};
                            tagMap[tag].animeCount++;
                            // Czas oglądania
                            let animeTime = 0;
                            
                            if (anime.seasons && anime.seasons.length > 1) {
                                // Oblicz czas dla każdego sezonu osobno
                                let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                anime.seasons.forEach((episodeCount, index) => {
                                    const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                                    const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                        ? anime.seasonEpisodeLengths[index] 
                                        : anime.episodeLength;
                                    animeTime += watchedThis * episodeLength;
                                    watched -= watchedThis;
                                });
                            } else {
                                const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                animeTime = watchedEpisodes * anime.episodeLength;
                            }
                            
                            // Rewatche
                            if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                                anime.seasonRewatches.forEach((rewatchCount, index) => {
                                    if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                        const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                            ? anime.seasonEpisodeLengths[index] 
                                            : anime.episodeLength;
                                        animeTime += rewatchCount * anime.seasons[index] * episodeLength;
                                    }
                                });
                            } else if (anime.rewatchCount) {
                                animeTime += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                            }
                            tagMap[tag].totalMinutes += animeTime;
                            tagMap[tag].ratings.push(anime.averageRating);
                        });
                    }
                });
                const tags = Object.keys(tagMap).sort((a,b)=>a.localeCompare(b));
                if (!tags.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                let html = `<h3 style='margin-bottom:1rem;'><i class="fas fa-tags"></i> Statystyki tagów</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tag</th>
                    <th style='text-align:left;padding:8px 4px;'>Liczba anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Czas łącznie</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                tags.forEach(tag => {
                    const t = tagMap[tag];
                    const avg = t.ratings.length ? (t.ratings.reduce((a,b)=>a+b,0)/t.ratings.length).toFixed(2) : '-';
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;'><span class='anime-tag tag-clickable' data-tag="${encodeURIComponent(tag)}">${tag}</span></td>
                        <td style='padding:8px 4px;'>${t.animeCount}</td>
                        <td style='padding:8px 4px;'>${formatTime(t.totalMinutes)}</td>
                        <td style='padding:8px 4px;'>${avg}</td>
                    </tr>`;
                });
                html += `</tbody></table></div>`;
                container.innerHTML = html;

                // Dodaj obsługę kliknięcia na tag
                container.querySelectorAll('.tag-clickable').forEach(el => {
                    el.style.cursor = 'pointer';
                    el.title = 'Pokaż anime z tym tagiem';
                    el.addEventListener('click', function(e) {
                        const tag = decodeURIComponent(this.dataset.tag);
                        renderProfileAnimeListByTag(tag);
                    });
                });
            }
            

            
            // Render anime list
            function renderAnimeList() {
                let sortedList = [...animeList];
                // Filtrowanie po wyszukiwaniu
                if (currentSearch.trim() !== '') {
                    const searchLower = currentSearch.trim().toLowerCase();
                    // Obsługa wyszukiwania po tagach: tag:nazwa
                    const tagMatch = searchLower.match(/^tag:(.+)$/);
                    if (tagMatch) {
                        const tagQuery = tagMatch[1].trim();
                        sortedList = sortedList.filter(anime => anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(tagQuery)));
                    } else {
                        sortedList = sortedList.filter(anime =>
                            anime.title.toLowerCase().includes(searchLower)
                            || (anime.status && anime.status.toLowerCase().includes(searchLower))
                            || (anime.ratings && Object.values(anime.ratings).some(val => (val+''||'').includes(searchLower)))
                            || (anime.averageRating+''||'').includes(searchLower)
                            || (anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(searchLower)))
                        );
                    }
                }
                // Sortowanie
                switch(currentSort) {
                    case 'averageRating':
                        sortedList.sort((a, b) => b.averageRating - a.averageRating || a.title.localeCompare(b.title));
                        break;
                    case 'graphics':
                        sortedList.sort((a, b) => b.ratings.graphics - a.ratings.graphics || a.title.localeCompare(b.title));
                        break;
                    case 'music':
                        sortedList.sort((a, b) => b.ratings.music - a.ratings.music || a.title.localeCompare(b.title));
                        break;
                    case 'characters':
                        sortedList.sort((a, b) => b.ratings.characters - a.ratings.characters || a.title.localeCompare(b.title));
                        break;
                    case 'story':
                        sortedList.sort((a, b) => b.ratings.story - a.ratings.story || a.title.localeCompare(b.title));
                        break;
                    case 'fun':
                        sortedList.sort((a, b) => b.ratings.fun - a.ratings.fun || a.title.localeCompare(b.title));
                        break;
                    case 'title':
                    default:
                        sortedList.sort((a, b) => a.title.localeCompare(b.title));
                        break;
                }
                // Paginacja
                let toShow;
                if (showAllCollection) {
                    toShow = sortedList;
                } else {
                    toShow = sortedList.slice(0, collectionPage * collectionPageSize);
                }
                if (sortedList.length === 0) {
                    animeListContainer.innerHTML = '<div class="no-anime">Nie znaleziono anime.' + (currentSearch ? ' Spróbuj innego hasła.' : ' Dodaj pierwsze używając formularza powyżej!') + '</div>';
                    document.getElementById('collection-controls').innerHTML = '';
                    return;
                }
                animeListContainer.innerHTML = '';
                toShow.forEach(anime => {
                    const animeCard = document.createElement('div');
                    animeCard.className = 'anime-card';
                    animeCard.dataset.id = anime.id;
                    
                    // Ustawianie tła tylko jeśli jest zdjęcie
                    if (anime.image) {
                        animeCard.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(${anime.image})`;
                        animeCard.style.backgroundSize = 'cover';
                        animeCard.style.backgroundPosition = 'center';
                    } else {
                        animeCard.style.backgroundImage = '';
                        animeCard.style.background = '';
                    }
                    
                    let statusClass = '';
                    let statusText = '';
                    
                    switch(anime.status) {
                        case 'watching':
                            statusClass = 'status-watching';
                            statusText = 'Oglądane';
                            break;
                        case 'completed':
                            statusClass = 'status-completed';
                            statusText = 'Obejrzane';
                            break;
                        case 'upcoming':
                            statusClass = 'status-upcoming';
                            statusText = 'Nadchodzące';
                            break;
                    }
                    
                    // Calculate watch progress
                    const watchProgress = anime.status === 'completed' ? 100 : 
                                        Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    
                    // Calculate watch time (including rewatches)
                    let mainTime = 0;
                    let rewatchTime = 0;
                    let rewatchCount = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        mainTime = anime.watchedEpisodes * anime.episodeLength;
                    }
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                                rewatchCount += count;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych - rewatchCount to liczba odcinków, nie liczba pełnych rewatchów
                        rewatchTime = anime.rewatchCount * anime.episodeLength;
                        rewatchCount = anime.rewatchCount;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    let episodesText = `${anime.watchedEpisodes}/${anime.totalEpisodes} (${watchProgress}%)`;
                    if (anime.rewatchCount && anime.rewatchCount > 0) {
                        episodesText += ` <span class="rewatch-info">(+${anime.rewatchCount} rewatch)</span>`;
                    }
                    let seasonsProgressHtml = '';
                    let hasSeasons = anime.seasons && anime.seasons.length > 1;
                    if (hasSeasons) {
                        // Przygotuj HTML z progressem sezonów (ukryty domyślnie)
                        let watched = anime.watchedEpisodes;
                        seasonsProgressHtml = `<div class='seasons-progress' id='seasons-progress-${anime.id}' style='display:none;margin-top:8px;transition:max-height 0.3s;overflow:hidden;'>`;
                        anime.seasons.forEach((count, idx) => {
                            let watchedThis = Math.max(0, Math.min(watched, count));
                            let percent = Math.round((watchedThis/count)*100);
                            let rewatchInfo = '';
                            if (anime.seasonRewatches && anime.seasonRewatches[idx] > 0) {
                                rewatchInfo = ` <span style='color:var(--primary);font-size:0.8em;'>(+${anime.seasonRewatches[idx]}x rewatch)</span>`;
                            }
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[idx] 
                                ? anime.seasonEpisodeLengths[idx] 
                                : anime.episodeLength;
                            
                            // Sprawdź czy sezon został ukończony i dodaj datę
                            let completionInfo = '';
                            if (checkSeasonCompletion(anime, idx) && anime.lastWatchedDate) {
                                completionInfo = ` <span style='color:var(--success);font-size:0.8em;' title="Automatycznie ustawione przy ukończeniu sezonu - zwiększ aktywność aby zobaczyć datę">✓ Ukończono ${formatDate(anime.lastWatchedDate)}</span>`;
                            }
                            // Sprawdź czy jest ręcznie ustawiona data ukończenia sezonu
                            if (anime.seasonCompletedDates && anime.seasonCompletedDates[idx]) {
                                completionInfo = ` <span style='color:var(--accent);font-size:0.8em;' title="Ręcznie ustawiona data ukończenia sezonu">✓ Ukończono ręcznie: ${formatDate(anime.seasonCompletedDates[idx])}</span>`;
                            }
                            
                            seasonsProgressHtml += `<div>Sezon ${idx+1}: ${watchedThis}/${count} (${percent}%) - ${episodeLength}min${rewatchInfo}${completionInfo}</div>`;
                            watched -= watchedThis;
                        });
                        seasonsProgressHtml += `</div>`;
                    }
                    
                    let tagHtml = '';
                    if (anime.tags && anime.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${anime.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    animeCard.innerHTML = `
                        <div class="anime-title">${anime.title}</div>
                        <span class="anime-status ${statusClass}">${statusText}</span>
                        ${tagHtml}
                        <div class="rating-container odcinki-row" data-id="${anime.id}" style="cursor:${hasSeasons ? 'pointer' : 'default'};">
                            <span class="rating-label">Odcinki:</span>
                            <span class="rating-value">${episodesText}${hasSeasons ? " <span style=\"font-size:0.8em;opacity:0.7;\">(kliknij)</span>" : ''}</span>
                        </div>
                        ${seasonsProgressHtml}
                        
                        <div class="rating-container">
                            <span class="rating-label">Czas:</span>
                            <span class="tooltip rating-value time-display" 
                                  title="Podstawowy: ${formatTime(mainTime)}\n${rewatchCount > 0 ? `Rewatch: ${formatTime(rewatchTime)}` : ''}">
                                ${formatTime(totalTime, 'hours')}
                                ${rewatchCount > 0 ? `<span class="rewatch-info">(${rewatchCount}x rewatch)</span>` : ''}
                            </span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Grafika:</span>
                            <span class="rating-value">${anime.ratings.graphics}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Muzyka:</span>
                            <span class="rating-value">${anime.ratings.music}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Postacie:</span>
                            <span class="rating-value">${anime.ratings.characters}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Fabuła:</span>
                            <span class="rating-value">${anime.ratings.story}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Śmieszność:</span>
                            <span class="rating-value">${anime.ratings.fun}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Średnia:</span>
                            <span class="rating-value">${anime.averageRating}</span>
                        </div>
                        
                        ${anime.completedDate ? `
                        <div class="rating-container">
                            <span class="rating-label">Ukończono:</span>
                            <span class="rating-value tooltip" title="${anime.completedDate ? 'Data ukończenia anime' : 'Automatycznie ustawione przy ukończeniu anime'}">${formatDate(anime.completedDate)}</span>
                        </div>
                        ` : ''}
                        
                        ${anime.lastWatchedDate ? `
                        <div class="rating-container">
                            <span class="rating-label">Ostatnio oglądano:</span>
                            <span class="rating-value tooltip" title="Aktualizowane przy zwiększaniu aktywności - kliknij przycisk + aby dodać odcinki">${formatDate(anime.lastWatchedDate)}</span>
                        </div>
                        ` : ''}
                        
                        ${anime.completedDate || anime.lastWatchedDate ? `
                        <div style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid var(--primary);">
                            <small style="color:var(--gray);font-size:0.8rem;">
                                <i class="fas fa-info-circle"></i> Daty są automatycznie śledzone przy zwiększaniu aktywności
                            </small>
                        </div>
                        ` : ''}
                        
                        <div class="actions">
                            <button class="add-episodes-btn btn-success" data-id="${anime.id}" title="Dodaj odcinki">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button class="edit-btn" data-id="${anime.id}"><i class="fas fa-edit"></i> Edytuj</button>
                            <button class="delete-btn btn-danger" data-id="${anime.id}"><i class="fas fa-trash"></i> Usuń</button>
                        </div>
                    `;
                    
                    // NIE dodaję podglądu obrazka ani przycisku usuwania zdjęcia
                    animeListContainer.appendChild(animeCard);
                });
                
                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        if (confirm('Czy na pewno chcesz usunąć to anime z listy?')) {
                            const id = parseInt(this.dataset.id);
                            animeList = animeList.filter(anime => anime.id !== id);
                            saveAnimeList();
                            renderAnimeList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Anime zostało usunięte!', 'danger');
                        }
                    });
                });
                
                            // Add event listeners for add episodes buttons
            document.querySelectorAll('.add-episodes-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.dataset.id);
                    showEpisodeModal(id);
                });
            });
            
            // Funkcja do sprawdzania czy anime zostało ukończone
            function checkAnimeCompletion(anime) {
                if (anime.seasons && anime.seasons.length > 1) {
                    // Dla anime z wieloma sezonami
                    let totalEpisodes = 0;
                    let watchedEpisodes = 0;
                    anime.seasons.forEach((episodeCount, index) => {
                        totalEpisodes += episodeCount;
                        const watchedThis = Math.min(anime.watchedEpisodes - watchedEpisodes, episodeCount);
                        watchedEpisodes += watchedThis;
                    });
                    console.log('checkAnimeCompletion dla sezonów:', { 
                        title: anime.title, 
                        watchedEpisodes: anime.watchedEpisodes, 
                        totalEpisodes, 
                        watchedEpisodes, 
                        isCompleted: watchedEpisodes >= totalEpisodes,
                        seasons: anime.seasons
                    });
                    return watchedEpisodes >= totalEpisodes;
                } else {
                    // Dla pojedynczego sezonu
                    console.log('checkAnimeCompletion dla pojedynczego sezonu:', { 
                        title: anime.title, 
                        watchedEpisodes: anime.watchedEpisodes, 
                        totalEpisodes: anime.totalEpisodes, 
                        isCompleted: anime.watchedEpisodes >= anime.totalEpisodes 
                    });
                    return anime.watchedEpisodes >= anime.totalEpisodes;
                }
            }
            
            // Funkcja do sprawdzania czy konkretny sezon został ukończony
            function checkSeasonCompletion(anime, seasonIndex) {
                if (anime.seasons && anime.seasons[seasonIndex]) {
                    const seasonEpisodes = anime.seasons[seasonIndex];
                    let watchedInSeason = 0;
                    
                    // Oblicz ile odcinków zostało obejrzanych w tym sezonie
                    let remainingWatched = anime.watchedEpisodes;
                    for (let i = 0; i < seasonIndex; i++) {
                        if (anime.seasons[i]) {
                            remainingWatched -= anime.seasons[i];
                        }
                    }
                    watchedInSeason = Math.max(0, Math.min(remainingWatched, seasonEpisodes));
                    
                    return watchedInSeason >= seasonEpisodes;
                }
                return false;
            }
            

                
                // Add event listeners for edit buttons
                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const animeToEdit = animeList.find(anime => anime.id === id);
                        
                        if (animeToEdit) {
                            document.getElementById('title').value = animeToEdit.title;
                            document.getElementById('status').value = animeToEdit.status;
                            document.getElementById('total-episodes').value = animeToEdit.totalEpisodes;
                            document.getElementById('episode-length').value = animeToEdit.episodeLength;
                            document.getElementById('watched-episodes').value = animeToEdit.watchedEpisodes;
                            
                            // Wypełnij pole daty ukończenia jeśli istnieje
                            if (animeToEdit.completedDate) {
                                document.getElementById('completed-date').value = animeToEdit.completedDate;
                            } else {
                                document.getElementById('completed-date').value = '';
                            }
                            toggleCompletedDateField();
                            document.getElementById('graphics').value = animeToEdit.ratings.graphics;
                            document.getElementById('music').value = animeToEdit.ratings.music;
                            document.getElementById('characters').value = animeToEdit.ratings.characters;
                            document.getElementById('story').value = animeToEdit.ratings.story;
                            document.getElementById('fun').value = animeToEdit.ratings.fun;
                            document.getElementById('anime-tags').value = animeToEdit.tags ? animeToEdit.tags.join('; ') : '';
                            editIdInput.value = animeToEdit.id;
                            
                            // Set image preview if available
                            if (animeToEdit.image) {
                                currentImageData = animeToEdit.image;
                                showImagePreview(currentImageData);
                                // Dodaję przycisk Usuń zdjęcie pod podglądem
                                imagePreview.innerHTML += `<button type='button' id='remove-image-btn' class='btn-danger' style='width:100%;margin-top:8px;'><i class='fas fa-trash'></i> Usuń zdjęcie</button>`;
                                document.getElementById('remove-image-btn').onclick = function() {
                                    if (confirm('Czy na pewno chcesz usunąć zdjęcie?')) {
                                        animeToEdit.image = null;
                                        currentImageData = null;
                                        showImagePlaceholder();
                                    }
                                };
                            } else {
                                currentImageData = null;
                                showImagePlaceholder();
                            }

                            // Fill season inputs if needed
                            fillSeasonInputsIfNeeded(animeToEdit);
                            
                            formTitle.innerHTML = '<i class="fas fa-edit"></i> Edytuj anime';
                            submitBtn.innerHTML = '<i class="fas fa-save"></i> Zapisz zmiany';
                            cancelEditBtn.style.display = 'inline-block';
                            
                            calculateAverage();
                            
                            // Scroll to form
                            document.getElementById('dodaj').scrollIntoView({ behavior: 'smooth' });
                        }
                    });
                });

                // Paginacja - pokaż przycisk "Załaduj więcej" jeśli są jeszcze anime do załadowania
                const collectionControls = document.getElementById('collection-controls');
                if (sortedList.length > collectionPage * collectionPageSize) {
                    collectionControls.innerHTML = `<button id="load-more-btn" class="btn-accent"><i class="fas fa-plus"></i> Załaduj więcej (${sortedList.length - (collectionPage * collectionPageSize)} pozostałych)</button>`;
                } else {
                    collectionControls.innerHTML = '';
                }
                const loadMoreBtn = document.getElementById('load-more-btn');
                if (loadMoreBtn) {
                    loadMoreBtn.onclick = function() {
                        collectionPage++;
                        renderAnimeList();
                    };
                }

                // Dodaj event listener na animeListContainer
                animeListContainer.addEventListener('click', function(event) {
                    const target = event.target;
                    if (target.classList.contains('rating-value')) {
                        const row = target.closest('.odcinki-row');
                        const id = parseInt(row.dataset.id);
                        const anime = animeList.find(a => a.id === id);
                        if (anime && anime.seasons && anime.seasons.length > 1) {
                            const seasonsProgress = document.getElementById(`seasons-progress-${id}`);
                            if (seasonsProgress) {
                                seasonsProgress.style.display = seasonsProgress.style.display === 'none' ? 'block' : 'none';
                            }
                        }
                    }
                });
            }
            
            // Render tier list
            function renderTierList() {
                // Clear all tiers
                document.getElementById('tier-SSS').innerHTML = '';
                document.getElementById('tier-SS').innerHTML = '';
                document.getElementById('tier-S').innerHTML = '';
                document.getElementById('tier-A').innerHTML = '';
                document.getElementById('tier-B').innerHTML = '';
                document.getElementById('tier-C').innerHTML = '';
                document.getElementById('tier-D').innerHTML = '';
                document.getElementById('tier-F').innerHTML = '';
                
                animeList.forEach(anime => {
                    const tierItem = document.createElement('div');
                    tierItem.className = 'tier-item';
                    tierItem.textContent = anime.title;
                    tierItem.title = `Średnia: ${anime.averageRating}\nGrafika: ${anime.ratings.graphics}\nMuzyka: ${anime.ratings.music}\nPostacie: ${anime.ratings.characters}\nFabuła: ${anime.ratings.story}\nŚmieszność: ${anime.ratings.fun}`;
                    
                    // Determine which tier to place the anime in based on current category
                    let rating;
                    if (currentTierCategory === 'average') {
                        rating = anime.averageRating;
                    } else {
                        rating = anime.ratings[currentTierCategory];
                    }
                    
                    if (rating === 11) {
                        tierItem.classList.add('sss-item');
                        document.getElementById('tier-SSS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 10) {
                        document.getElementById('tier-SS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 9) {
                        document.getElementById('tier-S').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 8) {
                        document.getElementById('tier-A').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 6 && rating <= 7) {
                        document.getElementById('tier-B').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 5) {
                        document.getElementById('tier-C').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 3 && rating <= 4) {
                        document.getElementById('tier-D').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 1 && rating <= 2) {
                        document.getElementById('tier-F').appendChild(tierItem.cloneNode(true));
                    }
                });
            }
            
            // Render planner list
            function renderPlannerList() {
                const plannerContainer = document.getElementById('planner-list');
                
                if (plannerList.length === 0) {
                    plannerContainer.innerHTML = '<div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>';
                    return;
                }
                
                // Sort by priority (duży -> średni -> niski)
                const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                const sortedPlanner = [...plannerList].sort((a, b) => {
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                });
                
                plannerContainer.innerHTML = '';
                
                sortedPlanner.forEach(item => {
                    const plannerCard = document.createElement('div');
                    plannerCard.className = 'planner-card';
                    plannerCard.dataset.id = item.id;
                    
                    let notesHtml = '';
                    if (item.notes && item.notes.trim()) {
                        notesHtml = `<div class="planner-notes"><i class="fas fa-sticky-note"></i> ${item.notes}</div>`;
                    }
                    
                    let tagHtml = '';
                    if (item.tags && item.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${item.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    plannerCard.innerHTML = `
                        <div class="anime-title">${item.title}</div>
                        ${tagHtml}
                        <span class="priority-badge priority-${item.priority}">Priorytet: ${item.priority}</span>
                        <div style="margin-bottom:8px;color:var(--gray);font-size:0.95em;">
                            ${item.seasonCount ? `Sezony: <b>${item.seasonCount}</b>` : ''}
                            ${item.totalEpisodes ? `&nbsp;Odcinki: <b>${item.totalEpisodes}</b>` : ''}
                            ${item.seasonEpisodeLengths && item.seasonEpisodeLengths.length > 1 ? 
                                `<br><span style="font-size:0.85em;">Długości: ${item.seasonEpisodeLengths.map((len, idx) => `S${idx+1}: ${len}min`).join(', ')}</span>` : ''}
                        </div>
                        ${notesHtml}
                        <div class="planner-actions">
                            <button class="start-watching-btn btn-success" data-id="${item.id}">
                                <i class="fas fa-play"></i> Zacznij oglądać
                            </button>
                            <button class="edit-planner-btn btn-secondary" data-id="${item.id}">
                                <i class="fas fa-edit"></i> Edytuj
                            </button>
                            <button class="delete-planner-btn btn-danger" data-id="${item.id}">
                                <i class="fas fa-trash"></i> Usuń
                            </button>
                        </div>
                    `;
                    
                    plannerContainer.appendChild(plannerCard);
                });
                
                // Add event listeners
                document.querySelectorAll('.start-watching-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            // Add to anime list as "upcoming" (Nadchodzące)
const animeData = {
    id: Date.now(),
    title: plannerItem.title,
    status: 'watching',
    totalEpisodes: (plannerItem.seasons && plannerItem.seasons.length > 1)
        ? plannerItem.seasons.reduce((a, b) => a + b, 0)
        : (plannerItem.totalEpisodes || 12),
    episodeLength: 24,
    watchedEpisodes: 0,
    rewatchCount: 0,
    ratings: {
        graphics: 5,
        music: 5,
        characters: 5,
        story: 5,
        fun: 5
    },
    averageRating: 5,
    createdAt: new Date().toISOString(),
    seasons: plannerItem.seasons,
    seasonEpisodeLengths: plannerItem.seasonEpisodeLengths
};
                            
                            animeList.push(animeData);
                            saveAnimeList();
                            
                            // Remove from planner
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            
                            // Update displays
                            renderAnimeList();
                            renderPlannerList();
                            updateProfileStats();
                            
                            showNotification(`"${plannerItem.title}" zostało dodane do nadchodzących!`, 'success');
                        }
                    });
                });
                
                document.querySelectorAll('.edit-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            document.getElementById('planner-title').value = plannerItem.title;
                            document.getElementById('planner-priority').value = plannerItem.priority;
                            document.getElementById('planner-notes').value = plannerItem.notes || '';
                            plannerTagsInput.value = plannerItem.tags ? plannerItem.tags.join('; ') : '';
                            
                            // Fill season inputs if needed
                            if (plannerItem.seasons && plannerItem.seasons.length > 1) {
                                plannerSeasonCountInput.value = plannerItem.seasons.length;
                                plannerSeasonCountInput.dispatchEvent(new Event('input'));
                                const episodeLengthValues = plannerItem.seasonEpisodeLengths || [];
                                setTimeout(() => {
                                    const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                                    const episodeLengthInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episode-length');
                                    seasonInputs.forEach((input, index) => {
                                        if (plannerItem.seasons[index]) {
                                            input.value = plannerItem.seasons[index];
                                        }
                                    });
                                    episodeLengthInputs.forEach((input, index) => {
                                        if (episodeLengthValues[index] !== undefined) {
                                            input.value = episodeLengthValues[index];
                                        } else {
                                            input.value = 24; // domyślna długość
                                        }
                                    });
                                    updatePlannerTotalEpisodesFromSeasons();
                                }, 10);
                            } else {
                                plannerSeasonCountInput.value = 1;
                                plannerSeasonsContainer.innerHTML = '';
                                plannerSeasonsContainer.style.display = 'none';
                                plannerTotalEpisodesInput.readOnly = false;
                            }
                            
                            // Change button text
                            const addBtn = document.getElementById('add-to-planner');
                            addBtn.innerHTML = '<i class="fas fa-save"></i> Zapisz zmiany';
                            addBtn.dataset.editId = id;
                            
                            // Scroll to planner form
                            const plannerSection = document.getElementById('planer');
                            plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                });
                
                document.querySelectorAll('.delete-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem && confirm(`Czy na pewno chcesz usunąć "${plannerItem.title}" z planera?`)) {
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            renderPlannerList();
                            showNotification('Anime zostało usunięte z planera!', 'danger');
                        }
                    });
                });
            }
            
            // Tier category switching
            tierCategoryBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentTierCategory = this.dataset.category;
                    
                    // Update active button
                    tierCategoryBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tier list
                    renderTierList();
                });
            });
            
            // Export data
            exportBtn.addEventListener('click', function() {
                const exportData = {
                    animeList: animeList,
                    plannerList: plannerList
                };
                const dataStr = JSON.stringify(exportData);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'anime-toolkit-data-'+new Date().toISOString().slice(0,10)+'.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showNotification('Dane zostały wyeksportowane!', 'success');
            });
            
            // Import data
            importBtn.addEventListener('click', function() {
                importFile.click();
            });
            
            importFile.addEventListener('change', function(event) {
                const file = event.target.files[0];
                
                if (!file) {
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (confirm('Czy na pewno chcesz zaimportować nowe dane? Obecne dane zostaną zastąpione.')) {
                            // Handle both old format (array) and new format (object)
                            if (Array.isArray(importedData)) {
                                // Old format - just anime list
                                animeList = importedData;
                                plannerList = [];
                            } else if (importedData.animeList && importedData.plannerList) {
                                // New format - both anime and planner data
                                animeList = importedData.animeList;
                                plannerList = importedData.plannerList;
                            } else {
                                showNotification('Nieprawidłowy format pliku!', 'danger');
                                return;
                            }
                            
                            saveAnimeList();
                            savePlannerList();
                            renderAnimeList();
                            renderPlannerList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Dane zostały zaimportowane!', 'success');
                        }
                    } catch (error) {
                        showNotification('Błąd podczas importowania pliku: ' + error.message, 'danger');
                    }
                    
                    // Reset file input
                    importFile.value = '';
                };
                reader.readAsText(file);
            });
            
            // Clear all data
            clearBtn.addEventListener('click', function() {
                if (confirm('Czy na pewno chcesz usunąć wszystkie dane? Tej operacji nie można cofnąć.')) {
                    animeList = [];
                    plannerList = [];
                    saveAnimeList();
                    savePlannerList();
                    renderAnimeList();
                    renderPlannerList();
                    renderTierList();
                    updateProfileStats();
                    showNotification('Wszystkie dane zostały usunięte!', 'danger');
                }
            });
            
            // Scroll to top button
            scrollTopBtn.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollTopBtn.style.display = 'flex';
                } else {
                    scrollTopBtn.style.display = 'none';
                }
            });
            
            // Navbar functionality
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);

                    // Przewiń do wybranej sekcji
                    window.scrollTo({top: targetSection.offsetTop - 80, behavior: 'smooth'});
                });
            });

            // Show notification
            function showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
            
            // === SYSTEM TRANSFERU DANYCH (HYBRID: GITHUB + LOCALSTORAGE) ===
            
            // === BEZPIECZNA KONFIGURACJA GITHUB ===
            
            // Zabezpieczenie tokena - proste i niezawodne kodowanie Base64
            // (Złożone XOR kodowanie usunięte z powodu problemów z kodowaniem znaków)
            
            /*
            // Stare wielowarstwowe zabezpieczenie (wyłączone)
            function encodeToken(token) {
                // Warstwa 1: XOR z dynamicznym kluczem  
                const xored = token.split('').map((char, i) => 
                    String.fromCharCode(char.charCodeAt(0) ^ (i % 7 + 42))
                ).join('');
                // Warstwa 2: Base64
                return btoa(xored);
            }
            */
            
            // Tymczasowo - wygeneruj segmenty i wyświetl w konsoli
            console.log('🔧 Generuję segmenty...');
            const tempToken = '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';
            const tempEncoded = btoa(tempToken);
            const tempLen = tempEncoded.length;
            const tempSegSize = Math.ceil(tempLen / 4);
            
            const tempSegments = [
                tempEncoded.substr(0, tempSegSize),
                tempEncoded.substr(tempSegSize, tempSegSize), 
                tempEncoded.substr(tempSegSize * 2, tempSegSize),
                tempEncoded.substr(tempSegSize * 3)
            ];
            
            console.log('Segmenty do użycia w kodzie:', tempSegments);
            
            // Konfiguracja API endpoints (wewnętrzne) - wygenerowane segmenty
            const API_CONFIG_SEGMENTS = tempSegments;
            
            // Funkcja łączenia segmentów konfiguracji
            function assembleApiConfig() {
                return API_CONFIG_SEGMENTS.join('');
            }
            
            // Funkcja do pobierania klucza autoryzacji
            function getGitHubToken() {
                const configString = assembleApiConfig();
                // Użyj prostszego dekodowania - tylko Base64
                try {
                    return atob(configString);
                } catch (e) {
                    console.error('Błąd dekodowania klucza API');
                    return '';
                }
            }
            
            const GITHUB_CONFIG = {
                get token() {
                    return getGitHubToken();
                },
                owner: 'EppcPL',
                repo: 'anilista',
                file: 'dane.json'
            };

            // Flaga czy GitHub API działa
            let githubApiWorking = true;
            
            // Reset API status przy nowym tokenie
            console.log('🔄 Zabezpieczony klucz API został załadowany - resetuję status API');
            
            // Test dekodowania tokena
            const testToken = getGitHubToken();
            console.log('🔍 Test dekodowanego tokena:', testToken ? `${testToken.substring(0, 8)}...` : 'BŁĄD');
            if (!testToken || !testToken.startsWith('ghp_')) {
                console.error('❌ BŁĄD: Token nie dekoduje się prawidłowo!');
            } else {
                console.log('✅ Token dekoduje się prawidłowo');
            }
            
            // Zmylne dane (red herring) - NIE SĄ TO PRAWDZIWE TOKENY
            const DUMMY_CONFIGS = [
                'ghp_1234567890abcdef1234567890abcdef12345678',  // Dummy token 1
                'github_pat_11DUMMY123456789DUMMY123456_FAKE',   // Dummy token 2
                'fake_token_for_obfuscation_purposes_only'       // Dummy token 3
            ];
            
            // Funkcja sprawdzająca integralność (dodatkowe zabezpieczenie)
            function validateApiAccess() {
                const token = getGitHubToken();
                return token && token.length > 30 && (token.startsWith('ghp_') || token.startsWith('github_pat_'));
            }
            

            
            // Funkcja do testowania uprawnień tokena
            async function testGitHubToken() {
                try {
                    // Sprawdź integralność tokena
                    if (!validateApiAccess()) {
                        throw new Error('Błąd integralności klucza API');
                    }
                    
                    console.log('🧪 Testuję uprawnienia zabezpieczonego tokena GitHub...');
                    
                    // Test czytania
                    const readResponse = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`, {
                        headers: {
                            'Authorization': `token ${GITHUB_CONFIG.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (!readResponse.ok) {
                        throw new Error(`Błąd dostępu do repozytorium: ${readResponse.status}`);
                    }
                    
                    console.log('✅ Token ma dostęp do odczytu repozytorium');
                    
                    // Test zapisu - spróbuj pobrać dane.json żeby sprawdzić uprawnienia
                    const writeTestResponse = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.file}`, {
                        headers: {
                            'Authorization': `token ${GITHUB_CONFIG.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (writeTestResponse.ok || writeTestResponse.status === 404) {
                        console.log('✅ Token ma uprawnienia do zapisu plików');
                        githubApiWorking = true;
                        showNotification('GitHub API gotowe!', 'success');
                    } else {
                        throw new Error(`Brak uprawnień do zapisu: ${writeTestResponse.status}`);
                    }
                    
                } catch (error) {
                    console.error('❌ Problem z tokenem GitHub:', error.message);
                    githubApiWorking = false;
                    showNotification('Token GitHub ma ograniczone uprawnienia', 'warning');
                }
            }

            // === FUNKCJE LOCALSTORAGE (FALLBACK) ===
            
            function getLocalStorageData() {
                try {
                    const data = localStorage.getItem('transfer_codes_backup');
                    return data ? JSON.parse(data) : { transfer_codes: {} };
                } catch (error) {
                    console.error('Błąd pobierania z localStorage:', error);
                    return { transfer_codes: {} };
                }
            }
            
            function saveLocalStorageData(data) {
                try {
                    localStorage.setItem('transfer_codes_backup', JSON.stringify(data));
                    return true;
                } catch (error) {
                    console.error('Błąd zapisywania do localStorage:', error);
                    return false;
                }
            }
            
            function cleanExpiredCodesLocal() {
                const data = getLocalStorageData();
                const now = Date.now();
                let hasExpired = false;
                
                Object.keys(data.transfer_codes || {}).forEach(code => {
                    const codeData = data.transfer_codes[code];
                    if (codeData && codeData.expiresAt && now > codeData.expiresAt) {
                        delete data.transfer_codes[code];
                        hasExpired = true;
                        console.log('Usunięto przeterminowany kod (localStorage):', code);
                    }
                });
                
                if (hasExpired) {
                    saveLocalStorageData(data);
                }
            }

            // === FUNKCJE GITHUB API ===

            // Funkcja do pobierania pliku dane.json z GitHub
            async function getGitHubData() {
                try {
                    const response = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.file}`, {
                        headers: {
                            'Authorization': `token ${GITHUB_CONFIG.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (response.status === 404) {
                        // Plik nie istnieje, zwróć pustą strukturę
                        console.log('Plik dane.json nie istnieje na GitHub, tworzę pustą strukturę');
                        return { transfer_codes: {} };
                    }
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const fileData = await response.json();
                    
                    // Sprawdź czy plik ma zawartość
                    if (!fileData.content) {
                        console.log('Plik dane.json jest pusty, zwracam pustą strukturę');
                        return { transfer_codes: {} };
                    }
                    
                    try {
                        const content = atob(fileData.content.replace(/\s/g, ''));
                        
                        // Sprawdź czy dekodowana zawartość nie jest pusta
                        if (!content.trim()) {
                            console.log('Dekodowana zawartość pliku jest pusta, zwracam pustą strukturę');
                            return { transfer_codes: {} };
                        }
                        
                        const parsedData = JSON.parse(content);
                        
                        // Sprawdź czy struktura jest poprawna
                        if (!parsedData || typeof parsedData !== 'object') {
                            console.log('Niepoprawna struktura JSON, zwracam pustą strukturę');
                            return { transfer_codes: {} };
                        }
                        
                        // Upewnij się że transfer_codes istnieje
                        if (!parsedData.transfer_codes) {
                            parsedData.transfer_codes = {};
                        }
                        
                        return parsedData;
                        
                    } catch (parseError) {
                        console.log('Błąd parsowania JSON, prawdopodobnie uszkodzony plik. Zwracam pustą strukturę:', parseError.message);
                        return { transfer_codes: {} };
                    }
                    
                } catch (error) {
                    console.error('Błąd pobierania danych z GitHub:', error);
                    githubApiWorking = false;
                    throw error;
                }
            }

            // Funkcja hybrydowa - pobiera z GitHub lub localStorage
            async function getData() {
                if (githubApiWorking) {
                    try {
                        const data = await getGitHubData();
                        // Synchronizuj z localStorage na wszelki wypadek
                        saveLocalStorageData(data);
                        return data;
                    } catch (error) {
                        console.log('GitHub API niedostępne, używam localStorage...');
                        githubApiWorking = false;
                        return getLocalStorageData();
                    }
                } else {
                    return getLocalStorageData();
                }
            }

            // Funkcja do zapisywania pliku dane.json na GitHub
            async function saveGitHubData(data) {
                try {
                    // Upewnij się że dane mają poprawną strukturę
                    if (!data.transfer_codes) {
                        data.transfer_codes = {};
                    }
                    
                    // Najpierw pobierz aktualny SHA pliku
                    let sha = null;
                    let fileExists = false;
                    
                    try {
                        const currentFile = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.file}`, {
                            headers: {
                                'Authorization': `token ${GITHUB_CONFIG.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });
                        
                        if (currentFile.ok) {
                            const currentData = await currentFile.json();
                            sha = currentData.sha;
                            fileExists = true;
                            console.log('Plik dane.json już istnieje na GitHub, aktualizuję...');
                        } else if (currentFile.status === 404) {
                            console.log('Plik dane.json nie istnieje na GitHub, tworzę nowy...');
                            fileExists = false;
                        }
                    } catch (e) {
                        console.log('Błąd sprawdzania pliku, próbuję utworzyć nowy:', e.message);
                        fileExists = false;
                    }
                    
                    // Przygotuj zawartość z odpowiednim formatowaniem
                    const jsonContent = JSON.stringify(data, null, 2);
                    const content = btoa(jsonContent);
                    
                    const requestBody = {
                        message: fileExists ? `Update transfer codes - ${new Date().toISOString()}` : `Create transfer codes file - ${new Date().toISOString()}`,
                        content: content
                    };
                    
                    // Dodaj SHA tylko jeśli plik istnieje
                    if (sha) {
                        requestBody.sha = sha;
                    }
                    
                    console.log('Zapisuję dane na GitHub...', fileExists ? '(aktualizacja)' : '(nowy plik)');
                    console.log('Dane do zapisania:', JSON.stringify(data, null, 2));
                    
                    const response = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.file}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${GITHUB_CONFIG.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('GitHub API response:', errorText);
                        throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
                    }
                    
                    const result = await response.json();
                    console.log('Pomyślnie zapisano na GitHub!');
                    return result;
                    
                } catch (error) {
                    console.error('Błąd zapisywania na GitHub:', error);
                    githubApiWorking = false;
                    throw error;
                }
            }

            // Funkcja hybrydowa - zapisuje do GitHub lub localStorage
            async function saveData(data) {
                // Zawsze zapisz do localStorage jako backup
                const localSaved = saveLocalStorageData(data);
                console.log('Dane zapisane do localStorage jako backup');
                
                if (githubApiWorking) {
                    try {
                        await saveGitHubData(data);
                        console.log('✅ Dane zapisane na GitHub');
                        showNotification('Kod zapisany na GitHub!', 'success');
                        return true;
                    } catch (error) {
                        console.log('❌ GitHub API niedostępne (błąd zapisu), przechodzę na localStorage');
                        console.log('Błąd GitHub:', error.message);
                        githubApiWorking = false;
                        showNotification('Kod zapisany lokalnie (GitHub niedostępny dla zapisu)', 'warning');
                        return false;
                    }
                } else {
                    console.log('📱 Używam localStorage (GitHub API wyłączone)');
                    showNotification('Kod zapisany lokalnie', 'warning');
                    return false;
                }
            }

            // Funkcja do czyszczenia przeterminowanych kodów (hybrydowa)
            async function cleanExpiredCodes() {
                try {
                    // Czyść w localStorage zawsze
                    cleanExpiredCodesLocal();
                    
                    // Spróbuj też na GitHub jeśli działa
                    if (githubApiWorking) {
                        try {
                            const data = await getData();
                            const now = Date.now();
                            let hasExpired = false;
                            
                            Object.keys(data.transfer_codes || {}).forEach(code => {
                                const codeData = data.transfer_codes[code];
                                if (codeData && codeData.expiresAt && now > codeData.expiresAt) {
                                    delete data.transfer_codes[code];
                                    hasExpired = true;
                                    console.log('Usunięto przeterminowany kod:', code);
                                }
                            });
                            
                            if (hasExpired) {
                                await saveData(data);
                            }
                        } catch (error) {
                            console.log('Czyszczenie GitHub nie powiodło się, używam localStorage');
                        }
                    }
                } catch (error) {
                    console.error('Błąd podczas czyszczenia przeterminowanych kodów:', error);
                }
            }

            // Funkcja do generowania losowego 6-cyfrowego kodu
            async function generateTransferCode() {
                const data = await getData();
                let code;
                do {
                    code = Math.floor(100000 + Math.random() * 900000).toString();
                } while (data.transfer_codes && data.transfer_codes[code]);
                return code;
            }

            // Funkcja do zapisania danych do kodu (hybrydowa)
            async function saveDataToCode(code) {
                try {
                    const transferData = {
                        animeList: animeList,
                        plannerList: plannerList,
                        activityData: activityData,
                        activityDetails: activityDetails,
                        createdAt: Date.now(),
                        expiresAt: Date.now() + (60 * 60 * 1000) // 1 godzina
                    };
                    
                    const data = await getData();
                    if (!data.transfer_codes) {
                        data.transfer_codes = {};
                    }
                    
                    data.transfer_codes[code] = transferData;
                    const saved = await saveData(data);
                    
                    console.log(`✅ Kod ${code} został wygenerowany i zapisany`);
                    
                    return transferData;
                } catch (error) {
                    console.error('Błąd zapisywania kodu:', error);
                    throw error;
                }
            }

            // Funkcja do pobierania danych z kodu (hybrydowa)
            async function getDataFromCode(code) {
                try {
                    const data = await getData();
                    
                    if (!data.transfer_codes || !data.transfer_codes[code]) {
                        return null;
                    }
                    
                    const codeData = data.transfer_codes[code];
                    
                    // Sprawdź czy kod nie wygasł
                    if (Date.now() > codeData.expiresAt) {
                        // Usuń wygasły kod
                        delete data.transfer_codes[code];
                        await saveData(data);
                        return null;
                    }
                    
                    return codeData;
                } catch (error) {
                    console.error('Błąd pobierania kodu:', error);
                    return null;
                }
            }

            // Funkcja do usuwania kodu po pomyślnym imporcie (hybrydowa)
            async function removeCode(code) {
                try {
                    const data = await getData();
                    
                    if (data.transfer_codes && data.transfer_codes[code]) {
                        delete data.transfer_codes[code];
                        const saved = await saveData(data);
                        
                        if (saved) {
                            console.log(`Usunięto kod ${code} z GitHub`);
                        } else {
                            console.log(`Usunięto kod ${code} lokalnie`);
                        }
                    }
                } catch (error) {
                    console.error('Błąd usuwania kodu:', error);
                }
            }

            // Obsługa generowania kodu
            document.getElementById('generate-code-card').addEventListener('click', async function() {
                const modal = document.getElementById('generate-code-modal');
                const codeDisplay = document.getElementById('generated-code');
                const timeRemaining = document.getElementById('time-remaining');
                
                try {
                    // Pokaż modal z loadingiem
                    codeDisplay.textContent = 'Generowanie...';
                    modal.classList.add('show');
                    
                    // Generuj kod
                    const code = await generateTransferCode();
                    const transferData = await saveDataToCode(code);
                    
                    codeDisplay.textContent = code;
                    
                    // Timer odliczający
                    let timeLeft = 60 * 60; // 1 godzina w sekundach
                    const timer = setInterval(() => {
                        timeLeft--;
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        timeRemaining.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        
                        if (timeLeft <= 0) {
                            clearInterval(timer);
                            modal.classList.remove('show');
                            showNotification('Kod wygasł!', 'warning');
                        }
                    }, 1000);
                    
                    // Zapisz timer i kod do modal żeby można było go wyczyścić
                    modal.dataset.timer = timer;
                    modal.dataset.code = code;
                    
                    showNotification(`Kod ${code} został wygenerowany i zapisany na GitHub!`, 'success');
                } catch (error) {
                    modal.classList.remove('show');
                    showNotification('Błąd podczas generowania kodu: ' + error.message, 'danger');
                    console.error('Błąd generowania kodu:', error);
                }
            });

            // Obsługa kopiowania kodu
            document.getElementById('copy-code-btn').addEventListener('click', function() {
                const code = document.getElementById('generated-code').textContent;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(code).then(() => {
                        showNotification('Kod skopiowany do schowka!', 'success');
                    });
                } else {
                    // Fallback dla starszych przeglądarek
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification('Kod skopiowany do schowka!', 'success');
                }
            });

            // Obsługa wpisywania kodu
            document.getElementById('import-code-card').addEventListener('click', function() {
                const modal = document.getElementById('import-code-modal');
                const input = document.getElementById('import-code-input');
                const preview = document.getElementById('import-preview');
                
                input.value = '';
                input.classList.remove('error');
                preview.style.display = 'none';
                
                modal.classList.add('show');
                
                // Focus na input
                setTimeout(() => {
                    input.focus();
                }, 100);
            });

            // Obsługa wpisywania w input
            document.getElementById('import-code-input').addEventListener('input', async function() {
                const code = this.value.replace(/\D/g, ''); // Tylko cyfry
                this.value = code;
                
                this.classList.remove('error');
                const preview = document.getElementById('import-preview');
                const previewContent = document.getElementById('import-preview-content');
                preview.style.display = 'none';
                
                if (code.length === 6) {
                    try {
                        // Pokaż loading
                        previewContent.innerHTML = '<div style="text-align: center; padding: 1rem;"><i class="fas fa-spinner fa-spin"></i> Sprawdzanie kodu...</div>';
                        preview.style.display = 'block';
                        
                        // Sprawdź kod na GitHub
                        const transferData = await getDataFromCode(code);
                        
                        if (transferData) {
                            // Pokaż podgląd danych
                            const animeCount = transferData.animeList ? transferData.animeList.length : 0;
                            const plannerCount = transferData.plannerList ? transferData.plannerList.length : 0;
                            const activityDays = transferData.activityData ? Object.keys(transferData.activityData).length : 0;
                            
                            previewContent.innerHTML = `
                                <div style="margin: 0.5rem 0;">📺 Anime: ${animeCount}</div>
                                <div style="margin: 0.5rem 0;">📋 Planer: ${plannerCount}</div>
                                <div style="margin: 0.5rem 0;">📅 Dni aktywności: ${activityDays}</div>
                                <div style="margin: 0.5rem 0; font-size: 0.8rem; color: var(--gray);">
                                    Wygenerowano: ${new Date(transferData.createdAt).toLocaleString('pl-PL')}
                                </div>
                            `;
                            
                            preview.style.display = 'block';
                        } else {
                            // Błędny kod
                            this.classList.add('error');
                            preview.style.display = 'none';
                            showNotification('Nieprawidłowy lub wygasły kod!', 'danger');
                        }
                    } catch (error) {
                        console.error('Błąd sprawdzania kodu:', error);
                        this.classList.add('error');
                        preview.style.display = 'none';
                        showNotification('Błąd podczas sprawdzania kodu!', 'danger');
                    }
                }
            });

            // Obsługa potwierdzenia importu
            document.getElementById('confirm-import-btn').addEventListener('click', async function() {
                const code = document.getElementById('import-code-input').value;
                const button = this;
                
                try {
                    // Zablokuj przycisk i pokaż loading
                    button.disabled = true;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Importowanie...';
                    
                    const transferData = await getDataFromCode(code);
                    
                    if (!transferData) {
                        showNotification('Kod jest nieprawidłowy lub wygasł!', 'danger');
                        return;
                    }
                    
                    if (confirm('Czy na pewno chcesz wgrać te dane? Obecne dane zostaną połączone z importowanymi.')) {
                        // Połącz dane
                        if (transferData.animeList && Array.isArray(transferData.animeList)) {
                            // Dodaj nowe anime, unikając duplikatów po tytule
                            transferData.animeList.forEach(importedAnime => {
                                const exists = animeList.find(existing => existing.title === importedAnime.title);
                                if (!exists) {
                                    // Nadaj nowe ID żeby uniknąć konfliktów
                                    importedAnime.id = Date.now() + Math.random();
                                    animeList.push(importedAnime);
                                }
                            });
                        }
                        
                        if (transferData.plannerList && Array.isArray(transferData.plannerList)) {
                            // Dodaj nowe pozycje planera
                            transferData.plannerList.forEach(importedItem => {
                                const exists = plannerList.find(existing => existing.title === importedItem.title);
                                if (!exists) {
                                    importedItem.id = Date.now() + Math.random();
                                    plannerList.push(importedItem);
                                }
                            });
                        }
                        
                        if (transferData.activityData && typeof transferData.activityData === 'object') {
                            // Połącz dane aktywności
                            Object.keys(transferData.activityData).forEach(date => {
                                if (!activityData[date]) {
                                    activityData[date] = 0;
                                }
                                activityData[date] += transferData.activityData[date];
                            });
                        }
                        
                        if (transferData.activityDetails && typeof transferData.activityDetails === 'object') {
                            // Połącz szczegóły aktywności
                            Object.keys(transferData.activityDetails).forEach(date => {
                                if (!activityDetails[date]) {
                                    activityDetails[date] = [];
                                }
                                activityDetails[date] = activityDetails[date].concat(transferData.activityDetails[date] || []);
                            });
                        }
                        
                        // Zapisz wszystko lokalnie
                        saveAnimeList();
                        savePlannerList();
                        saveActivityData();
                        
                        // Usuń kod
                        await removeCode(code);
                        
                        // Odśwież wyświetlanie
                        renderAnimeList();
                        renderPlannerList();
                        renderTierList();
                        updateProfileStats();
                        renderActivityCalendar();
                        
                        // Zamknij modal
                        document.getElementById('import-code-modal').classList.remove('show');
                        
                        showNotification('Dane zostały pomyślnie wgrane i kod został usunięty!', 'success');
                    }
                } catch (error) {
                    console.error('Błąd importowania:', error);
                    showNotification('Błąd podczas importowania danych: ' + error.message, 'danger');
                } finally {
                    // Przywróć przycisk
                    button.disabled = false;
                    button.innerHTML = '<i class="fas fa-check"></i> Potwierdź import danych';
                }
            });
            
            // Funkcja do śledzenia aktywnej sekcji
            function trackActiveSection() {
                const sections = document.querySelectorAll('.section');
                const navItems = document.querySelectorAll('.nav-item');
                
                let currentSection = '';
                
                sections.forEach(section => {
                    const sectionTop = section.offsetTop - 100;
                    const sectionBottom = sectionTop + section.offsetHeight;
                    
                    if (window.scrollY >= sectionTop && window.scrollY < sectionBottom) {
                        currentSection = section.id;
                    }
                });
                
                
                navItems.forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('href') === `#${currentSection}`) {
                        item.classList.add('active');
                    }
                });
            }

            // Nasłuchuj zdarzenia scroll
            window.addEventListener('scroll', trackActiveSection);

            // Wywołaj na początku, aby ustawić początkową sekcję
            trackActiveSection();
            
            // Funkcja do migracji istniejących anime - dodanie dat ukończenia
            function migrateExistingAnime() {
                let hasChanges = false;
                animeList.forEach(anime => {
                    // Usuń automatyczne ustawianie daty ukończenia - niech użytkownik sam decyduje
                    // if (anime.status === 'completed' && !anime.completedDate) {
                    //     anime.completedDate = anime.createdAt ? anime.createdAt.split('T')[0] : new Date().toISOString().split('T')[0];
                    //     hasChanges = true;
                    // }
                });
                
                if (hasChanges) {
                    saveAnimeList();
                }
            }
            
            // Obsługa zamykania modali
            document.getElementById('generate-code-close').addEventListener('click', function() {
                const modal = document.getElementById('generate-code-modal');
                const timer = modal.dataset.timer;
                if (timer) {
                    clearInterval(timer);
                }
                modal.classList.remove('show');
            });

            document.getElementById('import-code-close').addEventListener('click', function() {
                document.getElementById('import-code-modal').classList.remove('show');
            });

            // Zamykanie modali po kliknięciu poza nimi
            document.querySelectorAll('.transfer-modal').forEach(modal => {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        const timer = modal.dataset.timer;
                        if (timer) {
                            clearInterval(timer);
                        }
                        modal.classList.remove('show');
                    }
                });
            });
            
            // Initial render
            calculateAverage();
            migrateExistingAnime(); // Migruj istniejące anime
            renderAnimeList();
            renderPlannerList();
            renderTierList();
            updateProfileStats();
            
            // Wyczyść przeterminowane kody przy starcie (asynchronicznie)
            cleanExpiredCodes().catch(error => {
                console.error('Błąd podczas czyszczenia przeterminowanych kodów:', error);
            });

            // Test zabezpieczonego tokena GitHub przy starcie
            testGitHubToken().catch(error => {
                console.error('Błąd podczas testowania tokena GitHub:', error);
            });

            // === FUNKCJE POMOCNICZE DLA DEVELOPERÓW ===
            
            // Funkcja do kodowania tokena (dostępna w konsoli)
            window.encodeMyToken = function(token) {
                if (!token) {
                    console.log('Użycie: encodeMyToken("ghp_your_token_here")');
                    return;
                }
                // Użyj prostego kodowania Base64
                const encoded = btoa(token);
                console.log('Zakodowany token (Base64):', encoded);
                
                // Podziel na segmenty
                const segmentLength = Math.ceil(encoded.length / 4);
                const segments = [];
                for (let i = 0; i < 4; i++) {
                    const start = i * segmentLength;
                    const end = start + segmentLength;
                    segments.push(encoded.slice(start, end));
                }
                
                console.log('Segmenty do użycia w kodzie:', segments);
                console.log('Możesz użyć tych segmentów w API_CONFIG_SEGMENTS');
                return { encoded, segments };
            };
            
            // Informacja o dostępnych funkcjach
            console.log('🔧 Funkcje związane z tokenem GitHub dostępne w konsoli:');
            console.log('• testGitHubToken() - przetestuj obecny zabezpieczony token');
            console.log('• encodeMyToken("token") - zakoduj token do bezpiecznego przechowywania');
            console.log('• GITHUB_CONFIG.token - pokaż obecny token (automatycznie dekodowany)');
            
            // Udostępnij funkcje globalnie dla łatwego dostępu
            window.testGitHubToken = testGitHubToken;

            // Periodycznie sprawdzaj dostępność GitHub API (co 5 minut)
            setInterval(async () => {
                if (!githubApiWorking) {
                    try {
                        console.log('Testuję ponownie GitHub API...');
                        await testGitHubToken();
                    } catch (error) {
                        // GitHub wciąż niedostępny
                        console.log('GitHub API wciąż niedostępne');
                    }
                }
            }, 5 * 60 * 1000); // 5 minut

            const seasonCountInput = document.getElementById('season-count');
            const seasonsContainer = document.getElementById('seasons-container');
            const totalEpisodesInput = document.getElementById('total-episodes');

            function renderSeasonInputs(count, values=[], rewatchValues=[], episodeLengths=[], seasonCompletedDates=[]) {
                seasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const rewatchVal = rewatchValues[i] || 0;
                    const episodeLength = episodeLengths[i] || '';
                    const seasonDate = seasonCompletedDates && seasonCompletedDates[i] ? seasonCompletedDates[i] : '';
                    seasonsContainer.innerHTML += `
                        <div style='margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:8px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                            <div style='margin-left:20px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-redo"></i> Rewatch:</label>
                                <input type='number' class='season-rewatch' min='0' value='${rewatchVal}' style='width:60px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);font-size:0.8rem;'>
                                <span style='margin-left:4px;color:var(--gray);font-size:0.8rem;'>razy</span>
                            </div>
                            <div style='margin-top:8px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-calendar-check"></i> Data ukończenia sezonu:</label>
                                <input type='date' class='season-completed-date' value='${seasonDate}' style='margin-left:8px;'>
                            </div>
                        </div>
                    `;
                }
                seasonsContainer.style.display = count > 1 ? '' : 'none';
                // Ustaw readonly na totalEpisodes jeśli jest więcej niż 1 sezon
                totalEpisodesInput.readOnly = count > 1;
            }

            function updateTotalEpisodesFromSeasons() {
                const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                totalEpisodesInput.value = sum > 0 ? sum : '';
            }

            seasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderSeasonInputs(count);
                } else {
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
                updateTotalEpisodesFromSeasons();
            });

            seasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('season-episodes')) {
                    updateTotalEpisodesFromSeasons();
                }
            });

            // Przy edycji anime, jeśli są sezony, wypełnij pola
            function fillSeasonInputsIfNeeded(anime) {
                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    seasonCountInput.value = anime.seasons.length;
                    const rewatchValues = anime.seasonRewatches || [];
                    const episodeLengthValues = anime.seasonEpisodeLengths || [];
                    const seasonCompletedDates = anime.seasonCompletedDates || [];
                    // Trigger the input event to ensure the season inputs are rendered
                    renderSeasonInputs(anime.seasons.length, anime.seasons, rewatchValues, episodeLengthValues, seasonCompletedDates);
                    // After the inputs are rendered, set the values
                    setTimeout(() => {
                        const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                        const rewatchInputs = seasonsContainer.querySelectorAll('.season-rewatch');
                        const episodeLengthInputs = seasonsContainer.querySelectorAll('.season-episode-length');
                        const seasonDateInputs = seasonsContainer.querySelectorAll('.season-completed-date');
                        seasonInputs.forEach((input, index) => {
                            if (anime.seasons[index]) {
                                input.value = anime.seasons[index];
                            }
                        });
                        rewatchInputs.forEach((input, index) => {
                            if (rewatchValues[index] !== undefined) {
                                input.value = rewatchValues[index];
                            }
                        });
                        episodeLengthInputs.forEach((input, index) => {
                            if (episodeLengthValues[index] !== undefined) {
                                input.value = episodeLengthValues[index];
                            } else {
                                input.value = anime.episodeLength || 24; // fallback do głównej długości odcinka
                            }
                        });
                        seasonDateInputs.forEach((input, index) => {
                            if (seasonCompletedDates[index]) {
                                input.value = seasonCompletedDates[index];
                            }
                        });
                        updateTotalEpisodesFromSeasons();
                    }, 10);
                } else {
                    seasonCountInput.value = 1;
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
            }

            // Obsługa przycisku 'Pokaż sezony' (toggle)
            animeListContainer.addEventListener('click', function(e) {
                const row = e.target.closest('.odcinki-row');
                if (row) {
                    const id = row.dataset.id;
                    const el = document.getElementById('seasons-progress-' + id);
                    if (el) {
                        const isCurrentlyVisible = el.style.display !== 'none' && el.style.display !== '' ? true : el.style.display === '';
                        // Chowamy wszystkie inne
                        document.querySelectorAll("[id^='seasons-progress-']").forEach(function(other) {
                            if (other !== el) {
                                other.style.display = 'none';
                            }
                        });
                        // Jeśli kliknięty był widoczny, chowamy go; jeśli nie, pokazujemy
                        if (isCurrentlyVisible) {
                            el.style.display = 'none';
                        } else {
                            el.style.display = '';
                        }
                    }
                }
            });

            const sortSelect = document.getElementById('sort-select');
            const searchInput = document.getElementById('search-input');
            const collectionControls = document.getElementById('collection-controls');

            // Sortowanie select
            sortSelect.addEventListener('change', function() {
                currentSort = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Wyszukiwarka na bieżąco
            searchInput.addEventListener('input', function() {
                currentSearch = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Obsługa przycisków
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.onclick = function() {
                    collectionPage++;
                    renderAnimeList();
                };
            }
            const showAllBtn = document.getElementById('show-all-btn');
            if (showAllBtn) {
                showAllBtn.onclick = function() {
                    showAllCollection = true;
                    renderAnimeList();
                };
            }
            const showLessBtn = document.getElementById('show-less-btn');
            if (showLessBtn) {
                showLessBtn.onclick = function() {
                    showAllCollection = false;
                    collectionPage = 1;
                    renderAnimeList();
                };
            }

            // Obsługa kliknięcia na statystyki profilu
            function renderProfileAnimeList(type) {
                let list = [];
                let label = '';
                let sortBy = 'title';
                let sortDir = 'asc';
                // Zapamiętaj sortowanie dla tej listy
                if (!renderProfileAnimeList.sortState) renderProfileAnimeList.sortState = {};
                if (renderProfileAnimeList.sortState[type]) {
                    sortBy = renderProfileAnimeList.sortState[type].by;
                    sortDir = renderProfileAnimeList.sortState[type].dir;
                }
                if (type === 'completed') {
                    list = animeList.filter(a => a.status === 'completed');
                    label = 'Obejrzane';
                } else if (type === 'watching') {
                    list = animeList.filter(a => a.status === 'watching');
                    label = 'Oglądane';
                } else if (type === 'upcoming') {
                    list = plannerList;
                    label = 'Planowane';
                } else if (type === 'all') {
                    list = animeList;
                    label = 'Wszystkie';
                }
                // Sortowanie
                if (type === 'upcoming') {
                    // Dla planera sortuj po priorytecie
                    const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                    list = [...list].sort((a, b) => {
                        const cmp = priorityOrder[a.priority] - priorityOrder[b.priority];
                        return sortDir === 'asc' ? cmp : -cmp;
                    });
                } else {
                    // Dla głównej listy anime
                    if (sortBy === 'averageRating') {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.averageRating - b.averageRating : b.averageRating - a.averageRating);
                    } else if (sortBy === 'status') {
                        const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                        list = [...list].sort((a, b) => {
                            const cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            return sortDir === 'asc' ? cmp : -cmp;
                        });
                    } else {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.title.localeCompare(b.title) : b.title.localeCompare(a.title));
                    }
                }
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kategorii "${label}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label} anime</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                
                if (type === 'upcoming') {
                    // Dla planera
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-priority'>Priorytet ${sortBy==='priority'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;'>Notatki</th>
                        ${type === 'completed' ? '<th style="text-align:left;padding:8px 4px;">Data ukończenia</th>' : ''}
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        const priorityClass = `priority-${a.priority}`;
                        const notes = a.notes && a.notes.trim() ? a.notes : '-';
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'><span class='priority-badge ${priorityClass}' style='font-size:0.7rem;padding:2px 8px;'>${a.priority}</span></td>
                            <td style='padding:8px 4px;font-size:0.9rem;color:var(--gray);'>${notes}</td>
                            ${type === 'completed' ? `<td style='padding:8px 4px;color:var(--accent);font-size:0.9rem;'>${a.completedDate ? formatDate(a.completedDate) : 'Brak daty'}</td>` : ''}
                        </tr>`;
                    });
                } else {
                    // Dla głównej listy anime
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-avg-rating'>Średnia ocena ${sortBy==='averageRating'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        ${type === 'completed' ? '<th style="text-align:left;padding:8px 4px;">Data ukończenia</th>' : ''}
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                            <td style='padding:8px 4px;'>${a.averageRating}</td>
                            ${type === 'completed' ? `<td style='padding:8px 4px;color:var(--accent);font-size:0.9rem;'>${a.completedDate ? formatDate(a.completedDate) : 'Brak daty'}</td>` : ''}
                        </tr>`;
                    });
                }
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania po średniej ocenie
                document.getElementById('sort-avg-rating').onclick = function() {
                    if (sortBy === 'averageRating') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'averageRating';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-title').onclick = function() {
                    if (sortBy === 'title') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'title';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-status').onclick = function() {
                    if (sortBy === 'status') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'status';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                
                // Dla planera dodaj sortowanie po priorytecie
                if (type === 'upcoming') {
                    document.getElementById('sort-priority').onclick = function() {
                        if (sortBy === 'priority') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'priority';
                            sortDir = 'asc';
                        }
                        renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                        renderProfileAnimeList(type);
                    };
                }
            }
            
            // Render rating breakdown
            function renderRatingBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz statystyki ocen
                const ratedAnime = animeList.filter(a => a.averageRating > 0);
                
                if (ratedAnime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak ocenionych anime</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Oblicz średnie dla każdej kategorii
                const categories = ['graphics', 'music', 'characters', 'story', 'fun'];
                const categoryNames = {
                    'graphics': 'Grafika',
                    'music': 'Muzyka', 
                    'characters': 'Postacie',
                    'story': 'Fabuła',
                    'fun': 'Śmieszność'
                };
                
                const averages = {};
                categories.forEach(cat => {
                    const sum = ratedAnime.reduce((acc, anime) => acc + anime.ratings[cat], 0);
                    averages[cat] = (sum / ratedAnime.length).toFixed(2);
                });
                
                // Sortuj kategorie po średniej
                const sortedCategories = categories.sort((a, b) => parseFloat(averages[b]) - parseFloat(averages[a]));
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowe statystyki ocen</h3>`;
                html += `<div style='display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:1rem;margin-bottom:1rem;'>`;
                
                sortedCategories.forEach(cat => {
                    const avg = parseFloat(averages[cat]);
                    const percentage = (avg / 11) * 100;
                    const color = avg >= 8 ? 'var(--success)' : avg >= 6 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<div style='background:rgba(0,0,0,0.3);border-radius:8px;padding:1rem;text-align:center;'>
                        <div style='font-size:1.2rem;font-weight:600;color:${color};'>${avg}</div>
                        <div style='font-size:0.9rem;color:var(--gray);margin-bottom:0.5rem;'>${categoryNames[cat]}</div>
                        <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:6px;width:100%;'>
                            <div style='background:${color};height:100%;border-radius:4px;width:${percentage}%;'></div>
                        </div>
                    </div>`;
                });
                
                html += `</div>`;
                
                // Dodaj tabelę z najlepszymi anime w każdej kategorii
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Kategoria</th>
                    <th style='text-align:left;padding:8px 4px;'>Najlepsze anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Ocena</th>
                </tr></thead><tbody>`;
                
                categories.forEach(cat => {
                    const bestAnime = ratedAnime.reduce((best, current) => 
                        current.ratings[cat] > best.ratings[cat] ? current : best
                    );
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${categoryNames[cat]}</td>
                        <td style='padding:8px 4px;'>${bestAnime.title}</td>
                        <td style='padding:8px 4px;color:var(--primary);font-weight:600;'>${bestAnime.ratings[cat]}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render progress breakdown
            function renderProgressBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz postęp dla każdego anime
                const animeWithProgress = animeList.map(anime => {
                    const progress = anime.status === 'completed' ? 100 : 
                                   Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    return {
                        ...anime,
                        progress
                    };
                });
                
                if (animeWithProgress.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Sortuj po postępie (malejąco)
                animeWithProgress.sort((a, b) => b.progress - a.progress);
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Postęp oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Odcinki</th>
                    <th style='text-align:left;padding:8px 4px;'>Postęp</th>
                </tr></thead><tbody>`;
                
                animeWithProgress.forEach(anime => {
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : 
                                     anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const progressColor = anime.progress === 100 ? 'var(--success)' : 
                                        anime.progress >= 50 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${anime.watchedEpisodes}/${anime.totalEpisodes}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressColor};height:100%;border-radius:4px;width:${anime.progress}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${anime.progress}%</span>
                            </div>
                        </td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render time breakdown
            function renderTimeBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz czas dla każdego anime
                const animeWithTime = animeList.map(anime => {
                    let mainTime = 0;
                    let fullTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            fullTime += episodeCount * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        mainTime = watchedEpisodes * anime.episodeLength;
                        fullTime = anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    let rewatchTime = 0;
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        rewatchTime = anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    return {
                        ...anime,
                        mainTime,
                        rewatchTime,
                        totalTime,
                        fullTime
                    };
                }); // Pokaż wszystkie anime
                
                if (animeWithTime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                

                
                // Sortowanie dla czasu oglądania
                if (!renderTimeBreakdown.sortState) {
                    renderTimeBreakdown.sortState = { sortBy: 'totalTime', sortDir: 'desc' };
                }
                let sortBy = renderTimeBreakdown.sortState.sortBy;
                let sortDir = renderTimeBreakdown.sortState.sortDir;
                
                // Sortuj listę
                animeWithTime.sort((a, b) => {
                    let cmp = 0;
                    switch(sortBy) {
                        case 'title':
                            cmp = a.title.localeCompare(b.title);
                            break;
                        case 'status':
                            const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                            cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            break;
                        case 'totalTime':
                            cmp = a.totalTime - b.totalTime;
                            break;
                        case 'fullTime':
                            cmp = a.fullTime - b.fullTime;
                            break;
                        case 'progress':
                            const progressA = a.totalTime > 0 ? (a.totalTime / a.fullTime) * 100 : 0;
                            const progressB = b.totalTime > 0 ? (b.totalTime / b.fullTime) * 100 : 0;
                            cmp = progressA - progressB;
                            break;
                        case 'percentOfTotal':
                            cmp = a.percentOfTotal - b.percentOfTotal;
                            break;
                        default:
                            cmp = b.totalTime - a.totalTime;
                    }
                    return sortDir === 'asc' ? cmp : -cmp;
                });
                
                let totalWatchTime = animeWithTime.reduce((sum, anime) => sum + anime.totalTime, 0);
                // Dodaj percentOfTotal do każdego anime PRZED sortowaniem
                animeWithTime.forEach(anime => {
                    anime.percentOfTotal = totalWatchTime > 0 ? (anime.totalTime / totalWatchTime) * 100 : 0;
                });
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowy czas oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-total-time'>Czas oglądany ${sortBy==='totalTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-full-time'>Pełna długość ${sortBy==='fullTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-progress'>Postęp ${sortBy==='progress'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;'>% całości</th>
                </tr></thead><tbody>`;
                
                animeWithTime.forEach(anime => {
                    const progressPercent = anime.totalTime > 0 ? Math.round((anime.totalTime / anime.fullTime) * 100) : 0;
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const rewatchInfo = anime.rewatchTime > 0 ? ` <span style='color:var(--primary);font-size:0.8em;'>(+${formatTime(anime.rewatchTime)} rewatch)</span>` : '';
                    
                    // Dla anime z czasem 0, pokaż specjalny tekst
                    const timeDisplay = anime.totalTime > 0 ? `${formatTime(anime.totalTime)}${rewatchInfo}` : '0h';
                    const progressBarColor = anime.totalTime > 0 ? 'linear-gradient(90deg, var(--primary), var(--accent))' : 'rgba(255,255,255,0.2)';
                    const percentOfTotal = totalWatchTime > 0 ? ((anime.totalTime / totalWatchTime) * 100).toFixed(1) : '0.0';
                    anime.percentOfTotal = parseFloat(percentOfTotal); // for sorting
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${timeDisplay}</td>
                        <td style='padding:8px 4px;'>${formatTime(anime.fullTime)}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressBarColor};height:100%;border-radius:4px;width:${progressPercent}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${progressPercent}%</span>
                            </div>
                        </td>
                        <td style='padding:8px 4px;'>${anime.percentOfTotal.toFixed(1)}%</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania
                function assignTimeBreakdownSortHandlers() {
                    document.getElementById('sort-title').onclick = function() {
                        if (sortBy === 'title') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'title';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-status').onclick = function() {
                        if (sortBy === 'status') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'status';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-total-time').onclick = function() {
                        if (sortBy === 'totalTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'totalTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-full-time').onclick = function() {
                        if (sortBy === 'fullTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'fullTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-progress').onclick = function() {
                        if (sortBy === 'progress') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'progress';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                }
                assignTimeBreakdownSortHandlers();
            }
            
            // Podpinam kliknięcia na statystyki
            setTimeout(() => {
                document.getElementById('total-completed').parentElement.onclick = () => renderProfileAnimeList('completed');
                document.getElementById('total-upcoming').parentElement.onclick = () => renderProfileAnimeList('upcoming');
                document.getElementById('total-watching').parentElement.onclick = () => renderProfileAnimeList('watching');
                document.getElementById('total-all').parentElement.onclick = () => renderProfileAnimeList('all');

            }, 0);

            // Po wygenerowaniu kart anime w renderAnimeList:
            animeListContainer.querySelectorAll('.odcinki-row').forEach(row => {
                const clickable = row.querySelector('.rating-value');
                if (clickable) {
                    clickable.style.cursor = 'pointer';
                    clickable.onclick = function(e) {
                        e.stopPropagation();
                        const id = row.dataset.id;
                        const el = document.getElementById('seasons-progress-' + id);
                        if (el) {
                            el.style.display = (el.style.display === 'block') ? 'none' : 'block';
                        }
                    };
                }
            });
            
            // Planner functionality
            const addToPlannerBtn = document.getElementById('add-to-planner');
            const plannerTitleInput = document.getElementById('planner-title');
            const plannerPrioritySelect = document.getElementById('planner-priority');
            const plannerNotesTextarea = document.getElementById('planner-notes');
            const plannerTagsInput = document.getElementById('planner-tags');
            
            addToPlannerBtn.addEventListener('click', function() {
                const title = plannerTitleInput.value.trim();
                const priority = plannerPrioritySelect.value;
                const notes = plannerNotesTextarea.value.trim();
                const tagsRaw = plannerTagsInput.value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                const seasonCount = parseInt(plannerSeasonCountInput.value);
                let seasons = [];
                let seasonEpisodeLengths = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episodes');
                    const episodeLengthInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episode-length');
                    seasonInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v);
                    });
                }
                const totalEpisodes = parseInt(plannerTotalEpisodesInput.value) || 12;
                if (!title) {
                    showNotification('Proszę wprowadzić tytuł anime!', 'danger');
                    return;
                }
                // Check if editing
                const editId = this.dataset.editId;
                if (editId) {
                    // Update existing item
                    const index = plannerList.findIndex(item => item.id === parseInt(editId));
                    if (index !== -1) {
                        plannerList[index] = {
                            ...plannerList[index],
                            title,
                            priority,
                            notes,
                            seasonCount,
                            seasons: seasons.length > 1 ? seasons : undefined,
                            seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                            totalEpisodes,
                            tags
                        };
                        savePlannerList();
                        renderPlannerList();
                        showNotification('Anime zostało zaktualizowane w planerze!', 'success');
                    }
                    // Reset form
                    this.innerHTML = '<i class="fas fa-plus"></i> Dodaj do planera';
                    delete this.dataset.editId;
                } else {
                    // Add new item
                    const plannerItem = {
                        id: Date.now(),
                        title,
                        priority,
                        notes,
                        createdAt: new Date().toISOString(),
                        seasonCount,
                        seasons: seasons.length > 1 ? seasons : undefined,
                        seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                        totalEpisodes,
                        tags
                    };
                    plannerList.push(plannerItem);
                    savePlannerList();
                    renderPlannerList();
                    showNotification('Anime zostało dodane do planera!', 'success');
                }
                // Clear form
                plannerTitleInput.value = '';
                plannerPrioritySelect.value = 'średni';
                plannerNotesTextarea.value = '';
                plannerTagsInput.value = '';
                plannerSeasonCountInput.value = 1;
                plannerSeasonsContainer.innerHTML = '';
                plannerSeasonsContainer.style.display = 'none';
                plannerTotalEpisodesInput.value = 12;
            });
            
            // Initial render of planner
            renderPlannerList();

            const plannerSeasonCountInput = document.getElementById('planner-season-count');
            const plannerSeasonsContainer = document.getElementById('planner-seasons-container');
            const plannerTotalEpisodesInput = document.getElementById('planner-total-episodes');

            function renderPlannerSeasonInputs(count, values=[], episodeLengths=[]) {
                plannerSeasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const episodeLength = episodeLengths[i] || '';
                    plannerSeasonsContainer.innerHTML += `
                        <div style='margin-bottom:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:4px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='planner-season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='planner-season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                        </div>
                    `;
                }
                plannerSeasonsContainer.style.display = count > 1 ? '' : 'none';
                plannerTotalEpisodesInput.readOnly = count > 1;
            }

            plannerSeasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderPlannerSeasonInputs(count);
                } else {
                    plannerSeasonsContainer.innerHTML = '';
                    plannerSeasonsContainer.style.display = 'none';
                    plannerTotalEpisodesInput.readOnly = false;
                }
                updatePlannerTotalEpisodesFromSeasons();
            });

            plannerSeasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('planner-season-episodes')) {
                    updatePlannerTotalEpisodesFromSeasons();
                }
            });

            function updatePlannerTotalEpisodesFromSeasons() {
                const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                plannerTotalEpisodesInput.value = sum > 0 ? sum : '';
            }

            // Funkcje kalendarza aktywności
            function saveActivityData() {
                localStorage.setItem('activityData', JSON.stringify(activityData));
                localStorage.setItem('activityDetails', JSON.stringify(activityDetails));
            }
            
            function getActivityLevel(episodes) {
                if (episodes === 0) return 0;
                if (episodes <= 2) return 1;
                if (episodes <= 4) return 2;
                if (episodes <= 6) return 3;
                if (episodes <= 8) return 4;
                return 5;
            }
            
            // Zmienne dla widoku miesięcznego
            let currentMonth = new Date().getMonth();
            let isMobileView = window.innerWidth <= 768;
            let selectedMonth = null; // null = widok lat, number = widok konkretnego miesiąca
            
            function renderActivityCalendar() {
                const container = document.getElementById('calendar-container');
                if (!container) return;
                
                // Sprawdź czy to mobile
                isMobileView = window.innerWidth <= 768;
                
                if (isMobileView) {
                    renderMobileCalendar(container);
                } else {
                    if (selectedMonth !== null) {
                        renderDesktopMonthView(container);
                    } else {
                        renderDesktopCalendar(container);
                    }
                }
            }
            
            function renderDesktopMonthView(container) {
                const months = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                const days = ['Nie', 'Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-month-title clickable" id="month-title-clickable" title="Kliknij aby wrócić do lat">${months[selectedMonth]} ${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-month">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-month">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <div class="desktop-month-grid">
                        <div class="desktop-month-labels">
                            ${days.map(day => `<div class="desktop-month-label">${day}</div>`).join('')}
                        </div>
                        <div class="desktop-month-days" id="desktop-month-days">
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-month').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth--;
                        if (selectedMonth < 0) {
                            selectedMonth = 11;
                            currentYear--;
                        }
                        renderActivityCalendar();
                    });
                });
                
                document.getElementById('next-month').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth++;
                        if (selectedMonth > 11) {
                            selectedMonth = 0;
                            currentYear++;
                        }
                        renderActivityCalendar();
                    });
                });
                
                // Dodaj event listener dla kliknięcia na tytuł miesiąca
                document.getElementById('month-title-clickable').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth = null;
                        renderActivityCalendar();
                    });
                });
                
                // Renderuj dni miesięcznego widoku
                renderDesktopMonthDays();
                
                // Dodaj obsługę swipe
                addSwipeSupport(container);
            }
            
            function renderDesktopCalendar(container) {
                const months = ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'];
                const days = ['Nie', 'Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-year clickable" id="year-clickable" title="Kliknij aby zobaczyć aktualny miesiąc">${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-year">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-year">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>

                    </div>
                    <div class="calendar-grid">
                        <div class="calendar-labels">
                            ${days.map(day => `<div>${day}</div>`).join('')}
                        </div>
                        <div>
                            <div class="calendar-months">
                                ${months.map(month => `<div class="calendar-month">${month}</div>`).join('')}
                            </div>
                            <div class="calendar-days" id="calendar-days">
                            </div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-year').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        currentYear--;
                        renderActivityCalendar();
                    });
                });
                
                document.getElementById('next-year').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        currentYear++;
                        renderActivityCalendar();
                    });
                });
                

                
                // Dodaj event listener dla kliknięcia na rok
                document.getElementById('year-clickable').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth = new Date().getMonth(); // Aktualny miesiąc
                        renderActivityCalendar();
                    });
                });
                

                
                // Renderuj dni
                renderCalendarDays();
                
                // Dodaj obsługę swipe dla mobile
                addSwipeSupport(container);
            }
            
            function renderMobileCalendar(container) {
                const months = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                const days = ['Nie', 'Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-month-title">${months[currentMonth]} ${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-month">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-month">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mobile-calendar-grid">
                        <div class="mobile-calendar-labels">
                            ${days.map(day => `<div class="mobile-calendar-label">${day}</div>`).join('')}
                        </div>
                        <div class="mobile-calendar-days" id="mobile-calendar-days">
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-month').addEventListener('click', () => {
                    currentMonth--;
                    if (currentMonth < 0) {
                        currentMonth = 11;
                        currentYear--;
                    }
                    renderActivityCalendar();
                });
                
                document.getElementById('next-month').addEventListener('click', () => {
                    currentMonth++;
                    if (currentMonth > 11) {
                        currentMonth = 0;
                        currentYear++;
                    }
                    renderActivityCalendar();
                });
                
                // Renderuj dni mobilnego kalendarza
                renderMobileCalendarDays();
                
                // Dodaj obsługę swipe dla mobile
                addSwipeSupport(container);
            }
            
            function renderMobileCalendarDays() {
                const daysContainer = document.getElementById('mobile-calendar-days');
                if (!daysContainer) return;
                
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
                const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
                const startDayOfWeek = firstDayOfMonth.getDay(); // 0 = niedziela, 1 = poniedziałek, itd.
                
                // Dostosuj do układu poniedziałek-niedziela
                const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
                
                let html = '';
                
                // Dodaj puste dni z poprzedniego miesiąca
                for (let i = 0; i < adjustedStartDay; i++) {
                    html += '<div class="mobile-calendar-day empty other-month"></div>';
                }
                
                // Dodaj dni bieżącego miesiąca
                for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
                    const date = new Date(currentYear, currentMonth, day);
                    const dateStr = date.toISOString().split('T')[0];
                    const episodes = activityData[dateStr] || 0;
                    const level = getActivityLevel(episodes);
                    
                    const tooltip = episodes > 0 ? 
                        `${dateStr}: ${episodes} odcinków` : 
                        `${dateStr}: Brak aktywności`;
                    
                    html += `
                        <div class="mobile-calendar-day level-${level}" data-date="${dateStr}" data-episodes="${episodes}">
                            ${day}
                            <div class="mobile-calendar-tooltip">${tooltip}</div>
                        </div>
                    `;
                }
                
                // Dodaj puste dni z następnego miesiąca, żeby wypełnić grid
                const totalDays = adjustedStartDay + lastDayOfMonth.getDate();
                const remainingDays = 42 - totalDays; // 6 tygodni * 7 dni = 42
                
                for (let i = 0; i < remainingDays; i++) {
                    html += '<div class="mobile-calendar-day empty other-month"></div>';
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.mobile-calendar-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
            }
            
            function animateCalendarTransition(callback) {
                const daysContainer = document.getElementById('calendar-days');
                if (!daysContainer) {
                    callback();
                    return;
                }
                
                // Animacja fade out
                daysContainer.classList.add('fade-out');
                
                setTimeout(() => {
                    callback();
                    
                    // Animacja fade in
                    setTimeout(() => {
                        daysContainer.classList.remove('fade-out');
                        daysContainer.classList.add('fade-in');
                        
                        setTimeout(() => {
                            daysContainer.classList.remove('fade-in');
                        }, 400);
                    }, 50);
                }, 200);
            }
            
            function renderDesktopMonthDays() {
                const daysContainer = document.getElementById('desktop-month-days');
                if (!daysContainer) return;
                
                const firstDayOfMonth = new Date(currentYear, selectedMonth, 1);
                const lastDayOfMonth = new Date(currentYear, selectedMonth + 1, 0);
                const startDayOfWeek = firstDayOfMonth.getDay(); // 0 = niedziela, 1 = poniedziałek, itd.
                
                // Dostosuj do układu poniedziałek-niedziela
                const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
                
                let html = '';
                
                // Dodaj puste dni z poprzedniego miesiąca
                for (let i = 0; i < adjustedStartDay; i++) {
                    html += '<div class="desktop-month-day empty other-month"></div>';
                }
                
                // Dodaj dni bieżącego miesiąca
                for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
                    const date = new Date(currentYear, selectedMonth, day);
                    const dateStr = date.toISOString().split('T')[0];
                    const episodes = activityData[dateStr] || 0;
                    const level = getActivityLevel(episodes);
                    
                    const tooltip = episodes > 0 ? 
                        `${dateStr}: ${episodes} odcinków` : 
                        `${dateStr}: Brak aktywności`;
                    
                    html += `
                        <div class="desktop-month-day level-${level}" data-date="${dateStr}" data-episodes="${episodes}">
                            ${day}
                            <div class="desktop-month-tooltip">${tooltip}</div>
                        </div>
                    `;
                }
                
                // Dodaj puste dni z następnego miesiąca, żeby wypełnić grid
                const totalDays = adjustedStartDay + lastDayOfMonth.getDate();
                const remainingDays = 42 - totalDays; // 6 tygodni * 7 dni = 42
                
                for (let i = 0; i < remainingDays; i++) {
                    html += '<div class="desktop-month-day empty other-month"></div>';
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.desktop-month-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
            }
            

            
            function renderCalendarDays() {
                const daysContainer = document.getElementById('calendar-days');
                if (!daysContainer) return;
                
                renderYearlyView(daysContainer);
            }
            
            function renderYearlyView(daysContainer) {
                const startDate = new Date(currentYear, 0, 1);
                const endDate = new Date(currentYear, 11, 31);
                
                // Znajdź pierwszy poniedziałek roku
                const firstMonday = new Date(startDate);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }
                
                // Oblicz liczbę tygodni potrzebnych dla całego roku
                const totalDays = Math.ceil((endDate - firstMonday) / (1000 * 60 * 60 * 24)) + 1;
                const weeks = Math.ceil(totalDays / 7);
                
                // Przygotuj tablicę 2D: [dzień_tygodnia][tydzień]
                const calendarGrid = Array(7).fill().map(() => Array(weeks).fill(null));
                
                // Wypełnij grid datami
                for (let week = 0; week < weeks; week++) {
                    for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
                        const currentDate = new Date(firstMonday);
                        currentDate.setDate(firstMonday.getDate() + (week * 7) + dayOfWeek);
                        
                        // dayOfWeek = 0 to poniedziałek (firstMonday), dayOfWeek = 1 to wtorek, itd.
                        // Chcemy: 0=poniedziałek, 1=wtorek, 2=środa, 3=czwartek, 4=piątek, 5=sobota, 6=niedziela
                        const mappedDayOfWeek = dayOfWeek;
                        
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const episodes = activityData[dateStr] || 0;
                        const level = getActivityLevel(episodes);
                        const isCurrentYear = currentDate.getFullYear() === currentYear;
                        
                        calendarGrid[mappedDayOfWeek][week] = {
                            date: dateStr,
                            episodes: episodes,
                            level: level,
                            isCurrentYear: isCurrentYear
                        };
                    }
                }
                
                // Renderuj HTML - każdy rząd to jeden dzień tygodnia
                let html = '';
                // Renderuj każdy tydzień osobno, żeby poniedziałek był pierwszy
                for (let week = 0; week < weeks; week++) {
                    for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
                        const day = calendarGrid[dayOfWeek][week];
                        
                        if (day.isCurrentYear) {
                            const tooltip = day.episodes > 0 ? 
                                `${day.date}: ${day.episodes} odcinków` : 
                                `${day.date}: Brak aktywności`;
                            
                            html += `
                                <div class="calendar-day level-${day.level}" data-date="${day.date}" data-episodes="${day.episodes}" style="grid-row: ${dayOfWeek + 1}; grid-column: ${week + 1};">
                                    <div class="calendar-tooltip">${tooltip}</div>
                                </div>
                            `;
                        } else {
                            html += `<div class="calendar-day empty" style="grid-row: ${dayOfWeek + 1}; grid-column: ${week + 1};"></div>`;
                        }
                    }
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.calendar-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
                
                // Dodaj event listeners dla hover na etykiety dni
                const dayLabels = document.querySelectorAll('.calendar-labels > div');
                dayLabels.forEach((label, index) => {
                    label.addEventListener('mouseenter', () => {
                        // Przyciemnij wszystkie kwadraty
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.add('dimmed');
                        });
                        
                        // Podświetl kwadraty dla tego dnia tygodnia
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            const dayElement = day;
                            const computedStyle = window.getComputedStyle(dayElement);
                            const gridRow = computedStyle.gridRow;
                            if (gridRow === `${index + 1}`) {
                                dayElement.classList.remove('dimmed');
                            }
                        });
                    });
                    
                    label.addEventListener('mouseleave', () => {
                        // Usuń przyciemnienie ze wszystkich kwadratów
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.remove('dimmed');
                        });
                    });
                });
                
                // Dodaj event listeners dla hover na etykiety miesięcy
                const monthLabels = document.querySelectorAll('.calendar-months > div');
                monthLabels.forEach((label, index) => {
                    label.addEventListener('mouseenter', () => {
                        // Przyciemnij wszystkie kwadraty
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.add('dimmed');
                        });
                        
                        // Podświetl kwadraty dla tego miesiąca
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            const dayElement = day;
                            if (dayElement.dataset.date) {
                                const date = new Date(dayElement.dataset.date);
                                const month = date.getMonth(); // 0-11 (styczeń=0, luty=1, itd.)
                                
                                if (month === index) {
                                    dayElement.classList.remove('dimmed');
                                }
                            }
                        });
                    });
                    
                    label.addEventListener('mouseleave', () => {
                        // Usuń przyciemnienie ze wszystkich kwadratów
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.remove('dimmed');
                        });
                    });
                    
                    // Dodaj event listener dla kliknięcia na miesiąc
                    label.addEventListener('click', () => {
                        showMonthDetails(index);
                    });
                });
            }
            
            function showMonthDetails(monthIndex) {
                const modal = document.getElementById('day-summary-modal');
                const dateEl = document.getElementById('day-summary-date');
                const statsEl = document.getElementById('day-summary-stats');
                const animeListEl = document.getElementById('day-summary-anime-list');
                
                // Nazwy miesięcy
                const monthNames = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                                   'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                
                // Formatuj nagłówek
                dateEl.textContent = `${monthNames[monthIndex]} ${currentYear}`;
                
                // Zbierz dane dla całego miesiąca
                let totalEpisodes = 0;
                let totalMinutes = 0;
                let monthDetails = [];
                let animeStats = {};
                let tagStats = {};
                
                // Przejdź przez wszystkie dni miesiąca
                const startDate = new Date(currentYear, monthIndex, 1);
                const endDate = new Date(currentYear, monthIndex + 1, 0); // Ostatni dzień miesiąca
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    const episodes = activityData[dateStr] || 0;
                    const details = activityDetails[dateStr] || [];
                    
                    if (episodes > 0) {
                        totalEpisodes += episodes;
                        monthDetails.push(...details);
                        
                        // Oblicz czas oglądania dla tego dnia
                        details.forEach(detail => {
                            const anime = animeList.find(a => a.id === detail.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            totalMinutes += detail.episodes * episodeLength;
                            
                            // Zbierz statystyki anime
                            const title = detail.title;
                            if (!animeStats[title]) {
                                animeStats[title] = {
                                    title: title,
                                    episodes: 0,
                                    animeId: detail.animeId
                                };
                            }
                            animeStats[title].episodes += detail.episodes;
                            
                            // Zbierz statystyki tagów
                            if (anime && anime.tags && Array.isArray(anime.tags)) {
                                anime.tags.forEach(tag => {
                                    if (!tagStats[tag]) {
                                        tagStats[tag] = {
                                            name: tag,
                                            episodes: 0,
                                            animeCount: 0,
                                            animeIds: new Set()
                                        };
                                    }
                                    tagStats[tag].episodes += detail.episodes;
                                    tagStats[tag].animeIds.add(detail.animeId);
                                    tagStats[tag].animeCount = tagStats[tag].animeIds.size;
                                });
                            }
                        });
                    }
                }
                
                if (totalEpisodes > 0) {
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    const timeString = hours > 0 ? 
                        `${hours}h ${minutes > 0 ? minutes + 'm' : ''}` : 
                        `${minutes}m`;
                    
                    // Statystyki miesiąca
                    const uniqueMonthAnime = new Set(monthDetails.map(d => d.animeId)).size;
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${totalEpisodes}</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${timeString}</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${uniqueMonthAnime}</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                    `;
                    
                    // Lista anime z podsumowaniem
                    if (Object.keys(animeStats).length > 0) {
                        let animeHtml = '';
                        Object.values(animeStats).forEach(group => {
                            const anime = animeList.find(a => a.id === group.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            const animeTime = group.episodes * episodeLength;
                            const animeHours = Math.floor(animeTime / 60);
                            const animeMinutes = animeTime % 60;
                            const animeTimeString = animeHours > 0 ? 
                                `${animeHours}h ${animeMinutes > 0 ? animeMinutes + 'm' : ''}` : 
                                `${animeMinutes}m`;
                            
                            animeHtml += `
                                <div class="day-summary-anime-item">
                                    <div class="day-summary-anime-title">${group.title}</div>
                                    <div class="day-summary-anime-details">
                                        <span class="day-summary-anime-episodes">
                                            <i class="fas fa-play-circle"></i> ${group.episodes} odcinków
                                        </span>
                                        <span class="day-summary-anime-time">
                                            <i class="fas fa-clock"></i> ${animeTimeString}
                                        </span>
                                    </div>
                                </div>
                            `;
                        });
                        animeListEl.innerHTML = animeHtml;
                    } else {
                        animeListEl.innerHTML = `
                            <div class="day-summary-empty">
                                <i class="fas fa-info-circle"></i>
                                Brak szczegółów oglądanych anime
                            </div>
                        `;
                    }
                } else {
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0h</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Sesje oglądania</div>
                        </div>
                    `;
                    
                    animeListEl.innerHTML = `
                        <div class="day-summary-empty">
                            <i class="fas fa-calendar-times"></i>
                            Brak aktywności w tym miesiącu
                        </div>
                    `;
                }
                
                // Dodaj sekcję z tagami jeśli są jakieś
                if (Object.keys(tagStats).length > 0) {
                    // Sortuj tagi według liczby odcinków (malejąco)
                    const sortedTags = Object.values(tagStats).sort((a, b) => b.episodes - a.episodes);
                    
                    let tagsHtml = `
                        <div class="day-summary-section">
                            <h4 style="margin: 1.5rem 0 1rem 0; color: var(--lighter); font-size: 1.1rem;">
                                <i class="fas fa-tags"></i> Najpopularniejsze tagi
                            </h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                    `;
                    
                    sortedTags.forEach(tag => {
                        const tagTime = tag.episodes * 24; // Przybliżony czas na odcinek
                        const tagHours = Math.floor(tagTime / 60);
                        const tagMinutes = tagTime % 60;
                        const tagTimeString = tagHours > 0 ? 
                            `${tagHours}h ${tagMinutes > 0 ? tagMinutes + 'm' : ''}` : 
                            `${tagMinutes}m`;
                        
                        tagsHtml += `
                            <div class="day-summary-tag-item">
                                <span class="anime-tag">${tag.name}</span>
                                <div class="day-summary-tag-stats">
                                    <span class="day-summary-tag-episodes">
                                        <i class="fas fa-play-circle"></i> ${tag.episodes} odc.
                                    </span>
                                    <span class="day-summary-tag-anime">
                                        <i class="fas fa-film"></i> ${tag.animeCount} anime
                                    </span>
                                    <span class="day-summary-tag-time">
                                        <i class="fas fa-clock"></i> ~${tagTimeString}
                                    </span>
                                </div>
                            </div>
                        `;
                    });
                    
                    tagsHtml += `
                            </div>
                        </div>
                    `;
                    
                    animeListEl.innerHTML += tagsHtml;
                }
                
                modal.classList.add('show');
            }
            
            function showDayDetails(date, episodes) {
                const modal = document.getElementById('day-summary-modal');
                const dateEl = document.getElementById('day-summary-date');
                const statsEl = document.getElementById('day-summary-stats');
                const animeListEl = document.getElementById('day-summary-anime-list');
                
                // Formatuj datę
                const dateObj = new Date(date);
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                dateEl.textContent = dateObj.toLocaleDateString('pl-PL', options);
                
                if (episodes > 0) {
                    const level = getActivityLevel(episodes);
                    const details = activityDetails[date] || [];
                    
                    // Oblicz rzeczywisty czas oglądania na podstawie szczegółów
                    let totalMinutes = 0;
                    details.forEach(detail => {
                        const anime = animeList.find(a => a.id === detail.animeId);
                        const episodeLength = anime ? anime.episodeLength : 24;
                        totalMinutes += detail.episodes * episodeLength;
                    });
                    
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    const timeString = hours > 0 ? 
                        `${hours}h ${minutes > 0 ? minutes + 'm' : ''}` : 
                        `${minutes}m`;
                    
                    // Statystyki
                    const uniqueAnimeCount = new Set(details.map(d => d.animeId)).size;
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${episodes}</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${timeString}</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${uniqueAnimeCount}</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                    `;
                    
                    // Lista anime - grupuj według tytułu
                    if (details.length > 0) {
                        // Grupuj odcinki według tytułu anime
                        const groupedAnime = {};
                        details.forEach(detail => {
                            const title = detail.title;
                            if (!groupedAnime[title]) {
                                groupedAnime[title] = {
                                    title: title,
                                    episodes: 0,
                                    animeId: detail.animeId
                                };
                            }
                            groupedAnime[title].episodes += detail.episodes;
                        });
                        
                        let animeHtml = '';
                        Object.values(groupedAnime).forEach(group => {
                            const anime = animeList.find(a => a.id === group.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            const animeTime = group.episodes * episodeLength;
                            const animeHours = Math.floor(animeTime / 60);
                            const animeMinutes = animeTime % 60;
                            const animeTimeString = animeHours > 0 ? 
                                `${animeHours}h ${animeMinutes > 0 ? animeMinutes + 'm' : ''}` : 
                                `${animeMinutes}m`;
                            
                            animeHtml += `
                                <div class="day-summary-anime-item">
                                    <div class="day-summary-anime-title">${group.title}</div>
                                    <div class="day-summary-anime-details">
                                        <span class="day-summary-anime-episodes">
                                            <i class="fas fa-play-circle"></i> ${group.episodes} odcinków
                                        </span>
                                        <span class="day-summary-anime-time">
                                            <i class="fas fa-clock"></i> ${animeTimeString}
                                        </span>
                                    </div>
                                </div>
                            `;
                        });
                        animeListEl.innerHTML = animeHtml;
                    } else {
                        animeListEl.innerHTML = `
                            <div class="day-summary-empty">
                                <i class="fas fa-info-circle"></i>
                                Brak szczegółów oglądanych anime
                            </div>
                        `;
                    }
                } else {
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0h</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>

                    `;
                    
                    animeListEl.innerHTML = `
                        <div class="day-summary-empty">
                            <i class="fas fa-calendar-times"></i>
                            Brak aktywności tego dnia
                        </div>
                    `;
                }
                
                modal.classList.add('show');
            }
            
            function getAnimeForDate(date) {
                // Zwraca dane aktywności dla danego dnia
                const episodes = activityData[date] || 0;
                if (episodes > 0) {
                    return [{
                        title: 'Aktywność oglądania',
                        episodes: episodes
                    }];
                }
                return [];
            }
            
            function addActivity(date, episodes, animeId = null) {
                console.log('addActivity:', { date, episodes, animeId }); // Debug
                
                if (!activityData[date]) {
                    activityData[date] = 0;
                    activityDetails[date] = [];
                }
                activityData[date] += episodes;
                
                // Dodaj szczegóły aktywności
                if (animeId) {
                    const anime = animeList.find(a => a.id === animeId);
                    if (anime) {
                        activityDetails[date].push({
                            animeId: animeId,
                            title: anime.title,
                            episodes: episodes
                        });
                        
                        // Aktualizuj datę ostatniego oglądania tylko jeśli to nie jest dodawanie nowego anime
                        if (anime.lastWatchedDate !== date) {
                            anime.lastWatchedDate = date;
                            saveAnimeList();
                        }
                    }
                } else {
                    activityDetails[date].push({
                        animeId: null,
                        title: 'Dodane ręcznie',
                        episodes: episodes
                    });
                }
                
                saveActivityData();
                renderActivityCalendar();
            }
            
            // Modal do dodawania odcinków
            let currentAnimeId = null;
            
            function showEpisodeModal(animeId) {
                currentAnimeId = animeId;
                const modal = document.getElementById('episode-modal');
                const anime = animeList.find(a => a.id === animeId);
                
                if (anime) {
                    document.getElementById('episode-modal-title').textContent = `Dodaj odcinki - ${anime.title}`;
                }
                
                // Ustaw dzisiejszą datę w lokalnej strefie czasowej
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const todayString = `${year}-${month}-${day}`;
                document.getElementById('episode-date').value = todayString;
                document.getElementById('episode-count').textContent = '1';
                document.getElementById('activity-only').checked = false;
                
                modal.classList.add('show');
            }
            
            function hideEpisodeModal() {
                document.getElementById('episode-modal').classList.remove('show');
                currentAnimeId = null;
            }
            
            // Event listeners dla modala
            document.getElementById('episode-modal-close').addEventListener('click', hideEpisodeModal);
            document.getElementById('day-summary-close').addEventListener('click', () => {
                document.getElementById('day-summary-modal').classList.remove('show');
            });

            document.getElementById('episode-decrease').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                if (count > 1) {
                    countEl.textContent = count - 1;
                }
            });
            
            document.getElementById('episode-increase').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                countEl.textContent = count + 1;
            });
            
            document.getElementById('add-episode-btn').addEventListener('click', () => {
                const count = parseInt(document.getElementById('episode-count').textContent);
                const date = document.getElementById('episode-date').value;
                const activityOnly = document.getElementById('activity-only').checked;
                
                console.log('Dodawanie odcinków:', { count, date, currentAnimeId, activityOnly }); // Debug
                
                if (!date) {
                    alert('Proszę wybrać datę');
                    return;
                }
                
                addActivity(date, count, currentAnimeId);
                
                // Zaktualizuj anime tylko jeśli NIE jest zaznaczony "tylko aktywność"
                if (currentAnimeId && !activityOnly) {
                    const anime = animeList.find(a => a.id === currentAnimeId);
                    if (anime) {
                        console.log('Przed dodaniem odcinków:', { 
                            title: anime.title, 
                            watchedEpisodes: anime.watchedEpisodes, 
                            totalEpisodes: anime.totalEpisodes,
                            status: anime.status 
                        });
                        
                        // Sprawdź czy anime było już ukończone PRZED dodaniem nowych odcinków
                        const wasCompletedBefore = checkAnimeCompletion(anime);
                        console.log('Czy było ukończone przed:', wasCompletedBefore);
                        
                        if (wasCompletedBefore) {
                            // To jest rewatch - dodaj do rewatchCount
                            if (!anime.rewatchCount) {
                                anime.rewatchCount = 0;
                            }
                            anime.rewatchCount += count;
                            console.log('Dodano do rewatch:', count);
                        } else {
                            // Normalne dodawanie odcinków
                            anime.watchedEpisodes += count;
                            if (anime.watchedEpisodes > anime.totalEpisodes) {
                                anime.watchedEpisodes = anime.totalEpisodes;
                            }
                            console.log('Po dodaniu odcinków:', { 
                                watchedEpisodes: anime.watchedEpisodes, 
                                totalEpisodes: anime.totalEpisodes 
                            });
                            
                            // Sprawdź czy anime zostało ukończone PO dodaniu nowych odcinków
                            const isNowCompleted = checkAnimeCompletion(anime);
                            console.log('Czy jest ukończone po:', isNowCompleted);
                            if (isNowCompleted && anime.status === 'watching') {
                                anime.status = 'completed';
                                // Usuń automatyczne ustawianie daty ukończenia - niech użytkownik sam decyduje
                                // anime.completedDate = date; // Ustaw datę ukończenia na datę aktywności
                                console.log('Anime zostało ukończone!');
                            }
                            // Zawsze aktualizuj datę ostatniego oglądania
                            anime.lastWatchedDate = date;
                        }
                        
                        console.log('Przed saveAnimeList - animeList length:', animeList.length);
                        saveAnimeList();
                        console.log('Po saveAnimeList - animeList length:', animeList.length);
                        renderAnimeList();
                        renderTierList();
                        updateProfileStats();
                    }
                }
                
                hideEpisodeModal();
                const message = activityOnly ? 'Aktywność została dodana!' : 'Odcinki zostały dodane!';
                showNotification(message, 'success');
            });
            
            // Dodaj funkcję do wyświetlania anime z danym tagiem
            function renderProfileAnimeListByTag(tag) {
                const list = animeList.filter(a => a.tags && a.tags.includes(tag));
                const label = `Anime z tagiem: <span class='anime-tag'>${tag}</span>`;
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime z tagiem "${tag}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label}</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                list.forEach(a => {
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                        <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                        <td style='padding:8px 4px;'>${a.averageRating}</td>
                    </tr>`;
                });
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }

            // Obsługa czyszczenia daty ukończenia
            document.getElementById('clear-completed-date').addEventListener('click', function() {
                document.getElementById('completed-date').value = '';
            });
            
            // Initial render of activity calendar
            renderActivityCalendar();
            
            // Obsługa zmiany rozmiaru okna
            window.addEventListener('resize', () => {
                const wasMobile = isMobileView;
                isMobileView = window.innerWidth <= 768;
                
                // Przełącz widok tylko jeśli się zmienił
                if (wasMobile !== isMobileView) {
                    renderActivityCalendar();
                }
            });
            
            // Funkcja do obsługi swipe na kalendarzu
            function addSwipeSupport(container) {
                let startX = 0;
                let startY = 0;
                let endX = 0;
                let endY = 0;
                
                container.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                }, { passive: true });
                
                container.addEventListener('touchend', (e) => {
                    endX = e.changedTouches[0].clientX;
                    endY = e.changedTouches[0].clientY;
                    
                    const diffX = startX - endX;
                    const diffY = startY - endY;
                    
                    // Sprawdź czy swipe jest bardziej poziomy niż pionowy i ma odpowiednią długość
                    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                        if (isMobileView) {
                            // Na mobile - nawigacja miesięczna
                            if (diffX > 0) {
                                // Swipe w lewo - następny miesiąc
                                currentMonth++;
                                if (currentMonth > 11) {
                                    currentMonth = 0;
                                    currentYear++;
                                }
                            } else {
                                // Swipe w prawo - poprzedni miesiąc
                                currentMonth--;
                                if (currentMonth < 0) {
                                    currentMonth = 11;
                                    currentYear--;
                                }
                            }
                        } else {
                            // Na desktop - nawigacja roczna
                            if (diffX > 0) {
                                // Swipe w lewo - następny rok
                                currentYear++;
                            } else {
                                // Swipe w prawo - poprzedni rok
                                currentYear--;
                            }
                        }
                        renderActivityCalendar();
                    }
                }, { passive: true });
            }
        });
    </script>
    
    <!-- Modal do dodawania odcinków -->
    <div class="episode-modal" id="episode-modal">
        <div class="episode-modal-content">
            <div class="episode-modal-header">
                <h3 id="episode-modal-title">Dodaj odcinki</h3>
                <button class="episode-modal-close" id="episode-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="episode-counter">
                <button class="episode-counter-btn" id="episode-decrease">
                    <i class="fas fa-minus"></i>
                </button>
                <div class="episode-counter-value" id="episode-count">1</div>
                <button class="episode-counter-btn" id="episode-increase">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div class="form-group">
                <label for="episode-date">Data oglądania</label>
                <input type="date" id="episode-date" required>
            </div>
            <div class="form-group" style="margin-bottom: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="activity-only" style="width: auto; margin: 0;">
                    <span style="color: var(--gray); font-size: 0.9rem;">
                        <i class="fas fa-calendar-check"></i> Tylko aktywność (nie zmieniaj postępu anime)
                    </span>
                </label>
            </div>
            <button class="add-episode-btn" id="add-episode-btn">
                <i class="fas fa-plus"></i>
                Dodaj odcinki
            </button>
        </div>
    </div>
    
    <!-- Modal podsumowania dnia -->
    <div class="day-summary-modal" id="day-summary-modal">
        <div class="day-summary-content">
            <div class="day-summary-header">
                <div class="day-summary-date" id="day-summary-date">Data</div>
                <button class="day-summary-close" id="day-summary-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="day-summary-stats" id="day-summary-stats">
                <!-- Statystyki będą dodawane dynamicznie -->
            </div>
            <div class="day-summary-anime-list" id="day-summary-anime-list">
                <!-- Lista anime będzie dodawana dynamicznie -->
            </div>
        </div>
    </div>

    <!-- Modal generowania kodu -->
    <div class="transfer-modal" id="generate-code-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-qrcode"></i> Generuj kod transferu
                </h3>
                <button class="transfer-modal-close" id="generate-code-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Kod umożliwi przeniesienie wszystkich twoich danych anime oraz aktywności na inne urządzenie. Kod jest ważny przez 1 godzinę.
            </div>
            <div class="transfer-code-display" id="generated-code">
                Generowanie...
            </div>
            <div class="transfer-timer" id="code-timer">
                Kod wygaśnie za: <span id="time-remaining">59:59</span>
            </div>
            <button class="copy-button" id="copy-code-btn">
                <i class="fas fa-copy"></i> Skopiuj kod
            </button>
        </div>
    </div>

    <!-- Modal wpisywania kodu -->
    <div class="transfer-modal" id="import-code-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-download"></i> Wgraj kod transferu
                </h3>
                <button class="transfer-modal-close" id="import-code-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Wpisz 6-cyfrowy kod aby wgrać dane. Po wgraniu dane zostaną automatycznie połączone z obecnymi.
            </div>
            <input type="text" 
                   class="transfer-code-input" 
                   id="import-code-input" 
                   placeholder="000000"
                   maxlength="6"
                   autocomplete="off">
            <div style="display: none;" id="import-preview">
                <div class="transfer-info" style="border-left-color: var(--success);">
                    <strong>Znaleziono dane:</strong>
                    <div id="import-preview-content"></div>
                </div>
                <button class="btn-success" id="confirm-import-btn" style="width: 100%; margin-top: 1rem;">
                    <i class="fas fa-check"></i> Potwierdź import danych
                </button>
            </div>
        </div>
    </div>
</body>
</html>
