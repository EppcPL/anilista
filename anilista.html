<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Toolkit</title>
                      <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
                  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
                  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
                  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
                  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <style>
        html {
    scroll-behavior: smooth;
}

.section {
    scroll-margin-top: 80px;
}
        :root {
            --primary: #6c5ce7;
            --primary-dark: #5649c0;
            --primary-light: #a29bfe;
            --secondary: #fd79a8;
            --accent: #00cec9;
            --dark: #2d3436;
            --darker: #1e272e;
            --light: #f5f6fa;
            --lighter: #ffffff;
            --gray: #dfe6e9;
            --success: #00b894;
            --warning: #fdcb6e;
            --danger: #d63031;
            --info: #0984e3;
            
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            --card-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, var(--darker), var(--dark));
            color: var(--light);
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-left: 100px;
        }
        
        h1, h2, h3 {
            color: var(--lighter);
            margin-bottom: 1.5rem;
            font-weight: 600;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.8rem;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            padding-bottom: 1rem;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
        }
        
        .section {
            margin-bottom: 3rem;
            padding: 2rem;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray);
            font-size: 0.95rem;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 1rem;
            color: var(--lighter);
            transition: var(--transition);
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
            background: rgba(0, 0, 0, 0.3);
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
            box-shadow: 0 4px 12px rgba(214, 48, 49, 0.3);
        }
        
        .btn-success {
            background-color: var(--success);
        }
        
        .btn-success:hover {
            background-color: #00a383;
            box-shadow: 0 4px 12px rgba(0, 184, 148, 0.3);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
        }
        
        .btn-secondary:hover {
            background-color: #e84393;
            box-shadow: 0 4px 12px rgba(253, 121, 168, 0.3);
        }
        
        .btn-accent {
            background-color: var(--accent);
        }
        
        .btn-accent:hover {
            background-color: #00b5ad;
            box-shadow: 0 4px 12px rgba(0, 206, 201, 0.3);
        }
        
        .anime-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .anime-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.3;
            z-index: -1;
        }
        
        .anime-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .anime-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .anime-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .anime-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--lighter);
            position: relative;
            padding-left: 12px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .anime-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
        }
        
        .anime-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--glass-border);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .status-watching {
            color: var(--info);
            border-color: var(--info);
        }
        
        .status-completed {
            color: var(--success);
            border-color: var(--success);
        }
        
        .status-upcoming {
            color: var(--warning);
            border-color: var(--warning);
        }

        /* Status bar on top of anime cards */
        .anime-card {
            position: relative;
        }

        .anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            border-radius: 20px 20px 0 0;
            z-index: 1;
        }

        .anime-card.status-watching::before {
            background: var(--info);
            box-shadow: 0 0 8px rgba(9, 132, 227, 0.4);
        }

        .anime-card.status-completed::before {
            background: var(--success);
            box-shadow: 0 0 8px rgba(0, 184, 148, 0.4);
        }

        .anime-card.status-upcoming::before {
            background: var(--warning);
            box-shadow: 0 0 8px rgba(253, 203, 110, 0.4);
        }
        
        .rating-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .rating-label {
            font-weight: 500;
            width: 80px;
            color: var(--gray);
        }
        
        .rating-value {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: var(--lighter);
            padding-left: 8px;
            padding-right: 8px;
            flex-shrink: 0;
            word-break: break-all;
        }
        
        .tier-list {
            margin-top: 2rem;
        }
        
        .tier-row {
            display: flex;
            margin-bottom: 0.5rem;
            min-height: 70px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .tier-label {
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            position: relative;
            z-index: 1;
            font-size: 1.2rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .tier-SSS { 
            font-weight: 900;
            font-size: 1.4em;
            animation: rainbow 5s linear infinite;
        }
        
        .tier-SS { background-color: #ff4757; }
        .tier-S { background-color: #ff6b81; }
        .tier-A { background-color: #ff9f43; }
        .tier-B { background-color: #feca57; color: #333; }
        .tier-C { background-color: #fffa65; color: #333; }
        .tier-D { background-color: #1dd1a1; color: #333; }
        .tier-F { background-color: #10ac84; color: #333; }
        
        .tier-items {
            flex-grow: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            min-height: 70px;
            align-items: center;
        }
        
        .tier-item {
            background-color: var(--primary);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.9rem;
            height: fit-content;
            transition: var(--transition);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
        }
        
        /* Tier item hover moved to modern section below */
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
            gap: 0.8rem;
            margin-top: auto;
        }
        
        .actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        
        .no-anime {
            text-align: center;
            padding: 2rem;
            color: var(--gray);
            grid-column: 1 / -1;
            font-size: 1.1rem;
        }
        
        .tier-controls {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .tier-category-btn {
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--gray);
            transition: var(--transition);
            border: 1px solid var(--glass-border);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .tier-category-btn.active {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .average-rating {
            font-weight: 600;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--glass-border);
            color: var(--lighter);
            font-size: 1.1rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
        }
        
        /* Profile stats */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .stat-card {
            background: var(--glass);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-shadow);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .stat-card.clickable {
            cursor: pointer;
            transition: var(--transition);
        }
        
        .stat-card.clickable:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
        }
        
        .stat-card.clickable:hover .stat-value {
            color: var(--primary-light);
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin: 1rem 0;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-label {
            font-size: 0.95rem;
            color: var(--gray);
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        /* Time display */
        .time-display {
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }
        
        .time-display:hover {
            color: var(--primary);
        }
        
        .rewatch-info {
            font-size: 0.75rem;
            color: var(--gray);
            margin-top: 2px;
            display: block;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background: var(--darker);
            color: var(--lighter);
            text-align: center;
            border-radius: 8px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            font-size: 0.85rem;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Rainbow animation for SSS tier */
        @keyframes rainbow {
            0% { background-color: #ff0000; }
            14% { background-color: #ff7f00; }
            28% { background-color: #ffff00; }
            42% { background-color: #00ff00; }
            57% { background-color: #0000ff; }
            71% { background-color: #4b0082; }
            85% { background-color: #9400d3; }
            100% { background-color: #ff0000; }
        }
        
        /* Kalendarz aktywności */
        .month-dot.clickable:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.4);
            border-color: var(--primary-light);
        }
        
        .year-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--glass-border);
        }
        
        .months-grid {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }
        
        /* Navbar styles */
        .semi-circle-nav {
            width: 80px;
            height: 100vh;
            background: rgba(30, 39, 46, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            left: 0;
            top: 0;
            border-radius: 0 24px 24px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }
        
        .nav-item {
            padding: 14px 0;
            margin: 6px 0;
            color: var(--gray);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
            text-align: center;
            width: 100%;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        
        .nav-item i {
            font-size: 1.2rem;
        }
        
        .nav-item:hover {
            color: var(--primary-light);
            transform: translateX(8px);
        }
        
        .nav-item.active {
            color: white;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            border-radius: 12px 0 0 12px;
            transform: translateX(10px) scale(1.05);
            box-shadow: 4px 0 12px rgba(108, 92, 231, 0.4);
        }
        
        /* SSS tier styling is now handled by .tier-item[data-tier="SSS"] only */
        
        /* Floating action button */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 20px rgba(108, 92, 231, 0.4);
            cursor: pointer;
            z-index: 100;
            transition: var(--transition);
            border: none;
        }
        
        .fab:hover {
            transform: translateY(-5px) scale(1.1);
            background: var(--primary-dark);
            box-shadow: 0 6px 24px rgba(108, 92, 231, 0.5);
        }
        
        /* Image upload styles */
        .image-upload-container {
            margin-bottom: 1.5rem;
        }
        
        .image-preview {
            width: 100%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px dashed var(--glass-border);
            border-radius: 8px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .image-preview-placeholder {
            text-align: center;
            color: var(--gray);
            padding: 20px;
        }
        
        .image-preview-placeholder i {
            font-size: 3rem;
            margin-bottom: 10px;
            display: block;
            color: var(--primary-light);
        }
        
        .remove-image-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.8;
            transition: var(--transition);
            z-index: 2;
        }
        
        .remove-image-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        /* Responsive styles */
        @media (max-width: 992px) {
            .container {
                padding-left: 90px;
            }
            
            .semi-circle-nav {
                width: 70px;
            }
            
            .nav-item {
                font-size: 0;
                padding: 16px 0;
            }
            
            .nav-item i {
                font-size: 1.3rem;
            }
            
            .nav-item.active {
                transform: translateX(8px);
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding-left: 0;
            }
            
            .container {
                padding: 15px;
                padding-bottom: 80px;
            }
            
            .semi-circle-nav {
                width: 100%;
                height: 60px;
                bottom: 0;
                top: auto;
                flex-direction: row;
                border-radius: 24px 24px 0 0;
                justify-content: space-around;
                padding: 0 10px;
            }
            
            .nav-item {
                font-size: 0.7rem;
                padding: 8px 4px;
                margin: 0;
                width: auto;
            }
            
            .nav-item i {
                font-size: 1.1rem;
            }
            
            .nav-item.active {
                transform: translateY(-8px);
                border-radius: 12px 12px 0 0;
            }
            
            .anime-list {
                grid-template-columns: 1fr;
            }
            
            .tier-controls {
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 10px;
                scrollbar-width: none;
            }
            
            .tier-controls::-webkit-scrollbar {
                display: none;
            }
            
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            
            .fab {
                bottom: 80px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }
        
            .anime-card {
                min-height: 350px;
            }
        }
    
        @media (max-width: 480px) {
            .section {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .tier-label {
                width: 60px;
                font-size: 1rem;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .actions button {
                width: 100%;
            }
        }
        .seasons-progress {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .odcinki-row:hover {
            background: rgba(255,255,255,0.05);
        }
        #collection-controls {
            padding: 16px 0 0 0;
            min-height: 48px;
        }
        
        /* Planner styles */
        .planner-card {
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: var(--transition);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }
        
        .planner-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transition: var(--transition);
        }
        
        .planner-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--card-shadow);
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.8);
        }
        
        .planner-card:hover::after {
            width: 8px;
            background: linear-gradient(to bottom, var(--primary), var(--accent));
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }
        
        /* Activity Calendar Styles */
        .activity-calendar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .calendar-year {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .calendar-year.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            position: relative;
        }
        
        .calendar-year.clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        .calendar-year.clickable:active {
            transform: translateY(0);
        }
        
        .calendar-month-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--lighter);
            text-align: center;
        }
        
        .calendar-month-title.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem 1rem;
            border-radius: 6px;
        }
        
        .calendar-month-title.clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        .calendar-month-title.clickable:active {
            transform: translateY(0);
        }
        
        .calendar-nav {
            display: flex;
            gap: 0.5rem;
        }
        

        
        /* Desktop widok miesięczny */
        .calendar-back-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            margin-left: 1rem;
        }
        
        .calendar-back-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-1px);
        }
        
        .desktop-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: auto repeat(6, 1fr);
            gap: 3px;
            margin-top: 1rem;
        }
        
        .desktop-month-label {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.85rem;
            color: var(--gray);
            font-weight: 500;
        }
        
        .desktop-month-day {
            aspect-ratio: 1;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .desktop-month-day:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .desktop-month-day.empty {
            background: rgba(255, 255, 255, 0.05);
            color: var(--gray);
            cursor: default;
        }
        
        .desktop-month-day.other-month {
            color: var(--gray);
            opacity: 0.5;
        }
        
        .desktop-month-day.level-0 { background: rgba(255, 255, 255, 0.1); }
        .desktop-month-day.level-1 { background: rgba(108, 92, 231, 0.3); }
        .desktop-month-day.level-2 { background: rgba(108, 92, 231, 0.5); }
        .desktop-month-day.level-3 { background: rgba(108, 92, 231, 0.7); }
        .desktop-month-day.level-4 { background: rgba(108, 92, 231, 0.9); }
        
        .desktop-month-tooltip {
            position: absolute;
            background: var(--darker);
            color: var(--lighter);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
        }
        
        .desktop-month-day:hover .desktop-month-tooltip {
            opacity: 1;
        }
        
        /* Animacje przejścia dla kalendarza */
        .calendar-grid {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-days {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-day {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .calendar-day:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* Animacja fade dla przełączania widoków */
        .calendar-days.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .calendar-days.fade-in {
            opacity: 1;
            transform: translateY(0);
        }
        
        .calendar-nav-btn {
            background: var(--primary);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .calendar-nav-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            align-items: start;
        }
        
        .calendar-labels {
            display: grid;
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
            font-size: 0.85rem;
            color: var(--gray);
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            margin-top: 32px; /* Przesunięcie w dół, żeby wyrównać z kwadratami */
        }
        

        
        .calendar-labels > div {
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            cursor: pointer;
            transition: var(--transition);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .calendar-labels > div:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--lighter);
        }
        
        .calendar-months > div {
            transition: var(--transition);
            padding: 2px 4px;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }
        
        .calendar-months > div:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--lighter);
        }
        

        
        .calendar-day.dimmed {
            opacity: 0.3;
            filter: grayscale(0.5);
        }
        
        .calendar-months {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 4px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            color: var(--gray);
            text-align: center;
        }
        
        .calendar-month {
            position: relative;
        }
        
        .calendar-month:not(:last-child)::after {
            content: '';
            position: absolute;
            right: -2px;
            top: 0;
            bottom: 0;
            width: 1px;
            background: var(--glass-border);
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
            position: relative;
        }
        

        
        .calendar-day {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            border: 1px solid transparent;
        }
        
        .calendar-day:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        
        .calendar-day.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .calendar-day.level-0 {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .calendar-day.level-1 {
            background: var(--primary-light);
        }
        
        .calendar-day.level-2 {
            background: var(--primary);
        }
        
        .calendar-day.level-3 {
            background: var(--primary-dark);
        }
        
        .calendar-day.level-4 {
            background: var(--accent);
        }
        
        .calendar-day.level-5 {
            background: var(--secondary);
        }
        
        .calendar-tooltip {
            position: absolute;
            background: var(--darker);
            color: var(--lighter);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: var(--shadow);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .calendar-day:hover .calendar-tooltip {
            opacity: 1;
        }
        
        /* Mobile Calendar Improvements */
        @media (max-width: 768px) {
            .activity-calendar {
                padding: 1rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            

            
            .activity-calendar::-webkit-scrollbar {
                display: none;
            }
            
            .calendar-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .calendar-year {
                font-size: 1.2rem;
                text-align: center;
            }
            
            .calendar-month-title {
                font-size: 1.2rem;
                font-weight: 600;
                color: var(--lighter);
                text-align: center;
            }
            
            .calendar-nav {
                justify-content: center;
            }
            
            .calendar-nav-btn {
                padding: 12px 16px;
                font-size: 1rem;
                min-width: 50px;
                min-height: 50px;
                touch-action: manipulation;
            }
            
            /* Mobile Calendar Grid */
            .mobile-calendar-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .mobile-calendar-labels {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 4px;
                margin-bottom: 0.5rem;
            }
            
            .mobile-calendar-label {
                text-align: center;
                font-size: 0.8rem;
                color: var(--gray);
                font-weight: 500;
                padding: 4px;
            }
            
            .mobile-calendar-days {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 4px;
            }
            
            .mobile-calendar-day {
                aspect-ratio: 1;
                border-radius: 4px;
                cursor: pointer;
                transition: var(--transition);
                position: relative;
                border: 1px solid transparent;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.8rem;
                font-weight: 500;
                min-height: 32px;
            }
            
            .mobile-calendar-day:hover {
                transform: scale(1.1);
                z-index: 10;
            }
            
            .mobile-calendar-day.empty {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .mobile-calendar-day.other-month {
                opacity: 0.3;
                color: var(--gray);
            }
            
            .mobile-calendar-day.level-0 {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--lighter);
            }
            
            .mobile-calendar-day.level-1 {
                background: var(--primary-light);
                color: var(--dark);
            }
            
            .mobile-calendar-day.level-2 {
                background: var(--primary);
                color: white;
            }
            
            .mobile-calendar-day.level-3 {
                background: var(--primary-dark);
                color: white;
            }
            
            .mobile-calendar-day.level-4 {
                background: var(--accent);
                color: white;
            }
            
            .mobile-calendar-day.level-5 {
                background: var(--secondary);
                color: white;
            }
            
            .mobile-calendar-tooltip {
                position: absolute;
                background: var(--darker);
                color: var(--lighter);
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.8rem;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: var(--shadow);
                border: 1px solid var(--glass-border);
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-bottom: 5px;
            }
            
            .mobile-calendar-day:hover .mobile-calendar-tooltip {
                opacity: 1;
            }
            
            /* Ukryj desktop calendar na mobile */
            .calendar-grid {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .mobile-calendar-day {
                min-height: 28px;
                font-size: 0.7rem;
            }
            
            .mobile-calendar-label {
                font-size: 0.7rem;
            }
            
            .calendar-month-title {
                font-size: 1rem;
            }
            
            .calendar-nav-btn {
                padding: 10px 12px;
                min-width: 45px;
                min-height: 45px;
            }
        }
        
        /* Episode counter modal */
        .episode-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .episode-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .episode-modal-content {
            background: var(--darker);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
        }
        
        .episode-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .episode-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .episode-modal-close:hover {
            color: var(--lighter);
        }
        
        .episode-counter {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .episode-counter-btn {
            background: var(--primary);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: var(--transition);
        }
        
        .episode-counter-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }
        
        .episode-counter-value {
            font-size: 1.5rem;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .add-episode-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .add-episode-btn:hover {
            background: #00a383;
            transform: translateY(-1px);
        }
        
        /* Day summary modal */
        .day-summary-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .day-summary-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .day-summary-content {
            background: var(--darker);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .day-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .day-summary-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .day-summary-close:hover {
            color: var(--lighter);
        }
        
        .day-summary-date {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--lighter);
        }
        
        .day-summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .day-summary-stat {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            border: 1px solid var(--glass-border);
        }
        
        .day-summary-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-stat-label {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-list {
            margin-top: 1.5rem;
        }
        
        .day-summary-anime-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
        }
        
        .day-summary-anime-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
        }
        
        .day-summary-anime-title {
            font-weight: 600;
            color: var(--lighter);
            margin-bottom: 0.5rem;
        }
        
        .day-summary-anime-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .day-summary-anime-episodes {
            color: var(--primary);
            font-weight: 500;
        }
        
        .day-summary-anime-time {
            color: var(--accent);
            font-weight: 500;
        }
        
        .day-summary-empty {
            text-align: center;
            color: var(--gray);
            font-style: italic;
            padding: 2rem;
        }
        
        .day-summary-tag-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 150px;
        }
        
        .day-summary-tag-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
        }
        
        .day-summary-tag-stats {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .day-summary-tag-episodes {
            color: var(--primary);
            font-weight: 500;
        }
        
        .day-summary-tag-anime {
            color: var(--accent);
            font-weight: 500;
        }
        
        .day-summary-tag-time {
            color: var(--secondary);
            font-weight: 500;
        }
        
        .priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .priority-badge.priority-niski {
            color: var(--success);
            border-color: var(--success);
        }
        
        .priority-badge.priority-średni {
            color: var(--warning);
            border-color: var(--warning);
        }
        
        .priority-badge.priority-duży {
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .planner-notes {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 1rem 0;
            font-style: italic;
            color: var(--gray);
            border-left: 3px solid var(--primary);
        }
        
        .planner-actions {
            display: flex;
            gap: 0.8rem;
            margin-top: 1rem;
        }
        
        .planner-actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
            border-radius: 6px;
        }
        .anime-tag {background: var(--primary-light); color: var(--dark); border-radius: 12px; padding: 2px 10px; font-size: 0.85em; font-weight: 500; margin-right: 2px;}
        
        /* Transfer system styles */
        .transfer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .transfer-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .transfer-modal-content {
            background: var(--darker);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            text-align: center;
        }
        
        .transfer-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .transfer-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .transfer-modal-close:hover {
            color: var(--lighter);
        }
        
        .transfer-code-display {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: var(--primary-light);
            font-family: 'Courier New', monospace;
            text-align: center;
            position: relative;
        }
        
        .transfer-code-input {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: 0.2em;
            color: var(--lighter);
            font-family: 'Courier New', monospace;
            text-align: center;
            width: 100%;
            outline: none;
            transition: var(--transition);
        }
        
        .transfer-code-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
        }
        
        .transfer-code-input.error {
            border-color: var(--danger);
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .transfer-timer {
            font-size: 0.9rem;
            color: var(--warning);
            margin-top: 0.5rem;
            font-weight: 500;
        }
        
        .transfer-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            color: var(--gray);
            border-left: 3px solid var(--info);
        }
        
        .copy-button {
            background: var(--success);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            margin-top: 1rem;
        }
        
        .copy-button:hover {
            background: #00a383;
            transform: translateY(-1px);
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            max-width: 400px;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification-success {
            background: linear-gradient(90deg, var(--success), #00a383);
            border-left: 5px solid #00a383;
        }
        
        .notification-danger {
            background: linear-gradient(90deg, var(--danger), #c0392b);
            border-left: 5px solid #c0392b;
        }
        
        .notification-info {
            background: linear-gradient(90deg, var(--info), #0652dd);
            border-left: 5px solid #0652dd;
        }
        
        .notification-warning {
            background: linear-gradient(90deg, var(--warning), #e55039);
            border-left: 5px solid #e55039;
        }
        
        /* Loading spinner */
        .fa-spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ================================
           🎨 ADVANCED ANIMATIONS PACKAGE
           ================================ */

        /* Modal animations */
        .modal {
            animation: modalFadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .modal.show {
            animation: modalSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalFadeIn {
            0% { 
                opacity: 0;
                backdrop-filter: blur(0px);
            }
            100% { 
                opacity: 1;
                backdrop-filter: blur(8px);
            }
        }

        @keyframes modalSlideIn {
            0% { 
                opacity: 0;
                transform: scale(0.7) translateY(-50px);
                filter: blur(10px);
            }
            60% {
                transform: scale(1.05) translateY(10px);
                filter: blur(2px);
            }
            100% { 
                opacity: 1;
                transform: scale(1) translateY(0);
                filter: blur(0px);
            }
        }

        /* Page section animations */
        .section {
            animation: pageSlideUp 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        @keyframes pageSlideUp {
            0% {
                opacity: 0;
                transform: translateY(30px);
                filter: blur(5px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
                filter: blur(0px);
            }
        }

        /* Card hover animations */
        .anime-card, .stat-card, .tier-item {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .anime-card:hover, .stat-card:hover {
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }

        /* Button pulse animation */
        .btn-accent, .btn-primary {
            position: relative;
            overflow: hidden;
        }

        .btn-accent::before, .btn-primary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-accent:active::before, .btn-primary:active::before {
            width: 300px;
            height: 300px;
        }

        /* Navigation animations */
        .nav-item {
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .nav-item:hover {
            transform: translateY(-5px) scale(1.1);
            filter: brightness(1.2);
        }

        .nav-item.active {
            animation: navPulse 2s ease-in-out infinite;
        }

        @keyframes navPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Loading animations */
        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInLeft {
            0% {
                opacity: 0;
                transform: translateX(-50px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInRight {
            0% {
                opacity: 0;
                transform: translateX(50px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Stats counter animation */
        .stat-value {
            animation: countUp 1s ease-out;
        }

        @keyframes countUp {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Progress bar animation */
        .progress-bar {
            animation: progressFill 1.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        @keyframes progressFill {
            0% {
                width: 0% !important;
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Calendar day animations */
        .calendar-day {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .calendar-day:hover {
            transform: scale(1.1) rotate(5deg);
            z-index: 10;
        }

        .calendar-day.has-activity {
            animation: activityPulse 2s ease-in-out infinite;
        }

        @keyframes activityPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7);
            }
            50% { 
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }
        }

        /* Tier list animations */
        .tier-item {
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .tier-item:hover {
            transform: translateY(-2px) scale(1.03);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(108, 92, 231, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        .tier-item.dragging {
            animation: wiggle 0.5s ease-in-out infinite;
            z-index: 1000;
        }

        @keyframes wiggle {
            0%, 7% { transform: rotateZ(0deg); }
            15% { transform: rotateZ(-15deg); }
            20% { transform: rotateZ(10deg); }
            25% { transform: rotateZ(-10deg); }
            30% { transform: rotateZ(6deg); }
            35% { transform: rotateZ(-4deg); }
            40%, 100% { transform: rotateZ(0deg); }
        }

        /* Form input animations */
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            animation: inputFocus 0.3s ease-out;
        }

        @keyframes inputFocus {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7);
            }
            50% {
                transform: scale(1.02);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 8px rgba(52, 152, 219, 0);
            }
        }

        /* Success/Error animations */
        @keyframes successBounce {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(-50px);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(-10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }



        /* Stagger animations for lists */
        .anime-card:nth-child(1) { animation-delay: 0.1s; }
        .anime-card:nth-child(2) { animation-delay: 0.2s; }
        .anime-card:nth-child(3) { animation-delay: 0.3s; }
        .anime-card:nth-child(4) { animation-delay: 0.4s; }
        .anime-card:nth-child(5) { animation-delay: 0.5s; }
        .anime-card:nth-child(6) { animation-delay: 0.6s; }

        .stat-card:nth-child(1) { animation-delay: 0.1s; }
        .stat-card:nth-child(2) { animation-delay: 0.2s; }
        .stat-card:nth-child(3) { animation-delay: 0.3s; }
        .stat-card:nth-child(4) { animation-delay: 0.4s; }

        /* Mobile responsive animations */
        @media (max-width: 768px) {
            .modal {
                animation: modalSlideUp 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            }

            @keyframes modalSlideUp {
                0% {
                    opacity: 0;
                    transform: translateY(100%);
                }
                100% {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        }

        /* Utility animation classes */
        .animate-fadeIn { animation: fadeInUp 0.6s ease-out; }
        .animate-slideLeft { animation: slideInLeft 0.6s ease-out; }
        .animate-slideRight { animation: slideInRight 0.6s ease-out; }
        .animate-bounce { animation: bounceIn 0.8s ease-out; }

        .animate-pulse { animation: navPulse 2s ease-in-out infinite; }

        /* ================================
           END ANIMATIONS PACKAGE 🎨
           ================================ */

        /* ================================
           🚀 MODERN UI PACKAGE 2024
           ================================ */

        /* Advanced Background with Better Readability */
        body {
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 40% 40%, rgba(0, 206, 201, 0.1) 0%, transparent 60%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
            background-attachment: fixed;
            background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%;
        }

        /* Enhanced Glassmorphism with Better Readability */
        .section {
            background: linear-gradient(135deg, 
                rgba(20, 25, 45, 0.85) 0%, 
                rgba(15, 20, 35, 0.9) 100%);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
        }

        /* Enhanced Cards with Better Readability */
        .stat-card, .anime-card {
            background: linear-gradient(135deg, 
                rgba(25, 30, 50, 0.9) 0%, 
                rgba(20, 25, 40, 0.95) 100%);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
            position: relative;
            overflow: hidden;
        }

        /* Enhanced Text Readability */
        .stat-card, .anime-card, .section {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .stat-label, .anime-title {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
        }

        .stat-value {
            color: #ffffff;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .stat-card::before, .anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transition: left 0.8s ease;
        }

        .stat-card:hover::before, .anime-card:hover::before {
            left: 100%;
        }

        /* Old neon accents removed - tier items now have individual color hierarchy */

        /* Advanced Navigation */
        .semi-circle-nav {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 50px 50px 0;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .nav-item {
            position: relative;
            overflow: hidden;
            border-radius: 16px;
            background: transparent;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(108, 92, 231, 0.8) 0%, 
                rgba(0, 206, 201, 0.8) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 16px;
        }

        .nav-item.active::before, .nav-item:hover::before {
            opacity: 1;
        }

        .nav-item span, .nav-item i {
            position: relative;
            z-index: 1;
        }

        /* Modern Buttons */
        .btn-accent, .btn-primary, .btn-success {
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--accent) 100%);
            border: none;
            border-radius: 16px;
            padding: 14px 28px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 8px 24px rgba(108, 92, 231, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .btn-accent:hover, .btn-primary:hover, .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 32px rgba(108, 92, 231, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Enhanced Form Inputs with Better Readability */
        .form-group input, .form-group select, .form-group textarea {
            background: linear-gradient(135deg, 
                rgba(30, 35, 55, 0.9) 0%, 
                rgba(25, 30, 45, 0.95) 100%);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.95);
            font-size: 1rem;
            padding: 16px 20px;
            transition: all 0.3s ease;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.2),
                0 2px 8px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            border: 1px solid rgba(108, 92, 231, 0.6);
            box-shadow: 
                0 0 0 3px rgba(108, 92, 231, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.2),
                0 4px 12px rgba(108, 92, 231, 0.1);
            background: linear-gradient(135deg, 
                rgba(35, 40, 60, 0.95) 0%, 
                rgba(30, 35, 50, 1) 100%);
            color: #ffffff;
        }

        .form-group label {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
            margin-bottom: 8px;
        }

        /* Modern Typography */
        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, 
                #667eea 0%, 
                #764ba2 50%, 
                #f093fb 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 4px;
            background: linear-gradient(135deg, 
                #667eea 0%, 
                #764ba2 50%, 
                #f093fb 100%);
            border-radius: 2px;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        h2 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--accent) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 2rem;
        }

        /* Enhanced Modal Design with Better Readability */
        .modal {
            backdrop-filter: blur(16px);
            background: rgba(0, 0, 0, 0.8);
        }

        .episode-modal-content, .modal-content {
            background: linear-gradient(135deg, 
                rgba(20, 25, 45, 0.95) 0%, 
                rgba(15, 20, 35, 0.98) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.95);
        }

        .episode-modal-header h3, .modal-header h3 {
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Progress Bars Enhanced */
        .progress-bar {
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--accent) 100%);
            border-radius: 10px;
            box-shadow: 
                0 4px 8px rgba(108, 92, 231, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Calendar Modernization */
        .calendar-day {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .calendar-day:hover {
            background: linear-gradient(135deg, 
                rgba(108, 92, 231, 0.2) 0%, 
                rgba(0, 206, 201, 0.2) 100%);
            border: 1px solid rgba(108, 92, 231, 0.3);
            box-shadow: 
                0 8px 24px rgba(108, 92, 231, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Tier List Enhancements */
        .tier-row {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.08) 0%, 
                rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--accent) 100%);
            border-radius: 4px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, 
                var(--primary-dark) 0%, 
                var(--accent) 100%);
        }

        /* Floating Action Elements */
        .floating-element {
            position: fixed;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--accent) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                0 8px 24px rgba(108, 92, 231, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .floating-element:hover {
            transform: scale(1.1);
            box-shadow: 
                0 12px 32px rgba(108, 92, 231, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Particle Effects */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, 
                rgba(108, 92, 231, 0.8) 0%, 
                transparent 70%);
            border-radius: 50%;
            animation: float 6s infinite ease-in-out;
        }

        .particle:nth-child(odd) {
            animation-duration: 8s;
            background: radial-gradient(circle, 
                rgba(0, 206, 201, 0.6) 0%, 
                transparent 70%);
        }

        /* Mobile Responsiveness Enhanced */
        @media (max-width: 768px) {
            .container {
                padding-left: 20px;
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            .section {
                border-radius: 16px;
                margin-bottom: 2rem;
                padding: 1.5rem;
            }
            
            .stat-card, .anime-card {
                border-radius: 12px;
            }
        }

        /* Loading States */
        .loading-shimmer {
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.1) 25%, 
                rgba(255, 255, 255, 0.2) 50%, 
                rgba(255, 255, 255, 0.1) 75%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* ================================
           ✨ SPECTACULAR NEON EFFECTS
           ================================ */

        /* Subtle Neon Glow Text Effects */
        .neon-text {
            color: #fff;
            text-shadow: 
                0 0 3px rgba(108, 92, 231, 0.4),
                0 0 6px rgba(108, 92, 231, 0.3),
                0 0 9px rgba(108, 92, 231, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.8);
            animation: subtleNeonPulse 4s ease-in-out infinite alternate;
        }

        @keyframes subtleNeonPulse {
            0% {
                text-shadow: 
                    0 0 3px rgba(108, 92, 231, 0.4),
                    0 0 6px rgba(108, 92, 231, 0.3),
                    0 0 9px rgba(108, 92, 231, 0.2),
                    0 2px 4px rgba(0, 0, 0, 0.8);
            }
            100% {
                text-shadow: 
                    0 0 5px rgba(108, 92, 231, 0.6),
                    0 0 10px rgba(108, 92, 231, 0.4),
                    0 0 15px rgba(108, 92, 231, 0.3),
                    0 2px 4px rgba(0, 0, 0, 0.8);
            }
        }

        /* Enhanced Card Glow on Hover */
        .stat-card:hover, .anime-card:hover {
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 30px rgba(108, 92, 231, 0.3),
                0 0 50px rgba(0, 206, 201, 0.2);
            border: 1px solid rgba(108, 92, 231, 0.4);
        }

        /* Elegant Neon Border for SSS Tier Only */
        .neon-border {
            position: relative;
            border: 2px solid rgba(255, 215, 0, 0.3);
            background: linear-gradient(135deg, rgba(25, 30, 50, 0.9), rgba(20, 25, 40, 0.95));
            border-radius: 20px;
            box-shadow: 
                0 0 15px rgba(255, 215, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .neon-border::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                rgba(255, 215, 0, 0.4) 0%,
                rgba(255, 140, 0, 0.3) 50%,
                rgba(255, 215, 0, 0.4) 100%);
            border-radius: 22px;
            z-index: -1;
            animation: elegantGoldGlow 6s ease-in-out infinite;
        }

        @keyframes elegantGoldGlow {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.02);
            }
        }

        /* Holographic Effect */
        .holographic {
            background: linear-gradient(135deg, 
                rgba(25, 30, 50, 0.9) 0%, 
                rgba(20, 25, 40, 0.95) 100%);
            position: relative;
            overflow: hidden;
        }

        .holographic::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg,
                transparent 30%,
                rgba(255, 255, 255, 0.1) 50%,
                transparent 70%);
            animation: holographicSweep 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes holographicSweep {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }
            50% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
            }
            100% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }
        }

        /* Enhanced Navigation Glow */
        .semi-circle-nav {
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 20px rgba(108, 92, 231, 0.2);
        }

        .nav-item.active {
            box-shadow: 
                0 0 20px rgba(108, 92, 231, 0.4),
                inset 0 0 20px rgba(108, 92, 231, 0.1);
        }

        /* Tier Items Color Hierarchy */
        
        /* SSS Tier - RGB Rainbow */
        .tier-item[data-tier="SSS"] {
            background: linear-gradient(45deg, 
                rgba(255, 0, 0, 0.15) 0%,     /* Red */
                rgba(255, 127, 0, 0.15) 16%,  /* Orange */ 
                rgba(255, 255, 0, 0.15) 33%,  /* Yellow */
                rgba(0, 255, 0, 0.15) 50%,    /* Green */
                rgba(0, 0, 255, 0.15) 66%,    /* Blue */
                rgba(75, 0, 130, 0.15) 83%,   /* Indigo */
                rgba(148, 0, 211, 0.15) 100%  /* Violet */
            );
            background-size: 200% 200%;
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.3),
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            animation: rainbowShift 4s ease-in-out infinite, rainbowGlow 3s ease-in-out infinite alternate;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.4);
        }

        @keyframes rainbowShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes rainbowGlow {
            0% {
                box-shadow: 
                    0 0 20px rgba(255, 0, 0, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
            25% {
                box-shadow: 
                    0 0 20px rgba(0, 255, 0, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
            50% {
                box-shadow: 
                    0 0 20px rgba(0, 0, 255, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
            75% {
                box-shadow: 
                    0 0 20px rgba(148, 0, 211, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
            100% {
                box-shadow: 
                    0 0 25px rgba(255, 127, 0, 0.5),
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.4);
            }
        }

        /* SS Tier - Gold */
        .tier-item[data-tier="SS"] {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2) 0%, 
                rgba(255, 140, 0, 0.15) 100%);
            box-shadow: 
                0 0 15px rgba(255, 215, 0, 0.4),
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.5);
            animation: goldGlow 5s ease-in-out infinite alternate;
            color: #fff;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }

        @keyframes goldGlow {
            0% {
                box-shadow: 
                    0 0 15px rgba(255, 215, 0, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
            100% {
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.6),
                    0 8px 32px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.4);
            }
        }

        /* S Tier - Silver */
        .tier-item[data-tier="S"] {
            background: linear-gradient(135deg, 
                rgba(192, 192, 192, 0.2) 0%, 
                rgba(169, 169, 169, 0.15) 100%);
            box-shadow: 
                0 0 15px rgba(192, 192, 192, 0.4),
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(192, 192, 192, 0.5);
            animation: silverGlow 6s ease-in-out infinite alternate;
            color: #fff;
            text-shadow: 0 0 6px rgba(192, 192, 192, 0.8);
        }

        @keyframes silverGlow {
            0% {
                box-shadow: 
                    0 0 15px rgba(192, 192, 192, 0.4),
                    0 8px 32px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.4);
            }
            100% {
                box-shadow: 
                    0 0 25px rgba(192, 192, 192, 0.6),
                    0 8px 32px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.5);
            }
        }



        /* Subtle Ambient Background Effect */
        .subtle-ambient {
            background: 
                radial-gradient(circle at 25% 75%, rgba(108, 92, 231, 0.08) 0%, transparent 60%),
                radial-gradient(circle at 75% 25%, rgba(0, 206, 201, 0.06) 0%, transparent 60%);
            animation: subtleMove 20s ease-in-out infinite;
        }

        @keyframes subtleMove {
            0%, 100% {
                background: 
                    radial-gradient(circle at 25% 75%, rgba(108, 92, 231, 0.08) 0%, transparent 60%),
                    radial-gradient(circle at 75% 25%, rgba(0, 206, 201, 0.06) 0%, transparent 60%);
            }
            50% {
                background: 
                    radial-gradient(circle at 75% 75%, rgba(108, 92, 231, 0.06) 0%, transparent 60%),
                    radial-gradient(circle at 25% 25%, rgba(0, 206, 201, 0.08) 0%, transparent 60%);
            }
        }

        /* ================================
           END SPECTACULAR NEON EFFECTS ✨
           ================================ */

        /* ================================
           END MODERN UI PACKAGE 🚀
           ================================ */
    </style>
</head>
<body>
    <nav class="semi-circle-nav">
        <a href="#profil" class="nav-item"><i class="fas fa-user"></i><span>Profil</span></a>
        <a href="#dodaj" class="nav-item active"><i class="fas fa-plus"></i><span>Dodaj</span></a>
        <a href="#lista" class="nav-item"><i class="fas fa-list"></i><span>Lista</span></a>
        <a href="#tier-lista" class="nav-item"><i class="fas fa-layer-group"></i><span>Tier Lista</span></a>
        <a href="#planer" class="nav-item"><i class="fas fa-calendar-alt"></i><span>Planer</span></a>
        <a href="#eksport" class="nav-item"><i class="fas fa-file-export"></i><span>Dane</span></a>
    </nav>

    <div class="container">
        <h1><i class="fas fa-film"></i> Anime Toolkit</h1>
        
        <div class="section" id="profil">
            <h2><i class="fas fa-chart-line"></i> Twoje statystyki</h2>
            <div class="stats-container" id="profile-stats">
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-star"></i> Ocena ogólna</div>
                    <div class="stat-value" id="average-rating">0.0</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="average-rating-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-clock"></i> Czas oglądania</div>
                    <div class="stat-value time-display" id="total-time">0h</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-check-circle"></i> Obejrzane</div>
                    <div class="stat-value" id="total-completed">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-bookmark"></i> Planowane</div>
                    <div class="stat-value" id="total-upcoming">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-eye"></i> Oglądane</div>
                    <div class="stat-value" id="total-watching">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-database"></i> Wszystkie</div>
                    <div class="stat-value" id="total-all">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label"><i class="fas fa-tasks"></i> Postęp</div>
                    <div class="stat-value" id="watch-progress">0%</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="watch-progress-bar" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stat-card clickable" id="watch-streak-card">
                    <div class="stat-label"><i class="fas fa-fire"></i> Obecny streak</div>
                    <div class="stat-value" id="current-streak">0 dni</div>
                    <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;">
                        Najdłuższy: <span id="longest-streak">0 dni</span>
                    </div>
                </div>

                <div class="stat-card clickable" id="generate-code-card">
                    <div class="stat-label"><i class="fas fa-qrcode"></i> Generuj kod</div>
                    <div class="stat-value" style="font-size: 1.5rem; color: var(--success);">
                        <i class="fas fa-upload"></i>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;">
                        Kliknij aby wygenerować kod transferu
                    </div>
                </div>
                
                <!-- Aktywny kod eksportu -->
                <div class="stat-card" id="active-code-card" style="display: none;">
                    <div class="stat-label"><i class="fas fa-key"></i> Aktywny kod eksportu</div>
                    <div class="stat-value" style="font-size: 1.2rem; color: var(--primary); font-weight: bold;" id="active-code-display">
                        <!-- Kod będzie wyświetlany tutaj -->
                    </div>
                    <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;" id="active-code-timer">
                        <!-- Timer będzie wyświetlany tutaj -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 0.5rem;">
                        <button class="btn-secondary" id="copy-active-code-btn" style="padding: 4px 8px; font-size: 0.8rem;">
                            <i class="fas fa-copy"></i> Skopiuj
                        </button>
                        <button class="btn-secondary" id="check-active-code-btn" style="padding: 4px 8px; font-size: 0.8rem;">
                            <i class="fas fa-search"></i> Sprawdź kod
                        </button>
                    </div>
                </div>

                <div class="stat-card" id="import-code-card">
                    <div class="stat-label"><i class="fas fa-download"></i> Wgraj kod</div>
                    <div class="stat-value" style="font-size: 1rem; color: var(--accent);">
                        <input type="text" 
                               id="import-code-input-inline" 
                               placeholder="Wpisz kod 6-cyfrowy"
                               maxlength="6"
                               autocomplete="off"
                               style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--darker); color: var(--lighter); font-size: 0.9rem; text-align: center;">
                    </div>
                    <div style="display: none;" id="import-preview-inline">
                        <div class="transfer-info" style="border-left-color: var(--success); margin-top: 0.5rem; font-size: 0.8rem;">
                            <strong>Znaleziono dane:</strong>
                            <div id="import-preview-content-inline"></div>
                        </div>
                    </div>
                </div>


            </div>
            <div id="profile-tags-stats" style="margin-top:2rem;"></div>
            
            <!-- Kalendarz aktywności -->
            <div class="activity-calendar">
                <h3><i class="fas fa-calendar-alt"></i> Kalendarz aktywności</h3>
                <div id="calendar-container"></div>
            </div>
        </div>
        
        <div id="profile-anime-list" style="display:none;margin-top:1.5rem;"></div>
        
        <div class="section" id="dodaj">
            <h2 id="form-title"><i class="fas fa-plus-circle"></i> Dodaj nowe anime</h2>
            <form id="anime-form">
                <input type="hidden" id="edit-id">
                
                <div class="form-group">
                    <label for="title"><i class="fas fa-heading"></i> Tytuł anime</label>
                    <input type="text" id="title" required placeholder="Wpisz tytuł anime">
                </div>
                
                <div class="form-group">
                    <label for="anime-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                    <input type="text" id="anime-tags" placeholder="np. isekai; komedia; sport">
                </div>
                
                <div class="form-group">
                    <label for="status"><i class="fas fa-bookmark"></i> Status</label>
                    <select id="status" required>
                        <option value="watching">Oglądane</option>
                        <option value="completed">Obejrzane</option>
                        <option value="upcoming">Nadchodzące</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                    <input type="number" id="season-count" min="1" value="1">
                </div>
                <div class="form-group" id="seasons-container" style="display:none;"></div>
                <div class="form-group">
                    <label for="total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                    <input type="number" id="total-episodes" min="1" value="12">
                </div>
                
                <div class="form-group">
                    <label for="episode-length"><i class="fas fa-clock"></i> Długość odcinka (minuty)</label>
                    <input type="number" id="episode-length" min="1" value="24">
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="watched-episodes"><i class="fas fa-eye"></i> Obejrzane odcinki</label>
                    <input type="number" id="watched-episodes" min="0" value="0">
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Daty ukończenia i ostatniego oglądania będą automatycznie śledzone przy zwiększaniu aktywności.
                    </small>
                </div>
                
                <div class="form-group" id="completed-date-group" style="display:none;">
                    <label for="completed-date"><i class="fas fa-calendar-check"></i> Data ukończenia</label>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="date" id="completed-date">
                        <button type="button" id="clear-completed-date" class="btn-secondary" style="padding:6px 12px;font-size:0.9em;">Nie pamiętam daty</button>
                    </div>
                    <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                        <i class="fas fa-info-circle"></i> Możesz ręcznie ustawić datę ukończenia anime lub wyczyścić to pole.
                    </small>
                </div>
                

                
                <div class="form-group image-upload-container">
                    <label><i class="fas fa-image"></i> Obrazek anime</label>
                    <input type="file" id="image-upload" accept="image/*" style="display: none;">
                    <button type="button" id="upload-btn" class="btn-accent" style="width: 100%;"><i class="fas fa-upload"></i> Wybierz obrazek</button>
                    <div class="image-preview" id="image-preview">
                        <div class="image-preview-placeholder">
                            <i class="fas fa-image"></i>
                            <span>Brak wybranego obrazka</span>
                        </div>
                    </div>
                </div>
                
                <h3><i class="fas fa-star"></i> Oceny (1-11)</h3>
                <div class="rating-container">
                    <span class="rating-label">Grafika:</span>
                    <input type="number" id="graphics" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Muzyka:</span>
                    <input type="number" id="music" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Postacie:</span>
                    <input type="number" id="characters" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Fabuła:</span>
                    <input type="number" id="story" min="1" max="11" value="5" required>
                </div>
                
                <div class="rating-container">
                    <span class="rating-label">Śmieszność:</span>
                    <input type="number" id="fun" min="1" max="11" value="5" required>
                </div>
                
                <div class="average-rating">
                    <i class="fas fa-calculator"></i> Średnia ocena: <span id="average-display">5</span>
                </div>
                
                <div class="actions">
                    <button type="submit" class="btn-success" id="submit-btn"><i class="fas fa-plus"></i> Dodaj anime</button>
                    <button type="button" class="btn-secondary" id="cancel-edit" style="display: none;"><i class="fas fa-times"></i> Anuluj</button>
                </div>
            </form>
        </div>
        
        <div class="section" id="lista">
            <h2><i class="fas fa-list-ul"></i> Twoja kolekcja</h2>
            <div style="display:flex;align-items:center;gap:1rem;margin-bottom:1rem;flex-wrap:wrap;">
                <label for="sort-select" style="font-weight:500;">Sortuj po:</label>
                <select id="sort-select" style="padding:8px 16px;border-radius:8px;">
                    <option value="title">Tytule (A-Z)</option>
                    <option value="averageRating">Średniej ocenie</option>
                    <option value="graphics">Grafice</option>
                    <option value="music">Muzyce</option>
                    <option value="characters">Postaciach</option>
                    <option value="story">Fabule</option>
                    <option value="fun">Śmieszności</option>
                </select>
                <input type="text" id="search-input" placeholder="Szukaj anime..." style="flex:1;min-width:180px;padding:8px 16px;border-radius:8px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.2);color:var(--lighter);">
            </div>
            <div class="anime-list" id="anime-list">
                <div class="no-anime">Nie dodałeś jeszcze żadnego anime. Dodaj pierwsze używając formularza powyżej!</div>
            </div>
            <div id="collection-controls" style="display:flex;gap:1rem;justify-content:center;margin-top:1.5rem;"></div>
        </div>
        
        <div class="section tier-list" id="tier-lista">
            <h2><i class="fas fa-trophy"></i> Tier Lista</h2>
            
            <div class="tier-controls">
                <button class="tier-category-btn active" data-category="average"><i class="fas fa-star"></i> Średnia</button>
                <button class="tier-category-btn" data-category="graphics"><i class="fas fa-paint-brush"></i> Grafika</button>
                <button class="tier-category-btn" data-category="music"><i class="fas fa-music"></i> Muzyka</button>
                <button class="tier-category-btn" data-category="characters"><i class="fas fa-users"></i> Postacie</button>
                <button class="tier-category-btn" data-category="story"><i class="fas fa-book"></i> Fabuła</button>
                <button class="tier-category-btn" data-category="fun"><i class="fas fa-laugh"></i> Śmieszność</button>
            </div>
            
            <div id="tier-list-container">
                <div class="tier-row">
                    <div class="tier-label tier-SSS">SSS</div>
                    <div class="tier-items" id="tier-SSS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-SS">SS</div>
                    <div class="tier-items" id="tier-SS"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-S">S</div>
                    <div class="tier-items" id="tier-S"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-A">A</div>
                    <div class="tier-items" id="tier-A"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-B">B</div>
                    <div class="tier-items" id="tier-B"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-C">C</div>
                    <div class="tier-items" id="tier-C"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-D">D</div>
                    <div class="tier-items" id="tier-D"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-F">F</div>
                    <div class="tier-items" id="tier-F"></div>
                </div>
            </div>
        </div>
        
        <div class="section" id="planer">
            <h2><i class="fas fa-calendar-alt"></i> Planer anime</h2>
            <div style="color:var(--gray);margin-bottom:1rem;font-size:1rem;">Dodaj anime do planera i ustaw priorytet oglądania.</div>
            
            <div class="form-group">
                <label for="planner-title"><i class="fas fa-heading"></i> Tytuł anime</label>
                <input type="text" id="planner-title" placeholder="Wpisz tytuł anime do planera">
            </div>
            <div class="form-group">
                <label for="planner-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                <input type="text" id="planner-tags" placeholder="np. akcja; dramat; fantasy">
            </div>
            
            <div class="form-group">
                <label for="planner-season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                <input type="number" id="planner-season-count" min="1" value="1">
            </div>
            <div class="form-group" id="planner-seasons-container" style="display:none;"></div>
            <div class="form-group">
                <label for="planner-total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                <input type="number" id="planner-total-episodes" min="1" value="12">
                <small style="color:var(--gray);font-size:0.85rem;margin-top:4px;display:block;">
                    <i class="fas fa-info-circle"></i> Dla anime z wieloma sezonami możesz ustawić różną długość odcinków dla każdego sezonu w polach poniżej.
                </small>
            </div>
            
            <div class="form-group">
                <label for="planner-priority"><i class="fas fa-flag"></i> Priorytet</label>
                <select id="planner-priority">
                    <option value="niski">Niski</option>
                    <option value="średni" selected>Średni</option>
                    <option value="duży">Duży</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="planner-notes"><i class="fas fa-sticky-note"></i> Notatki (opcjonalnie)</label>
                <textarea id="planner-notes" placeholder="Dodaj notatki o anime..." rows="3" style="width:100%;padding:12px 16px;background:rgba(0,0,0,0.2);border:1px solid var(--glass-border);border-radius:8px;font-size:1rem;color:var(--lighter);resize:vertical;"></textarea>
            </div>
            
            <div class="actions">
                <button type="button" id="add-to-planner" class="btn-accent"><i class="fas fa-plus"></i> Dodaj do planera</button>
            </div>
            
            <div style="margin-top:2rem;">
                <h3><i class="fas fa-list"></i> Lista planowanych anime</h3>
                <div id="planner-list">
                    <div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>
                </div>
            </div>
        </div>
        
        <div class="section" id="eksport">
            <h2><i class="fas fa-file-export"></i> Zarządzanie danymi</h2>
            <div class="actions">
                <button id="export-btn" class="btn-accent"><i class="fas fa-file-export"></i> Eksportuj dane</button>
                <button id="import-btn" class="btn-accent"><i class="fas fa-file-import"></i> Importuj dane</button>
                <input type="file" id="import-file" accept=".json" style="display: none;">
                <button id="clear-btn" class="btn-danger"><i class="fas fa-trash"></i> Wyczyść dane</button>
            </div>
        </div>
    </div>

    <button class="fab" id="scroll-top-btn" title="Przewiń do góry"><i class="fas fa-arrow-up"></i></button>

    <script>
        // --- GLOBALNE FUNKCJE ---
        function checkAnimeCompletion(anime) {
            if (anime.seasons && anime.seasons.length > 1) {
                // Dla anime z wieloma sezonami
                let totalEpisodes = 0;
                let watchedEpisodes = 0;
                anime.seasons.forEach((episodeCount, index) => {
                    totalEpisodes += episodeCount;
                    const watchedThis = Math.min(anime.watchedEpisodes - watchedEpisodes, episodeCount);
                    watchedEpisodes += watchedThis;
                });
                console.log('checkAnimeCompletion dla sezonów:', { 
                    title: anime.title, 
                    watchedEpisodes: anime.watchedEpisodes, 
                    totalEpisodes, 
                    watchedEpisodes, 
                    isCompleted: watchedEpisodes >= totalEpisodes,
                    seasons: anime.seasons
                });
                return watchedEpisodes >= totalEpisodes;
            } else {
                // Dla pojedynczego sezonu
                console.log('checkAnimeCompletion dla pojedynczego sezonu:', { 
                    title: anime.title, 
                    watchedEpisodes: anime.watchedEpisodes, 
                    totalEpisodes: anime.totalEpisodes, 
                    isCompleted: anime.watchedEpisodes >= anime.totalEpisodes 
                });
                return anime.watchedEpisodes >= anime.totalEpisodes;
            }
        }
        function checkSeasonCompletion(anime, seasonIndex) {
            if (anime.seasons && anime.seasons[seasonIndex]) {
                const seasonEpisodes = anime.seasons[seasonIndex];
                let watchedInSeason = 0;
                // Oblicz ile odcinków zostało obejrzanych w tym sezonie
                let remainingWatched = anime.watchedEpisodes;
                for (let i = 0; i < seasonIndex; i++) {
                    if (anime.seasons[i]) {
                        remainingWatched -= anime.seasons[i];
                    }
                }
                watchedInSeason = Math.max(0, Math.min(remainingWatched, seasonEpisodes));
                return watchedInSeason >= seasonEpisodes;
            }
            return false;
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Load anime list from localStorage
            let animeList = JSON.parse(localStorage.getItem('animeList')) || [];
            console.log('Initial animeList length:', animeList.length);
            console.log('Initial animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
            let plannerList = JSON.parse(localStorage.getItem('plannerList')) || [];
            let activityData = JSON.parse(localStorage.getItem('activityData')) || {};
            let activityDetails = JSON.parse(localStorage.getItem('activityDetails')) || {};
            let currentTierCategory = 'average';
            let collectionPage = 1;
            const collectionPageSize = 3;
            let showAllCollection = false;
            let currentSort = 'title';
            let currentSearch = '';
            let currentYear = new Date().getFullYear();
            
            // Form elements
            const animeForm = document.getElementById('anime-form');
            const formTitle = document.getElementById('form-title');
            const submitBtn = document.getElementById('submit-btn');
            const cancelEditBtn = document.getElementById('cancel-edit');
            const editIdInput = document.getElementById('edit-id');
            
            // Image upload elements
            const uploadBtn = document.getElementById('upload-btn');
            const imageUpload = document.getElementById('image-upload');
            const imagePreview = document.getElementById('image-preview');
            let currentImageData = null;
            
            // Rating inputs
            const ratingInputs = [
                document.getElementById('graphics'),
                document.getElementById('music'),
                document.getElementById('characters'),
                document.getElementById('story'),
                document.getElementById('fun')
            ];
            
            // Average display
            const averageDisplay = document.getElementById('average-display');
            
            // Tier category buttons
            const tierCategoryBtns = document.querySelectorAll('.tier-category-btn');
            
            // Export/Import buttons
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const clearBtn = document.getElementById('clear-btn');
            
            // Scroll to top button
            const scrollTopBtn = document.getElementById('scroll-top-btn');

            // Anime list container (przeniesione na górę)
            const animeListContainer = document.getElementById('anime-list');
            
            // Format time function
            function formatTime(minutes, format = 'hours') {
                const hours = minutes / 60;
                const days = hours / 24;
                const months = days / 30;
                const years = days / 365;
                
                switch(format) {
                    case 'hours':
                        const roundedHours = Math.round(hours * 10) / 10;
                        return roundedHours % 1 === 0 ? `${roundedHours}h` : `${roundedHours.toFixed(1)}h`;
                    case 'days':
                        return `${Math.round(days * 10) / 10}d`;
                    case 'months':
                        return `${Math.round(months * 10) / 10}m`;
                    case 'years':
                        return `${Math.round(years * 10) / 10}y`;
                    default:
                        const h = Math.floor(minutes / 60);
                        const m = minutes % 60;
                        return `${h}h ${m}m`;
                }
            }
            
            // Funkcja do formatowania dat
            function formatDate(dateString) {
                if (!dateString) return '';
                const date = new Date(dateString);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (date.toDateString() === today.toDateString()) {
                    return 'Dzisiaj';
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return 'Wczoraj';
                } else {
                    return date.toLocaleDateString('pl-PL');
                }
            }

            // Obsługa pokazywania/ukrywania pola daty ukończenia
            const statusSelect = document.getElementById('status');
            const completedDateGroup = document.getElementById('completed-date-group');
            const completedDateInput = document.getElementById('completed-date');

            function toggleCompletedDateField() {
                if (statusSelect.value === 'completed') {
                    completedDateGroup.style.display = '';
                } else {
                    completedDateGroup.style.display = 'none';
                    completedDateInput.value = '';
                }
            }

            statusSelect.addEventListener('change', toggleCompletedDateField);
            // Wywołaj na początku, żeby ustawić początkowy stan
            toggleCompletedDateField();

            // Calculate average rating
            function calculateAverage() {
                let sum = 0;
                let count = 0;
                
                ratingInputs.forEach(input => {
                    const value = parseInt(input.value);
                    if (!isNaN(value) && value >= 1 && value <= 11) {
                        sum += value;
                        count++;
                    }
                });
                
                const average = count > 0 ? Math.round(sum / count) : 0;
                averageDisplay.textContent = average;
                return average;
            }
            
            // Update average when any rating changes
            ratingInputs.forEach(input => {
                input.addEventListener('change', calculateAverage);
                input.addEventListener('input', calculateAverage);
            });
            
            // Obsługa zdjęć anime
            uploadBtn.addEventListener('click', function() {
                imageUpload.value = '';
                imageUpload.click();
            });

            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!file.type.startsWith('image/')) {
                    showNotification('Proszę wybrać plik obrazu!', 'danger');
                    imageUpload.value = '';
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(ev) {
                    currentImageData = ev.target.result;
                    showImagePreview(currentImageData);
                };
                reader.readAsDataURL(file);
            });

            function showImagePreview(imageData) {
                imagePreview.innerHTML = `
                    <img src="${imageData}" alt="Podgląd obrazka">
                `;
            }

            function showImagePlaceholder() {
                imagePreview.innerHTML = `
                    <div class="image-preview-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Brak wybranego obrazka</span>
                    </div>
                `;
            }

            function resetImageUpload() {
                currentImageData = null;
                showImagePlaceholder();
                imageUpload.value = '';
            }

            // Form submission
            animeForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                const title = document.getElementById('title').value.trim();
                if (!title) {
                    alert('Proszę wprowadzić tytuł anime');
                    return;
                }
                
                const status = document.getElementById('status').value;
                const seasonCount = parseInt(document.getElementById('season-count').value);
                console.log('Debug - seasonCount from form:', seasonCount);
                console.log('Debug - season-count element value:', document.getElementById('season-count').value);
                let seasons = [];
                let seasonRewatches = [];
                let seasonEpisodeLengths = [];
                let seasonCompletedDates = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#seasons-container .season-episodes');
                    const rewatchInputs = document.querySelectorAll('#seasons-container .season-rewatch');
                    const episodeLengthInputs = document.querySelectorAll('#seasons-container .season-episode-length');
                    const seasonDateInputs = document.querySelectorAll('#seasons-container .season-completed-date');
                    
                    console.log('Debug - seasonCount:', seasonCount);
                    console.log('Debug - seasonInputs found:', seasonInputs.length);
                    
                    seasonInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                        console.log(`Debug - Season ${index + 1}: ${input.value} -> ${isNaN(v) ? 0 : v}`);
                    });
                    rewatchInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonRewatches.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach((input, index) => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v); // domyślnie 24 minuty
                    });
                    seasonDateInputs.forEach((input, index) => {
                        const date = input.value;
                        seasonCompletedDates.push(date || null);
                    });
                    
                    console.log('Debug - seasons array:', seasons);
                    console.log('Debug - seasonRewatches array:', seasonRewatches);
                    console.log('Debug - seasonEpisodeLengths array:', seasonEpisodeLengths);
                }
                const totalEpisodes = parseInt(document.getElementById('total-episodes').value) || 12;
                const episodeLength = parseInt(document.getElementById('episode-length').value) || 24;
                const watchedEpisodes = parseInt(document.getElementById('watched-episodes').value) || 0;
                const graphics = parseInt(document.getElementById('graphics').value);
                const music = parseInt(document.getElementById('music').value);
                const characters = parseInt(document.getElementById('characters').value);
                const story = parseInt(document.getElementById('story').value);
                const fun = parseInt(document.getElementById('fun').value);
                const averageRating = calculateAverage();
                
                const tagsRaw = document.getElementById('anime-tags').value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                
                const animeData = {
                    id: editIdInput.value ? parseInt(editIdInput.value) : Date.now(),
                    title,
                    status,
                    totalEpisodes,
                    episodeLength,
                    watchedEpisodes,
                    ratings: {
                        graphics,
                        music,
                        characters,
                        story,
                        fun
                    },
                    averageRating,
                    createdAt: new Date().toISOString(),
                    tags
                };

                // Dodaj datę ukończenia jeśli status to 'completed'
                if (status === 'completed') {
                    const completedDate = document.getElementById('completed-date').value;
                    animeData.completedDate = completedDate || null;
                }
                
                if (seasons.length > 1) {
                    animeData.seasons = seasons;
                    animeData.seasonRewatches = seasonRewatches;
                    animeData.seasonEpisodeLengths = seasonEpisodeLengths;
                    animeData.seasonCompletedDates = seasonCompletedDates;
                    console.log('Debug - animeData with seasons:', {
                        title: animeData.title,
                        seasons: animeData.seasons,
                        seasonRewatches: animeData.seasonRewatches,
                        seasonEpisodeLengths: animeData.seasonEpisodeLengths
                    });
                }
                
                // Add image data if available
                if (currentImageData) {
                    animeData.image = currentImageData;
                } else if (editIdInput.value) {
                    // If editing and no new image selected, keep the existing one
                    const existingAnime = animeList.find(a => a.id === parseInt(editIdInput.value));
                    if (existingAnime && existingAnime.image) {
                        animeData.image = existingAnime.image;
                    }
                }
                
                if (editIdInput.value) {
                    // Update existing anime
                    const index = animeList.findIndex(a => a.id === animeData.id);
                    if (index !== -1) {
                        const oldAnime = animeList[index];
                        animeList[index] = animeData;
                        
                        // Jeśli status zmienił się na 'completed' i nie ma daty ukończenia, dodaj ją
                        // if (animeData.status === 'completed' && !animeData.completedDate) {
                        //     animeData.completedDate = new Date().toISOString().split('T')[0];
                        // }
                    }
                    cancelEdit();
                } else {
                    // Add new anime
                    // Nie ustawiamy dat dla nowych anime - tylko przy zwiększaniu aktywności
                    animeList.push(animeData);
                    
                    // If adding new anime with image, refresh the page
                    if (currentImageData) {
                        saveAnimeList();
                        window.location.reload();
                        return;
                    }
                }
                
                // Sort by title
                animeList.sort((a, b) => a.title.localeCompare(b.title));
                
                console.log('Przed saveAnimeList (form submit) - animeList length:', animeList.length);
                saveAnimeList();
                console.log('Po saveAnimeList (form submit) - animeList length:', animeList.length);
                renderAnimeList();
                renderTierList();
                updateProfileStats();
                
                // Reset form (except when editing)
                if (!editIdInput.value) {
                    animeForm.reset();
                                    document.getElementById('total-episodes').value = 12;
                document.getElementById('episode-length').value = 24;
                document.getElementById('watched-episodes').value = 0;
                document.getElementById('season-count').value = 1;
                document.getElementById('graphics').value = 5;
                document.getElementById('music').value = 5;
                document.getElementById('characters').value = 5;
                document.getElementById('story').value = 5;
                document.getElementById('fun').value = 5;
                calculateAverage();
                    
                    // Clear image
                    resetImageUpload();
                    
                    // Reset seasons container
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                    
                    // Show success notification
                    showNotification('Anime zostało dodane!', 'success');
                } else {
                    showNotification('Zmiany zostały zapisane!', 'success');
                }
            });
            

            
            // Cancel edit
            cancelEditBtn.addEventListener('click', cancelEdit);
            
            function cancelEdit() {
                editIdInput.value = '';
                formTitle.innerHTML = '<i class="fas fa-plus-circle"></i> Dodaj nowe anime';
                submitBtn.innerHTML = '<i class="fas fa-plus"></i> Dodaj anime';
                cancelEditBtn.style.display = 'none';
                animeForm.reset();
                document.getElementById('total-episodes').value = 12;
                document.getElementById('episode-length').value = 24;
                document.getElementById('watched-episodes').value = 0;
                document.getElementById('season-count').value = 1;
                document.getElementById('graphics').value = 5;
                document.getElementById('music').value = 5;
                document.getElementById('characters').value = 5;
                document.getElementById('story').value = 5;
                document.getElementById('fun').value = 5;
                document.getElementById('completed-date').value = '';
                toggleCompletedDateField();
                calculateAverage();
                // Clear image
                resetImageUpload();
                // Reset seasons container
                seasonsContainer.innerHTML = '';
                seasonsContainer.style.display = 'none';
                totalEpisodesInput.readOnly = false;
            }
            
            // Save anime list to localStorage
            function saveAnimeList() {
                console.log('saveAnimeList - animeList length:', animeList.length);
                console.log('saveAnimeList - animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
                localStorage.setItem('animeList', JSON.stringify(animeList));
            }
            
            // Save planner list to localStorage
            function savePlannerList() {
                localStorage.setItem('plannerList', JSON.stringify(plannerList));
            }
            
            // Update profile statistics
            function updateProfileStats() {
                console.log('updateProfileStats - animeList length:', animeList.length);
                console.log('updateProfileStats - animeList:', animeList.map(a => ({ id: a.id, title: a.title, status: a.status })));
                
                const completedAnime = animeList.filter(a => a.status === 'completed');
                const watchingAnime = animeList.filter(a => a.status === 'watching');
                const ratedAnime = animeList.filter(a => a.status !== 'upcoming');
                const upcomingAnime = animeList.filter(a => a.status === 'upcoming');
                const allAnime = animeList;
                
                // Total completed anime
                document.getElementById('total-completed').textContent = completedAnime.length;
                document.getElementById('total-upcoming').textContent = plannerList.length;
                document.getElementById('total-watching').textContent = watchingAnime.length;
                document.getElementById('total-all').textContent = allAnime.length;

                // Calculate average rating
                const ratedAnimeForAvg = animeList.filter(a => a.averageRating > 0);
                let averageRating = 0;
                if (ratedAnimeForAvg.length > 0) {
                    const totalRating = ratedAnimeForAvg.reduce((sum, anime) => sum + anime.averageRating, 0);
                    averageRating = Math.round((totalRating / ratedAnimeForAvg.length) * 10) / 10; // Zaokrąglenie do 1 miejsca po przecinku
                }
                
                // Update average rating display
                document.getElementById('average-rating').textContent = averageRating.toFixed(1);
                const averageRatingBar = document.getElementById('average-rating-bar');
                const percentage = (averageRating / 11) * 100; // 11 to maksymalna ocena
                averageRatingBar.style.width = percentage + '%';

                // Calculate watch progress
                const totalEpisodes = animeList.reduce((sum, anime) => sum + anime.totalEpisodes, 0);
                const watchedEpisodes = animeList.reduce((sum, anime) => {
                    if (anime.status === 'completed') {
                        return sum + anime.totalEpisodes;
                    } else {
                        return sum + anime.watchedEpisodes;
                    }
                }, 0);
                
                const watchProgress = totalEpisodes > 0 ? Math.round((watchedEpisodes / totalEpisodes) * 100) : 0;
                document.getElementById('watch-progress').textContent = watchProgress + '%';
                const watchProgressBar = document.getElementById('watch-progress-bar');
                watchProgressBar.style.width = watchProgress + '%';

                
                // Total watch time (including rewatches)
                let totalMinutes = 0;
                let totalRewatchMinutes = 0;
                
                animeList.forEach(anime => {
                    let animeTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            animeTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        animeTime = watchedEpisodes * anime.episodeLength;
                    }
                    
                    totalMinutes += animeTime;
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((rewatchCount, index) => {
                            if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                totalRewatchMinutes += rewatchCount * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych
                        totalRewatchMinutes += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                });

                const totalTimeElement = document.getElementById('total-time');
                let timeFormat = localStorage.getItem('timeFormat') || 'hours';
                
                totalTimeElement.textContent = formatTime(totalMinutes + totalRewatchMinutes, timeFormat);
                totalTimeElement.title = `Podstawowy czas: ${formatTime(totalMinutes)}\nRewatche: ${formatTime(totalRewatchMinutes)}`;
                totalTimeElement.dataset.minutes = totalMinutes + totalRewatchMinutes;
                
                // Kliknięcie na kafelki statystyk - przewijanie do odpowiednich sekcji
                const statsCards = document.querySelectorAll('#profile-stats .stat-card');
                
                // Ocena ogólna - pokazuje szczegółowe statystyki ocen
                if (statsCards[0]) {
                    statsCards[0].classList.add('clickable');
                    statsCards[0].title = 'Kliknij, aby zobaczyć szczegółowe statystyki ocen';
                    statsCards[0].addEventListener('click', function() {
                        renderRatingBreakdown();
                    });
                }
                
                // Czas oglądania - pokazuje szczegółowy breakdown
                if (statsCards[1]) {
                    statsCards[1].classList.add('clickable');
                    statsCards[1].title = 'Kliknij, aby zobaczyć szczegółowy breakdown czasu oglądania';
                    statsCards[1].addEventListener('click', function() {
                        renderTimeBreakdown();
                    });
                }

                // Obejrzane - pokazuje listę obejrzanych anime
                if (statsCards[2]) {
                    statsCards[2].classList.add('clickable');
                    statsCards[2].title = 'Kliknij, aby zobaczyć listę obejrzanych anime';
                    statsCards[2].addEventListener('click', function() {
                        renderProfileAnimeList('completed');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Planowane - pokazuje listę planowanych anime
                if (statsCards[3]) {
                    statsCards[3].classList.add('clickable');
                    statsCards[3].title = 'Kliknij, aby zobaczyć listę planowanych anime';
                    statsCards[3].addEventListener('click', function() {
                        renderProfileAnimeList('upcoming');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Oglądane - pokazuje listę oglądanych anime
                if (statsCards[4]) {
                    statsCards[4].classList.add('clickable');
                    statsCards[4].title = 'Kliknij, aby zobaczyć listę oglądanych anime';
                    statsCards[4].addEventListener('click', function() {
                        renderProfileAnimeList('watching');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Wszystkie - pokazuje wszystkie anime
                if (statsCards[5]) {
                    statsCards[5].classList.add('clickable');
                    statsCards[5].title = 'Kliknij, aby zobaczyć wszystkie anime';
                    statsCards[5].addEventListener('click', function() {
                        renderProfileAnimeList('all');
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }
                
                // Postęp - pokazuje listę anime z postępem
                if (statsCards[6]) {
                    statsCards[6].classList.add('clickable');
                    statsCards[6].title = 'Kliknij, aby zobaczyć postęp oglądania';
                    statsCards[6].addEventListener('click', function() {
                        renderProgressBreakdown();
                        // Przewiń do miejsca gdzie się otwiera lista
                        setTimeout(() => {
                            document.getElementById('profile-anime-list').scrollIntoView({ behavior: 'smooth' });
                        }, 100);
                    });
                }

                // Oblicz watch streak
                const currentStreak = getCurrentStreak();
                const longestStreakData = getLongestStreak();
                
                // Aktualizuj wyświetlanie streaku
                document.getElementById('current-streak').textContent = currentStreak === 1 ? `${currentStreak} dzień` : `${currentStreak} dni`;
                document.getElementById('longest-streak').textContent = longestStreakData.length === 1 ? `${longestStreakData.length} dzień` : `${longestStreakData.length} dni`;
                
                // Dodaj tooltip z datami najdłuższego streaku
                const streakCard = document.getElementById('watch-streak-card');
                if (longestStreakData.length > 0 && longestStreakData.startDate && longestStreakData.endDate) {
                    const startDate = new Date(longestStreakData.startDate).toLocaleDateString('pl-PL');
                    const endDate = new Date(longestStreakData.endDate).toLocaleDateString('pl-PL');
                    streakCard.title = `Najdłuższy streak: ${longestStreakData.length} dni\nOd: ${startDate}\nDo: ${endDate}`;
                } else {
                    streakCard.title = 'Brak historii oglądania';
                }

                // Renderuj statystyki tagów
                renderTagsStats();
            }

            // Statystyki tagów na profilu
            function renderTagsStats() {
                const container = document.getElementById('profile-tags-stats');
                if (!animeList.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                // Zbierz wszystkie tagi
                const tagMap = {};
                animeList.forEach(anime => {
                    if (anime.tags && Array.isArray(anime.tags)) {
                        anime.tags.forEach(tag => {
                            if (!tagMap[tag]) tagMap[tag] = {count:0, totalMinutes:0, ratings:[], animeCount:0};
                            tagMap[tag].animeCount++;
                            // Czas oglądania
                            let animeTime = 0;
                            
                            if (anime.seasons && anime.seasons.length > 1) {
                                // Oblicz czas dla każdego sezonu osobno
                                let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                anime.seasons.forEach((episodeCount, index) => {
                                    const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                                    const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                        ? anime.seasonEpisodeLengths[index] 
                                        : anime.episodeLength;
                                    animeTime += watchedThis * episodeLength;
                                    watched -= watchedThis;
                                });
                            } else {
                                const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                                animeTime = watchedEpisodes * anime.episodeLength;
                            }
                            
                            // Rewatche
                            if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                                anime.seasonRewatches.forEach((rewatchCount, index) => {
                                    if (rewatchCount > 0 && anime.seasons && anime.seasons[index]) {
                                        const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                            ? anime.seasonEpisodeLengths[index] 
                                            : anime.episodeLength;
                                        animeTime += rewatchCount * anime.seasons[index] * episodeLength;
                                    }
                                });
                            } else if (anime.rewatchCount) {
                                animeTime += anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                            }
                            tagMap[tag].totalMinutes += animeTime;
                            tagMap[tag].ratings.push(anime.averageRating);
                        });
                    }
                });
                const tags = Object.keys(tagMap).sort((a,b)=>a.localeCompare(b));
                if (!tags.length) {
                    container.innerHTML = '<div style="color:var(--gray);text-align:center;">Brak tagów do wyświetlenia</div>';
                    return;
                }
                let html = `<h3 style='margin-bottom:1rem;'><i class="fas fa-tags"></i> Statystyki tagów</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tag</th>
                    <th style='text-align:left;padding:8px 4px;'>Liczba anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Czas łącznie</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                tags.forEach(tag => {
                    const t = tagMap[tag];
                    const avg = t.ratings.length ? (t.ratings.reduce((a,b)=>a+b,0)/t.ratings.length).toFixed(2) : '-';
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;'><span class='anime-tag tag-clickable' data-tag="${encodeURIComponent(tag)}">${tag}</span></td>
                        <td style='padding:8px 4px;'>${t.animeCount}</td>
                        <td style='padding:8px 4px;'>${formatTime(t.totalMinutes)}</td>
                        <td style='padding:8px 4px;'>${avg}</td>
                    </tr>`;
                });
                html += `</tbody></table></div>`;
                container.innerHTML = html;

                // Dodaj obsługę kliknięcia na tag
                container.querySelectorAll('.tag-clickable').forEach(el => {
                    el.style.cursor = 'pointer';
                    el.title = 'Pokaż anime z tym tagiem';
                    el.addEventListener('click', function(e) {
                        const tag = decodeURIComponent(this.dataset.tag);
                        renderProfileAnimeListByTag(tag);
                    });
                });
            }
            

            
            // Render anime list
            function renderAnimeList() {
                let sortedList = [...animeList];
                // Filtrowanie po wyszukiwaniu
                if (currentSearch.trim() !== '') {
                    const searchLower = currentSearch.trim().toLowerCase();
                    // Obsługa wyszukiwania po tagach: tag:nazwa
                    const tagMatch = searchLower.match(/^tag:(.+)$/);
                    if (tagMatch) {
                        const tagQuery = tagMatch[1].trim();
                        sortedList = sortedList.filter(anime => anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(tagQuery)));
                    } else {
                        sortedList = sortedList.filter(anime =>
                            anime.title.toLowerCase().includes(searchLower)
                            || (anime.status && anime.status.toLowerCase().includes(searchLower))
                            || (anime.ratings && Object.values(anime.ratings).some(val => (val+''||'').includes(searchLower)))
                            || (anime.averageRating+''||'').includes(searchLower)
                            || (anime.tags && anime.tags.some(tag => tag.toLowerCase().includes(searchLower)))
                        );
                    }
                }
                // Sortowanie
                switch(currentSort) {
                    case 'averageRating':
                        sortedList.sort((a, b) => b.averageRating - a.averageRating || a.title.localeCompare(b.title));
                        break;
                    case 'graphics':
                        sortedList.sort((a, b) => b.ratings.graphics - a.ratings.graphics || a.title.localeCompare(b.title));
                        break;
                    case 'music':
                        sortedList.sort((a, b) => b.ratings.music - a.ratings.music || a.title.localeCompare(b.title));
                        break;
                    case 'characters':
                        sortedList.sort((a, b) => b.ratings.characters - a.ratings.characters || a.title.localeCompare(b.title));
                        break;
                    case 'story':
                        sortedList.sort((a, b) => b.ratings.story - a.ratings.story || a.title.localeCompare(b.title));
                        break;
                    case 'fun':
                        sortedList.sort((a, b) => b.ratings.fun - a.ratings.fun || a.title.localeCompare(b.title));
                        break;
                    case 'title':
                    default:
                        sortedList.sort((a, b) => a.title.localeCompare(b.title));
                        break;
                }
                // Paginacja
                let toShow;
                if (showAllCollection) {
                    toShow = sortedList;
                } else {
                    toShow = sortedList.slice(0, collectionPage * collectionPageSize);
                }
                if (sortedList.length === 0) {
                    animeListContainer.innerHTML = '<div class="no-anime">Nie znaleziono anime.' + (currentSearch ? ' Spróbuj innego hasła.' : ' Dodaj pierwsze używając formularza powyżej!') + '</div>';
                    document.getElementById('collection-controls').innerHTML = '';
                    return;
                }
                animeListContainer.innerHTML = '';
                toShow.forEach(anime => {
                    const animeCard = document.createElement('div');
                    animeCard.className = 'anime-card';
                    animeCard.dataset.id = anime.id;
                    
                    // Ustawianie tła tylko jeśli jest zdjęcie
                    if (anime.image) {
                        animeCard.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(${anime.image})`;
                        animeCard.style.backgroundSize = 'cover';
                        animeCard.style.backgroundPosition = 'center';
                    } else {
                        animeCard.style.backgroundImage = '';
                        animeCard.style.background = '';
                    }
                    
                    let statusClass = '';
                    let statusText = '';
                    
                    switch(anime.status) {
                        case 'watching':
                            statusClass = 'status-watching';
                            statusText = 'Oglądane';
                            break;
                        case 'completed':
                            statusClass = 'status-completed';
                            statusText = 'Obejrzane';
                            break;
                        case 'upcoming':
                            statusClass = 'status-upcoming';
                            statusText = 'Nadchodzące';
                            break;
                    }
                    
                    // Add status class to anime card for colored top bar
                    animeCard.className = `anime-card ${statusClass}`;
                    
                    // Calculate watch progress
                    const watchProgress = anime.status === 'completed' ? 100 : 
                                        Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    
                    // Calculate watch time (including rewatches)
                    let mainTime = 0;
                    let rewatchTime = 0;
                    let rewatchCount = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        mainTime = anime.watchedEpisodes * anime.episodeLength;
                    }
                    
                    // Licz rewatchy z sezonów jeśli są dostępne
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                                rewatchCount += count;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        // Fallback dla starych danych - rewatchCount to liczba odcinków, nie liczba pełnych rewatchów
                        rewatchTime = anime.rewatchCount * anime.episodeLength;
                        rewatchCount = anime.rewatchCount;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    let episodesText = `${anime.watchedEpisodes}/${anime.totalEpisodes} (${watchProgress}%)`;
                    if (anime.rewatchCount && anime.rewatchCount > 0) {
                        episodesText += ` <span class="rewatch-info">(+${anime.rewatchCount} rewatch)</span>`;
                    }
                    let seasonsProgressHtml = '';
                    let hasSeasons = anime.seasons && anime.seasons.length > 1;
                    if (hasSeasons) {
                        // Przygotuj HTML z progressem sezonów (ukryty domyślnie)
                        let watched = anime.watchedEpisodes;
                        seasonsProgressHtml = `<div class='seasons-progress' id='seasons-progress-${anime.id}' style='display:none;margin-top:8px;transition:max-height 0.3s;overflow:hidden;'>`;
                        anime.seasons.forEach((count, idx) => {
                            let watchedThis = Math.max(0, Math.min(watched, count));
                            let percent = Math.round((watchedThis/count)*100);
                            let rewatchInfo = '';
                            if (anime.seasonRewatches && anime.seasonRewatches[idx] > 0) {
                                rewatchInfo = ` <span style='color:var(--primary);font-size:0.8em;'>(+${anime.seasonRewatches[idx]}x rewatch)</span>`;
                            }
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[idx] 
                                ? anime.seasonEpisodeLengths[idx] 
                                : anime.episodeLength;
                            
                            // Sprawdź czy sezon został ukończony i dodaj datę
                            let completionInfo = '';
                            if (checkSeasonCompletion(anime, idx) && anime.lastWatchedDate) {
                                completionInfo = ` <span style='color:var(--success);font-size:0.8em;' title="Automatycznie ustawione przy ukończeniu sezonu - zwiększ aktywność aby zobaczyć datę">✓ Ukończono ${formatDate(anime.lastWatchedDate)}</span>`;
                            }
                            // Sprawdź czy jest ręcznie ustawiona data ukończenia sezonu
                            if (anime.seasonCompletedDates && anime.seasonCompletedDates[idx]) {
                                completionInfo = ` <span style='color:var(--accent);font-size:0.8em;' title="Ręcznie ustawiona data ukończenia sezonu">✓ Ukończono ręcznie: ${formatDate(anime.seasonCompletedDates[idx])}</span>`;
                            }
                            
                            seasonsProgressHtml += `<div>Sezon ${idx+1}: ${watchedThis}/${count} (${percent}%) - ${episodeLength}min${rewatchInfo}${completionInfo}</div>`;
                            watched -= watchedThis;
                        });
                        seasonsProgressHtml += `</div>`;
                    }
                    
                    let tagHtml = '';
                    if (anime.tags && anime.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${anime.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    animeCard.innerHTML = `
                        <div class="anime-title">${anime.title}</div>
                        <span class="anime-status ${statusClass}">${statusText}</span>
                        ${tagHtml}
                        <div class="rating-container odcinki-row" data-id="${anime.id}" style="cursor:${hasSeasons ? 'pointer' : 'default'};">
                            <span class="rating-label">Odcinki:</span>
                            <span class="rating-value">${episodesText}${hasSeasons ? " <span style=\"font-size:0.8em;opacity:0.7;\">(kliknij)</span>" : ''}</span>
                        </div>
                        ${seasonsProgressHtml}
                        
                        <div class="rating-container">
                            <span class="rating-label">Czas:</span>
                            <span class="tooltip rating-value time-display" 
                                  title="Podstawowy: ${formatTime(mainTime)}\n${rewatchCount > 0 ? `Rewatch: ${formatTime(rewatchTime)}` : ''}">
                                ${formatTime(totalTime, 'hours')}
                                ${rewatchCount > 0 ? `<span class="rewatch-info">(${rewatchCount}x rewatch)</span>` : ''}
                            </span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Grafika:</span>
                            <span class="rating-value">${anime.ratings.graphics}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Muzyka:</span>
                            <span class="rating-value">${anime.ratings.music}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Postacie:</span>
                            <span class="rating-value">${anime.ratings.characters}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Fabuła:</span>
                            <span class="rating-value">${anime.ratings.story}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Śmieszność:</span>
                            <span class="rating-value">${anime.ratings.fun}</span>
                        </div>
                        
                        <div class="rating-container">
                            <span class="rating-label">Średnia:</span>
                            <span class="rating-value">${anime.averageRating}</span>
                        </div>
                        
                        ${anime.completedDate ? `
                        <div class="rating-container">
                            <span class="rating-label">Ukończono:</span>
                            <span class="rating-value tooltip" title="${anime.completedDate ? 'Data ukończenia anime' : 'Automatycznie ustawione przy ukończeniu anime'}">${formatDate(anime.completedDate)}</span>
                        </div>
                        ` : ''}
                        
                        ${anime.lastWatchedDate ? `
                        <div class="rating-container">
                            <span class="rating-label">Ostatnio oglądano:</span>
                            <span class="rating-value tooltip" title="Aktualizowane przy zwiększaniu aktywności - kliknij przycisk + aby dodać odcinki">${formatDate(anime.lastWatchedDate)}</span>
                        </div>
                        ` : ''}
                        
                        ${anime.completedDate || anime.lastWatchedDate ? `
                        <div style="margin-top:8px;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid var(--primary);">
                            <small style="color:var(--gray);font-size:0.8rem;">
                                <i class="fas fa-info-circle"></i> Daty są automatycznie śledzone przy zwiększaniu aktywności
                            </small>
                        </div>
                        ` : ''}
                        
                        <div class="actions">
                            <button class="add-episodes-btn btn-success" data-id="${anime.id}" title="Dodaj odcinki">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button class="edit-btn" data-id="${anime.id}"><i class="fas fa-edit"></i> Edytuj</button>
                            <button class="delete-btn btn-danger" data-id="${anime.id}"><i class="fas fa-trash"></i> Usuń</button>
                        </div>
                    `;
                    
                    // NIE dodaję podglądu obrazka ani przycisku usuwania zdjęcia
                    animeListContainer.appendChild(animeCard);
                });
                
                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        if (confirm('Czy na pewno chcesz usunąć to anime z listy?')) {
                            const id = parseInt(this.dataset.id);
                            animeList = animeList.filter(anime => anime.id !== id);
                            saveAnimeList();
                            renderAnimeList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Anime zostało usunięte!', 'danger');
                        }
                    });
                });
                
                            // Add event listeners for add episodes buttons
            document.querySelectorAll('.add-episodes-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.dataset.id);
                    showEpisodeModal(id);
                });
            });
            
            // Funkcja do sprawdzania czy anime zostało ukończone
            function checkAnimeCompletion(anime) {
                if (anime.seasons && anime.seasons.length > 1) {
                    // Dla anime z wieloma sezonami
                    let totalEpisodes = 0;
                    let watchedEpisodes = 0;
                    anime.seasons.forEach((episodeCount, index) => {
                        totalEpisodes += episodeCount;
                        const watchedThis = Math.min(anime.watchedEpisodes - watchedEpisodes, episodeCount);
                        watchedEpisodes += watchedThis;
                    });
                    console.log('checkAnimeCompletion dla sezonów:', { 
                        title: anime.title, 
                        watchedEpisodes: anime.watchedEpisodes, 
                        totalEpisodes, 
                        watchedEpisodes, 
                        isCompleted: watchedEpisodes >= totalEpisodes,
                        seasons: anime.seasons
                    });
                    return watchedEpisodes >= totalEpisodes;
                } else {
                    // Dla pojedynczego sezonu
                    console.log('checkAnimeCompletion dla pojedynczego sezonu:', { 
                        title: anime.title, 
                        watchedEpisodes: anime.watchedEpisodes, 
                        totalEpisodes: anime.totalEpisodes, 
                        isCompleted: anime.watchedEpisodes >= anime.totalEpisodes 
                    });
                    return anime.watchedEpisodes >= anime.totalEpisodes;
                }
            }
            
            // Funkcja do sprawdzania czy konkretny sezon został ukończony
            function checkSeasonCompletion(anime, seasonIndex) {
                if (anime.seasons && anime.seasons[seasonIndex]) {
                    const seasonEpisodes = anime.seasons[seasonIndex];
                    let watchedInSeason = 0;
                    
                    // Oblicz ile odcinków zostało obejrzanych w tym sezonie
                    let remainingWatched = anime.watchedEpisodes;
                    for (let i = 0; i < seasonIndex; i++) {
                        if (anime.seasons[i]) {
                            remainingWatched -= anime.seasons[i];
                        }
                    }
                    watchedInSeason = Math.max(0, Math.min(remainingWatched, seasonEpisodes));
                    
                    return watchedInSeason >= seasonEpisodes;
                }
                return false;
            }
            

                
                // Add event listeners for edit buttons
                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        showEditAnimeModal(id);
                    });
                });

                // Paginacja - pokaż przycisk "Załaduj więcej" jeśli są jeszcze anime do załadowania
                const collectionControls = document.getElementById('collection-controls');
                if (sortedList.length > collectionPage * collectionPageSize) {
                    collectionControls.innerHTML = `<button id="load-more-btn" class="btn-accent"><i class="fas fa-plus"></i> Załaduj więcej (${sortedList.length - (collectionPage * collectionPageSize)} pozostałych)</button>`;
                } else {
                    collectionControls.innerHTML = '';
                }
                const loadMoreBtn = document.getElementById('load-more-btn');
                if (loadMoreBtn) {
                    loadMoreBtn.onclick = function() {
                        collectionPage++;
                        renderAnimeList();
                    };
                }

                // Dodaj event listener na animeListContainer
                animeListContainer.addEventListener('click', function(event) {
                    const target = event.target;
                    if (target.classList.contains('rating-value')) {
                        const row = target.closest('.odcinki-row');
                        const id = parseInt(row.dataset.id);
                        const anime = animeList.find(a => a.id === id);
                        if (anime && anime.seasons && anime.seasons.length > 1) {
                            const seasonsProgress = document.getElementById(`seasons-progress-${id}`);
                            if (seasonsProgress) {
                                seasonsProgress.style.display = seasonsProgress.style.display === 'none' ? 'block' : 'none';
                            }
                        }
                    }
                });
            }
            
            // Render tier list
            function renderTierList() {
                // Clear all tiers
                document.getElementById('tier-SSS').innerHTML = '';
                document.getElementById('tier-SS').innerHTML = '';
                document.getElementById('tier-S').innerHTML = '';
                document.getElementById('tier-A').innerHTML = '';
                document.getElementById('tier-B').innerHTML = '';
                document.getElementById('tier-C').innerHTML = '';
                document.getElementById('tier-D').innerHTML = '';
                document.getElementById('tier-F').innerHTML = '';
                
                animeList.forEach(anime => {
                    const tierItem = document.createElement('div');
                    tierItem.className = 'tier-item';
                    tierItem.textContent = anime.title;
                    tierItem.dataset.animeId = anime.id;
                    tierItem.style.cursor = 'pointer';
                    tierItem.title = `Kliknij aby zobaczyć szczegóły\nŚrednia: ${anime.averageRating}`;
                    
                    // Determine which tier to place the anime in based on current category
                    let rating;
                    if (currentTierCategory === 'average') {
                        rating = anime.averageRating;
                    } else {
                        rating = anime.ratings[currentTierCategory];
                    }
                    
                    if (rating === 11) {
                        tierItem.dataset.tier = 'SSS';
                        document.getElementById('tier-SSS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 10) {
                        tierItem.dataset.tier = 'SS';
                        document.getElementById('tier-SS').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 9) {
                        tierItem.dataset.tier = 'S';
                        document.getElementById('tier-S').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 8) {
                        tierItem.dataset.tier = 'A';
                        document.getElementById('tier-A').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 6 && rating <= 7) {
                        tierItem.dataset.tier = 'B';
                        document.getElementById('tier-B').appendChild(tierItem.cloneNode(true));
                    } else if (rating === 5) {
                        tierItem.dataset.tier = 'C';
                        document.getElementById('tier-C').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 3 && rating <= 4) {
                        tierItem.dataset.tier = 'D';
                        document.getElementById('tier-D').appendChild(tierItem.cloneNode(true));
                    } else if (rating >= 1 && rating <= 2) {
                        tierItem.dataset.tier = 'F';
                        document.getElementById('tier-F').appendChild(tierItem.cloneNode(true));
                    }
                });

                // Add click event listeners to tier items
                document.querySelectorAll('.tier-item').forEach(tierItem => {
                    tierItem.addEventListener('click', function() {
                        const animeId = parseInt(this.dataset.animeId);
                        if (animeId) {
                            showAnimeDetailsModal(animeId);
                        }
                    });
                });
            }
            
            // Render planner list
            function renderPlannerList() {
                const plannerContainer = document.getElementById('planner-list');
                
                if (plannerList.length === 0) {
                    plannerContainer.innerHTML = '<div class="no-anime">Brak anime w planerze. Dodaj pierwsze używając formularza powyżej!</div>';
                    return;
                }
                
                // Sort by priority (duży -> średni -> niski)
                const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                const sortedPlanner = [...plannerList].sort((a, b) => {
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                });
                
                plannerContainer.innerHTML = '';
                
                sortedPlanner.forEach(item => {
                    const plannerCard = document.createElement('div');
                    plannerCard.className = 'planner-card';
                    plannerCard.dataset.id = item.id;
                    
                    let notesHtml = '';
                    if (item.notes && item.notes.trim()) {
                        notesHtml = `<div class="planner-notes"><i class="fas fa-sticky-note"></i> ${item.notes}</div>`;
                    }
                    
                    let tagHtml = '';
                    if (item.tags && item.tags.length) {
                        tagHtml = `<div style='margin:8px 0 0 0;display:flex;flex-wrap:wrap;gap:6px;'>${item.tags.map(tag => `<span class='anime-tag'>${tag}</span>`).join('')}</div>`;
                    }
                    
                    plannerCard.innerHTML = `
                        <div class="anime-title">${item.title}</div>
                        ${tagHtml}
                        <span class="priority-badge priority-${item.priority}">Priorytet: ${item.priority}</span>
                        <div style="margin-bottom:8px;color:var(--gray);font-size:0.95em;">
                            ${item.seasonCount ? `Sezony: <b>${item.seasonCount}</b>` : ''}
                            ${item.totalEpisodes ? `&nbsp;Odcinki: <b>${item.totalEpisodes}</b>` : ''}
                            ${item.seasonEpisodeLengths && item.seasonEpisodeLengths.length > 1 ? 
                                `<br><span style="font-size:0.85em;">Długości: ${item.seasonEpisodeLengths.map((len, idx) => `S${idx+1}: ${len}min`).join(', ')}</span>` : ''}
                        </div>
                        ${notesHtml}
                        <div class="planner-actions">
                            <button class="start-watching-btn btn-success" data-id="${item.id}">
                                <i class="fas fa-play"></i> Zacznij oglądać
                            </button>
                            <button class="edit-planner-btn btn-secondary" data-id="${item.id}">
                                <i class="fas fa-edit"></i> Edytuj
                            </button>
                            <button class="delete-planner-btn btn-danger" data-id="${item.id}">
                                <i class="fas fa-trash"></i> Usuń
                            </button>
                        </div>
                    `;
                    
                    plannerContainer.appendChild(plannerCard);
                });
                
                // Add event listeners
                document.querySelectorAll('.start-watching-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            // Add to anime list as "upcoming" (Nadchodzące)
const animeData = {
    id: Date.now(),
    title: plannerItem.title,
    status: 'watching',
    totalEpisodes: (plannerItem.seasons && plannerItem.seasons.length > 1)
        ? plannerItem.seasons.reduce((a, b) => a + b, 0)
        : (plannerItem.totalEpisodes || 12),
    episodeLength: 24,
    watchedEpisodes: 0,
    rewatchCount: 0,
    ratings: {
        graphics: 5,
        music: 5,
        characters: 5,
        story: 5,
        fun: 5
    },
    averageRating: 5,
    createdAt: new Date().toISOString(),
    seasons: plannerItem.seasons,
    seasonEpisodeLengths: plannerItem.seasonEpisodeLengths
};
                            
                            animeList.push(animeData);
                            saveAnimeList();
                            
                            // Remove from planner
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            
                            // Update displays
                            renderAnimeList();
                            renderPlannerList();
                            updateProfileStats();
                            
                            showNotification(`"${plannerItem.title}" zostało dodane do nadchodzących!`, 'success');
                        }
                    });
                });
                
                document.querySelectorAll('.edit-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem) {
                            document.getElementById('planner-title').value = plannerItem.title;
                            document.getElementById('planner-priority').value = plannerItem.priority;
                            document.getElementById('planner-notes').value = plannerItem.notes || '';
                            plannerTagsInput.value = plannerItem.tags ? plannerItem.tags.join('; ') : '';
                            
                            // Fill season inputs if needed
                            if (plannerItem.seasons && plannerItem.seasons.length > 1) {
                                plannerSeasonCountInput.value = plannerItem.seasons.length;
                                plannerSeasonCountInput.dispatchEvent(new Event('input'));
                                const episodeLengthValues = plannerItem.seasonEpisodeLengths || [];
                                setTimeout(() => {
                                    const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                                    const episodeLengthInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episode-length');
                                    seasonInputs.forEach((input, index) => {
                                        if (plannerItem.seasons[index]) {
                                            input.value = plannerItem.seasons[index];
                                        }
                                    });
                                    episodeLengthInputs.forEach((input, index) => {
                                        if (episodeLengthValues[index] !== undefined) {
                                            input.value = episodeLengthValues[index];
                                        } else {
                                            input.value = 24; // domyślna długość
                                        }
                                    });
                                    updatePlannerTotalEpisodesFromSeasons();
                                }, 10);
                            } else {
                                plannerSeasonCountInput.value = 1;
                                plannerSeasonsContainer.innerHTML = '';
                                plannerSeasonsContainer.style.display = 'none';
                                plannerTotalEpisodesInput.readOnly = false;
                            }
                            
                            // Change button text
                            const addBtn = document.getElementById('add-to-planner');
                            addBtn.innerHTML = '<i class="fas fa-save"></i> Zapisz zmiany';
                            addBtn.dataset.editId = id;
                            
                            // Scroll to planner form
                            const plannerSection = document.getElementById('planer');
                            plannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                });
                
                document.querySelectorAll('.delete-planner-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const id = parseInt(this.dataset.id);
                        const plannerItem = plannerList.find(item => item.id === id);
                        
                        if (plannerItem && confirm(`Czy na pewno chcesz usunąć "${plannerItem.title}" z planera?`)) {
                            plannerList = plannerList.filter(item => item.id !== id);
                            savePlannerList();
                            renderPlannerList();
                            showNotification('Anime zostało usunięte z planera!', 'danger');
                        }
                    });
                });
            }
            
            // Tier category switching
            tierCategoryBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    currentTierCategory = this.dataset.category;
                    
                    // Update active button
                    tierCategoryBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tier list
                    renderTierList();
                });
            });
            
            // Export data
            exportBtn.addEventListener('click', function() {
                const exportData = {
                    animeList: animeList,
                    plannerList: plannerList
                };
                const dataStr = JSON.stringify(exportData);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'anime-toolkit-data-'+new Date().toISOString().slice(0,10)+'.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showNotification('Dane zostały wyeksportowane!', 'success');
            });
            
            // Import data
            importBtn.addEventListener('click', function() {
                importFile.click();
            });
            
            importFile.addEventListener('change', function(event) {
                const file = event.target.files[0];
                
                if (!file) {
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (confirm('Czy na pewno chcesz zaimportować nowe dane? Obecne dane zostaną zastąpione.')) {
                            // Handle both old format (array) and new format (object)
                            if (Array.isArray(importedData)) {
                                // Old format - just anime list
                                animeList = importedData;
                                plannerList = [];
                            } else if (importedData.animeList && importedData.plannerList) {
                                // New format - both anime and planner data
                                animeList = importedData.animeList;
                                plannerList = importedData.plannerList;
                            } else {
                                showNotification('Nieprawidłowy format pliku!', 'danger');
                                return;
                            }
                            
                            saveAnimeList();
                            savePlannerList();
                            renderAnimeList();
                            renderPlannerList();
                            renderTierList();
                            updateProfileStats();
                            showNotification('Dane zostały zaimportowane!', 'success');
                        }
                    } catch (error) {
                        showNotification('Błąd podczas importowania pliku: ' + error.message, 'danger');
                    }
                    
                    // Reset file input
                    importFile.value = '';
                };
                reader.readAsText(file);
            });
            
            // Clear all data
            clearBtn.addEventListener('click', function() {
                if (confirm('Czy na pewno chcesz usunąć wszystkie dane? Tej operacji nie można cofnąć.')) {
                    animeList = [];
                    plannerList = [];
                    activityData = {};
                    activityDetails = {};
                    saveAnimeList();
                    savePlannerList();
                    saveActivityData();
                    renderAnimeList();
                    renderPlannerList();
                    renderTierList();
                    renderActivityCalendar();
                    updateProfileStats();
                    showNotification('Wszystkie dane zostały usunięte!', 'danger');
                }
            });
            
            // Scroll to top button
            scrollTopBtn.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollTopBtn.style.display = 'flex';
                } else {
                    scrollTopBtn.style.display = 'none';
                }
            });
            
            // Navbar functionality
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);

                    // Przewiń do wybranej sekcji
                    window.scrollTo({top: targetSection.offsetTop - 80, behavior: 'smooth'});
                });
            });

            // Show notification
            function showNotification(message, type = 'info', onClick = null) {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                
                // Dodaj cursor pointer jeśli jest onClick
                if (onClick) {
                    notification.style.cursor = 'pointer';
                    notification.title = 'Kliknij aby spróbować ponownie';
                    notification.addEventListener('click', onClick);
                }
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
            
            // === SYSTEM TRANSFERU DANYCH (HYBRID: JSONBIN.IO + LOCALSTORAGE) ===
            
            // === KONFIGURACJA JSONBIN.IO ===
            
            // Używamy JSONBin.io - profesjonalne, z pełnym CORS support
            const JSONBIN_CONFIG = {
                // JSONBin.io API
                apiUrl: 'https://api.jsonbin.io/v3/b',
                
                // Bin ID i API Key (nowy bin z lepszymi uprawnieniami)
                binId: '688be2b17b4b8670d8aa9a8b',
                apiKey: '$2a$10$5TR9RcCQnEyNeG6Un1qRW.ftdKAU9U5BZESY9FhDh4yCr8xWcJli2',
                
                // Pełny URL do naszego bin-a
                get readUrl() {
                    return `${this.apiUrl}/${this.binId}/latest`;
                },
                get writeUrl() {
                    return `${this.apiUrl}/${this.binId}`;
                }
            };
            
            // Funkcja do tworzenia nowego bin-a (jeśli potrzebne)
            async function createNewJsonbinBin() {
                try {
                    console.log('🆕 Próbuję utworzyć nowy bin w JSONBin.io...');
                    
                    const response = await fetch('https://api.jsonbin.io/v3/b', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        },
                        body: JSON.stringify({
                            transfer_codes: {},
                            _ignore: true
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('✅ Nowy bin utworzony:', result);
                        return result.metadata.id;
                    } else {
                        console.error('❌ Nie udało się utworzyć nowego bin-a:', response.status);
                        return null;
                    }
                } catch (error) {
                    console.error('❌ Błąd podczas tworzenia nowego bin-a:', error);
                    return null;
                }
            }

            // Flaga czy JSONBin.io działa
            let jsonbinWorking = true;
            
            // Reset API status
            console.log('🔄 Konfiguracja JSONBin.io została załadowana (profesjonalne API)');
            
            // Test połączenia z JSONBin.io
            async function testJsonbinConnection() {
                try {
                    console.log('🧪 Testuję połączenie z JSONBin.io...');
                    console.log('🔍 URL:', JSONBIN_CONFIG.readUrl);
                    console.log('🔍 Bin ID:', JSONBIN_CONFIG.binId);
                    
                    // Sprawdź czy bin jest dostępny
                    const response = await fetch(JSONBIN_CONFIG.readUrl, {
                        headers: {
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        }
                    });
                    
                    console.log('🔍 Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        console.log('✅ JSONBin.io dostępny');
                        jsonbinWorking = true;
                        showNotification('JSONBin.io API gotowe!', 'success');
                    } else {
                        let errorMsg = `JSONBin response: ${response.status}`;
                        if (response.status === 403) {
                            errorMsg += ' (Forbidden - sprawdź API key lub uprawnienia)';
                        } else if (response.status === 401) {
                            errorMsg += ' (Unauthorized - nieprawidłowy API key)';
                        } else if (response.status === 404) {
                            errorMsg += ' (Not Found - bin nie istnieje)';
                        }
                        throw new Error(errorMsg);
                    }
                } catch (error) {
                    console.error('❌ Problem z JSONBin.io:', error.message);
                    
                    // Spróbuj utworzyć nowy bin jeśli to błąd 403 lub 404
                    if (error.message.includes('403') || error.message.includes('404')) {
                        console.log('🔄 Próbuję utworzyć nowy bin...');
                        const newBinId = await createNewJsonbinBin();
                        if (newBinId) {
                            console.log('✅ Nowy bin utworzony, aktualizuję konfigurację...');
                            JSONBIN_CONFIG.binId = newBinId;
                            jsonbinWorking = true;
                            showNotification('Nowy JSONBin.io bin utworzony!', 'success');
                            return;
                        }
                    }
                    
                    jsonbinWorking = false;
                    showNotification('JSONBin niedostępny, używam localStorage. Kliknij aby spróbować ponownie.', 'warning', () => {
                        retryJsonbinConnection();
                    });
                }
            }
            
            // Test połączenia przy starcie
            testJsonbinConnection();
            
            // Funkcja do ręcznego ponownego testowania połączenia
            async function retryJsonbinConnection() {
                console.log('🔄 Ręczne ponowne testowanie połączenia JSONBin.io...');
                jsonbinWorking = true; // Reset flag
                await testJsonbinConnection();
            }
            
            // Funkcja diagnostyczna do testowania JSONBin.io (dostępna w konsoli)
            window.diagnoseJsonbin = async function() {
                console.log('🔍 Diagnostyka JSONBin.io...');
                console.log('📋 Konfiguracja:', {
                    apiUrl: JSONBIN_CONFIG.apiUrl,
                    binId: JSONBIN_CONFIG.binId,
                    readUrl: JSONBIN_CONFIG.readUrl,
                    writeUrl: JSONBIN_CONFIG.writeUrl
                });
                
                try {
                    // Test odczytu
                    console.log('📖 Test odczytu...');
                    const readResponse = await fetch(JSONBIN_CONFIG.readUrl, {
                        headers: {
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        }
                    });
                    console.log('📖 Odczyt status:', readResponse.status, readResponse.statusText);
                    
                    if (readResponse.ok) {
                        const data = await readResponse.json();
                        console.log('📖 Dane z bin-a:', data);
                    }
                    
                    // Test zapisu (tylko jeśli odczyt się udał)
                    if (readResponse.ok) {
                        console.log('✏️ Test zapisu...');
                        const writeResponse = await fetch(JSONBIN_CONFIG.writeUrl, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Master-Key': JSONBIN_CONFIG.apiKey
                            },
                            body: JSON.stringify({
                                transfer_codes: {},
                                _ignore: true,
                                test: Date.now()
                            })
                        });
                        console.log('✏️ Zapis status:', writeResponse.status, writeResponse.statusText);
                    }
                    
                } catch (error) {
                    console.error('❌ Błąd diagnostyki:', error);
                }
            };
            

            
            // Funkcja do testowania połączenia z JSONBin.io
            async function testJsonbinAPI() {
                return testJsonbinConnection(); // Już mamy tę funkcję
            }

            // === FUNKCJE JSONBIN.IO (GŁÓWNE) ===
            
            // Funkcja do pobierania danych z JSONBin.io
            async function getJsonbinData() {
                try {
                    console.log('📥 Pobieranie danych z JSONBin.io...');
                    const response = await fetch(JSONBIN_CONFIG.readUrl, {
                        headers: {
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`JSONBin error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('🔍 Raw response z JSONBin:', result);
                    
                    // JSONBin zwraca dane w formacie { record: actualData }
                    const data = result.record || result;
                    console.log('🔍 Data z JSONBin po extract:', data);
                    
                    // Sprawdź strukturę i ignoruj pole _ignore
                    if (!data || typeof data !== 'object') {
                        console.log('Niepoprawna struktura JSON z JSONBin, zwracam pustą strukturę');
                        return { transfer_codes: {} };
                    }
                    
                    // Usuń pole _ignore z danych (jak chciał user)
                    if (data._ignore !== undefined) {
                        delete data._ignore;
                        console.log('🗑️ Zignorowano pole _ignore z JSONBin');
                    }
                    
                    // Upewnij się że transfer_codes istnieje
                    if (!data.transfer_codes) {
                        data.transfer_codes = {};
                        console.log('➕ Utworzono pustą strukturę transfer_codes');
                    }
                    
                    console.log('✅ Pobrano dane z JSONBin.io:', data);
                    console.log('🔍 Transfer codes count:', Object.keys(data.transfer_codes).length);
                    return data;
                    
                } catch (error) {
                    console.error('Błąd pobierania danych z JSONBin.io:', error);
                    jsonbinWorking = false;
                    throw error;
                }
            }
            
            // Funkcja do zapisywania danych do JSONBin.io
            async function saveJsonbinData(data) {
                try {
                    console.log('💾 Zapisywanie danych do JSONBin.io...');
                    
                    // Upewnij się że dane mają poprawną strukturę
                    if (!data.transfer_codes) {
                        data.transfer_codes = {};
                    }
                    
                    // Dodaj pole _ignore (zgodnie z życzeniem user)
                    const dataToSave = {
                        ...data,
                        _ignore: true
                    };
                    
                    const response = await fetch(JSONBIN_CONFIG.writeUrl, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Master-Key': JSONBIN_CONFIG.apiKey
                        },
                        body: JSON.stringify(dataToSave)
                    });
                    
                    if (!response.ok) {
                        let errorMessage = `JSONBin error: ${response.status}`;
                        
                        // Dodaj szczegółowe informacje o błędzie
                        if (response.status === 403) {
                            errorMessage += ' (Forbidden - sprawdź API key lub uprawnienia bin-a)';
                        } else if (response.status === 401) {
                            errorMessage += ' (Unauthorized - nieprawidłowy API key)';
                        } else if (response.status === 404) {
                            errorMessage += ' (Not Found - bin nie istnieje)';
                        } else if (response.status === 429) {
                            errorMessage += ' (Too Many Requests - przekroczono limit zapytań)';
                        }
                        
                        console.error('🔍 Szczegóły błędu JSONBin:', {
                            status: response.status,
                            statusText: response.statusText,
                            url: JSONBIN_CONFIG.writeUrl,
                            binId: JSONBIN_CONFIG.binId
                        });
                        
                        throw new Error(errorMessage);
                    }
                    
                    console.log('✅ Zapisano dane do JSONBin.io');
                    return true;
                    
                } catch (error) {
                    console.error('Błąd zapisywania danych do JSONBin.io:', error);
                    jsonbinWorking = false;
                    throw error;
                }
            }

            // === FUNKCJE LOCALSTORAGE (FALLBACK) ===
            
            function getLocalStorageData() {
                try {
                    const data = localStorage.getItem('transfer_codes_backup');
                    return data ? JSON.parse(data) : { transfer_codes: {} };
                } catch (error) {
                    console.error('Błąd pobierania z localStorage:', error);
                    return { transfer_codes: {} };
                }
            }
            
            function saveLocalStorageData(data) {
                try {
                    localStorage.setItem('transfer_codes_backup', JSON.stringify(data));
                    return true;
                } catch (error) {
                    console.error('Błąd zapisywania do localStorage:', error);
                    return false;
                }
            }
            
            function cleanExpiredCodesLocal() {
                const data = getLocalStorageData();
                const now = Date.now();
                let hasExpired = false;
                
                Object.keys(data.transfer_codes || {}).forEach(code => {
                    const codeData = data.transfer_codes[code];
                    if (codeData && codeData.expiresAt && now > codeData.expiresAt) {
                        delete data.transfer_codes[code];
                        hasExpired = true;
                        console.log('Usunięto przeterminowany kod (localStorage):', code);
                    }
                });
                
                if (hasExpired) {
                    saveLocalStorageData(data);
                }
            }



            // Funkcja hybrydowa - pobiera z JSONBin.io lub localStorage
            async function getData() {
                console.log('🔍 getData() - jsonbinWorking:', jsonbinWorking);
                
                if (jsonbinWorking) {
                    try {
                        console.log('📡 Używam JSONBin.io...');
                        const data = await getJsonbinData();
                        // Synchronizuj z localStorage na wszelki wypadek
                        saveLocalStorageData(data);
                        console.log('✅ getData() - zwracam dane z JSONBin.io');
                        return data;
                    } catch (error) {
                        console.log('❌ JSONBin.io niedostępny, używam localStorage...', error.message);
                        jsonbinWorking = false;
                        const localData = getLocalStorageData();
                        console.log('✅ getData() - zwracam dane z localStorage (fallback)');
                        return localData;
                    }
                } else {
                    console.log('📱 Używam localStorage (JSONBin.io wyłączone)');
                    const localData = getLocalStorageData();
                    console.log('✅ getData() - zwracam dane z localStorage');
                    return localData;
                }
            }



            // Funkcja hybrydowa - zapisuje do JSONBin.io (główne) + localStorage (fallback)
            async function saveData(data) {
                // Zawsze zapisz do localStorage jako backup
                const localSaved = saveLocalStorageData(data);
                console.log('Dane zapisane do localStorage (backup)');
                
                if (jsonbinWorking) {
                    try {
                        await saveJsonbinData(data);
                        console.log('✅ Dane zapisane do JSONBin.io');
                        showNotification('Kod zapisany i udostępniony!', 'success');
                        return true;
                    } catch (error) {
                        console.log('❌ JSONBin.io niedostępny (błąd zapisu), używam localStorage');
                        console.log('Błąd JSONBin:', error.message);
                        jsonbinWorking = false;
                        showNotification('Kod zapisany lokalnie (JSONBin niedostępny)', 'warning');
                        return localSaved;
                    }
                } else {
                    console.log('📱 Używam localStorage (JSONBin.io wyłączone)');
                    showNotification('Kod zapisany lokalnie', 'warning');
                    return localSaved;
                }
            }

            // Funkcja do czyszczenia przeterminowanych kodów
            async function cleanExpiredCodes() {
                try {
                    // Czyść w localStorage zawsze
                    cleanExpiredCodesLocal();
                    
                    // Sprawdź też JSONBin.io i wyczyść przeterminowane kody
                    if (jsonbinWorking) {
                        try {
                            const data = await getData();
                            const now = Date.now();
                            let hasExpired = false;
                            
                            Object.keys(data.transfer_codes || {}).forEach(code => {
                                const codeData = data.transfer_codes[code];
                                if (codeData && codeData.expiresAt && now > codeData.expiresAt) {
                                    delete data.transfer_codes[code];
                                    hasExpired = true;
                                    console.log('Usunięto przeterminowany kod:', code);
                                }
                            });
                            
                            // Zapisz zaktualizowane dane z usuniętymi kodami
                            if (hasExpired) {
                                await saveData(data);
                                console.log('✅ Wyczyszczono przeterminowane kody z JSONBin.io');
                            }
                        } catch (error) {
                            console.log('Czyszczenie JSONBin.io nie powiodło się, używam tylko localStorage');
                        }
                    }
                } catch (error) {
                    console.error('Błąd podczas czyszczenia przeterminowanych kodów:', error);
                }
            }

            // Funkcje do zarządzania aktywnym kodem eksportu
            function getActiveCode() {
                const activeCode = localStorage.getItem('active_export_code');
                console.log('🔍 getActiveCode - localStorage.getItem:', activeCode);
                
                if (!activeCode) {
                    console.log('🔍 getActiveCode - Brak aktywnego kodu');
                    return null;
                }
                
                try {
                    const codeData = JSON.parse(activeCode);
                    const now = Date.now();
                    
                    console.log('🔍 getActiveCode - Parsed codeData:', codeData);
                    console.log('🔍 getActiveCode - now:', now, 'expiresAt:', codeData.expiresAt);
                    
                    // Sprawdź czy kod nie wygasł
                    if (codeData.expiresAt && now > codeData.expiresAt) {
                        console.log('🔍 getActiveCode - Kod wygasł, usuwam z localStorage');
                        localStorage.removeItem('active_export_code');
                        return null;
                    }
                    
                    console.log('🔍 getActiveCode - Zwracam aktywny kod:', codeData);
                    return codeData;
                } catch (error) {
                    console.log('🔍 getActiveCode - Błąd parsowania, usuwam z localStorage:', error);
                    localStorage.removeItem('active_export_code');
                    return null;
                }
            }
            
            function setActiveCode(code, expiresAt) {
                const codeData = {
                    code: code,
                    expiresAt: expiresAt,
                    createdAt: Date.now()
                };
                localStorage.setItem('active_export_code', JSON.stringify(codeData));
            }
            
            function clearActiveCode() {
                console.log('🔍 clearActiveCode - Usuwam aktywny kod z localStorage');
                localStorage.removeItem('active_export_code');
                console.log('🔍 clearActiveCode - Kod usunięty, localStorage.getItem:', localStorage.getItem('active_export_code'));
            }
            
            function updateActiveCodeDisplay() {
                const activeCodeCard = document.getElementById('active-code-card');
                const generateCodeCard = document.getElementById('generate-code-card');
                const activeCodeDisplay = document.getElementById('active-code-display');
                const activeCodeTimer = document.getElementById('active-code-timer');
                
                const activeCode = getActiveCode();
                
                console.log('🔍 updateActiveCodeDisplay - activeCode:', activeCode);
                console.log('🔍 updateActiveCodeDisplay - activeCodeCard:', activeCodeCard);
                console.log('🔍 updateActiveCodeDisplay - generateCodeCard:', generateCodeCard);
                
                if (activeCode) {
                    // Pokaż aktywny kod i ukryj przycisk generowania
                    activeCodeCard.style.display = 'block';
                    generateCodeCard.style.display = 'none';
                    
                    activeCodeDisplay.textContent = activeCode.code;
                    
                    // Timer odliczający
                    const updateTimer = () => {
                        const now = Date.now();
                        const timeLeft = Math.max(0, activeCode.expiresAt - now);
                        
                        if (timeLeft <= 0) {
                            clearActiveCode();
                            updateActiveCodeDisplay();
                            showNotification('Kod eksportu wygasł!', 'warning');
                            return;
                        }
                        
                        const minutes = Math.floor(timeLeft / 60000);
                        const seconds = Math.floor((timeLeft % 60000) / 1000);
                        activeCodeTimer.textContent = `Wygasa za: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    };
                    
                    updateTimer();
                    const timerInterval = setInterval(updateTimer, 1000);
                    
                    // Zapisz interval ID żeby można było go wyczyścić
                    activeCodeCard.dataset.timerInterval = timerInterval;
                    
                    console.log('🔍 updateActiveCodeDisplay - Pokazuję aktywny kod, ukrywam przycisk generowania');
                } else {
                    // Ukryj aktywny kod i pokaż przycisk generowania
                    activeCodeCard.style.display = 'none';
                    generateCodeCard.style.display = 'block';
                    
                    // Wyczyść timer jeśli istnieje
                    if (activeCodeCard.dataset.timerInterval) {
                        clearInterval(parseInt(activeCodeCard.dataset.timerInterval));
                        delete activeCodeCard.dataset.timerInterval;
                    }
                    
                    console.log('🔍 updateActiveCodeDisplay - Ukrywam aktywny kod, pokazuję przycisk generowania');
                }
            }
            
            // Funkcja do sprawdzania czy aktywny kod nadal istnieje na serwerze
            async function checkActiveCodeOnServer() {
                const activeCode = getActiveCode();
                if (!activeCode) {
                    console.log('🔍 checkActiveCodeOnServer - Brak aktywnego kodu lokalnie');
                    return;
                }
                
                console.log('🔍 checkActiveCodeOnServer - Sprawdzam kod na serwerze:', activeCode.code);
                
                try {
                    // Sprawdź czy kod nadal istnieje na serwerze
                    const serverCodeData = await getDataFromCode(activeCode.code);
                    
                    if (!serverCodeData) {
                        console.log('🔍 checkActiveCodeOnServer - Kod nie istnieje na serwerze, czyszczę lokalnie');
                        clearActiveCode();
                        updateActiveCodeDisplay();
                        showNotification('Twój kod eksportu został użyty lub wygasł na serwerze!', 'info');
                    } else {
                        console.log('🔍 checkActiveCodeOnServer - Kod nadal istnieje na serwerze');
                    }
                } catch (error) {
                    console.error('🔍 checkActiveCodeOnServer - Błąd podczas sprawdzania kodu na serwerze:', error);
                    // W przypadku błędu sieci, zachowujemy lokalny kod
                }
            }
            
            // Funkcja do generowania losowego 6-cyfrowego kodu
            async function generateTransferCode() {
                const data = await getData();
                let code;
                do {
                    code = Math.floor(100000 + Math.random() * 900000).toString();
                } while (data.transfer_codes && data.transfer_codes[code]);
                return code;
            }

            // Funkcja do zapisania danych do kodu (hybrydowa)
            async function saveDataToCode(code) {
                try {
                    const now = Date.now();
                    const expires = now + (60 * 60 * 1000); // 1 godzina
                    
                    console.log('🕒 DEBUG timestamp:');
                    console.log('Date.now():', now);
                    console.log('Date object:', new Date(now));
                    console.log('Expires at:', expires);
                    console.log('Expires date:', new Date(expires));
                    
                    const transferData = {
                        animeList: animeList,
                        plannerList: plannerList,
                        activityData: activityData,
                        activityDetails: activityDetails,
                        createdAt: now,
                        expiresAt: expires
                    };
                    
                    const data = await getData();
                    if (!data.transfer_codes) {
                        data.transfer_codes = {};
                    }
                    
                    data.transfer_codes[code] = transferData;
                    const saved = await saveData(data);
                    
                    console.log(`✅ Kod ${code} został wygenerowany i zapisany`);
                    
                    return transferData;
                } catch (error) {
                    console.error('Błąd zapisywania kodu:', error);
                    throw error;
                }
            }

            // Funkcja do pobierania danych z kodu (hybrydowa)
            async function getDataFromCode(code) {
                try {
                    console.log('🔍 Szukam kodu:', code);
                    const data = await getData();
                    console.log('🔍 Dane pobrane:', data);
                    console.log('🔍 Transfer codes:', data.transfer_codes);
                    console.log('🔍 Dostępne kody:', Object.keys(data.transfer_codes || {}));
                    
                    if (!data.transfer_codes || !data.transfer_codes[code]) {
                        console.log('❌ Kod nie znaleziony:', code);
                        return null;
                    }
                    
                    const codeData = data.transfer_codes[code];
                    console.log('✅ Znaleziono kod:', code, codeData);
                    
                    // Sprawdź czy kod nie wygasł
                    const currentTime = Date.now();
                    console.log('🕒 Sprawdzanie ważności kodu:');
                    console.log('Obecny czas:', currentTime, '(' + new Date(currentTime) + ')');
                    console.log('Kod wygasa:', codeData.expiresAt, '(' + new Date(codeData.expiresAt) + ')');
                    console.log('Kod wygasł?', currentTime > codeData.expiresAt);
                    
                    if (currentTime > codeData.expiresAt) {
                        console.log('⏰ Kod wygasł:', code);
                        // Usuń wygasły kod
                        delete data.transfer_codes[code];
                        await saveData(data);
                        return null;
                    }
                    
                    console.log('✅ Kod jest ważny:', code);
                    return codeData;
                } catch (error) {
                    console.error('Błąd pobierania kodu:', error);
                    return null;
                }
            }

            // Funkcja do usuwania kodu po pomyślnym imporcie
            async function removeCode(code) {
                try {
                    const data = await getData();
                    
                    if (data.transfer_codes && data.transfer_codes[code]) {
                        delete data.transfer_codes[code];
                        const saved = await saveData(data);
                        
                        if (saved) {
                            console.log(`Usunięto kod ${code} lokalnie`);
                        } else {
                            console.log(`Błąd usuwania kodu ${code}`);
                        }
                    }
                } catch (error) {
                    console.error('Błąd usuwania kodu:', error);
                }
            }

            // Obsługa generowania kodu
            document.getElementById('generate-code-card').addEventListener('click', async function() {
                console.log('🔍 Generate button clicked');
                // Sprawdź czy już istnieje aktywny kod
                const activeCode = getActiveCode();
                console.log('🔍 Generate button - activeCode check:', activeCode);
                if (activeCode) {
                    console.log('🔍 Generate button - Blocked by active code');
                    showNotification('Masz już aktywny kod eksportu! Poczekaj aż wygaśnie lub zostanie użyty.', 'warning');
                    return;
                }
                
                const modal = document.getElementById('generate-code-modal');
                const codeDisplay = document.getElementById('generated-code');
                const timeRemaining = document.getElementById('time-remaining');
                
                try {
                    // Pokaż modal z loadingiem
                    codeDisplay.textContent = 'Generowanie...';
                    modal.classList.add('show');
                    
                    // Generuj kod
                    const code = await generateTransferCode();
                    const transferData = await saveDataToCode(code);
                    
                    // Zapisz aktywny kod
                    setActiveCode(code, transferData.expiresAt);
                    
                    codeDisplay.textContent = code;
                    
                    // Timer odliczający
                    let timeLeft = 60 * 60; // 1 godzina w sekundach
                    const timer = setInterval(() => {
                        timeLeft--;
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        timeRemaining.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        
                        if (timeLeft <= 0) {
                            clearInterval(timer);
                            modal.classList.remove('show');
                            clearActiveCode();
                            updateActiveCodeDisplay();
                            showNotification('Kod wygasł!', 'warning');
                        }
                    }, 1000);
                    
                    // Zapisz timer i kod do modal żeby można było go wyczyścić
                    modal.dataset.timer = timer;
                    modal.dataset.code = code;
                    
                    // Aktualizuj wyświetlanie aktywnego kodu
                    updateActiveCodeDisplay();
                    
                    showNotification(`Kod ${code} został wygenerowany!`, 'success');
                } catch (error) {
                    modal.classList.remove('show');
                    showNotification('Błąd podczas generowania kodu: ' + error.message, 'danger');
                    console.error('Błąd generowania kodu:', error);
                }
            });

            // Obsługa kopiowania kodu z modala
            document.getElementById('copy-code-btn').addEventListener('click', function() {
                const code = document.getElementById('generated-code').textContent;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(code).then(() => {
                        showNotification('Kod skopiowany do schowka!', 'success');
                    });
                } else {
                    // Fallback dla starszych przeglądarek
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification('Kod skopiowany do schowka!', 'success');
                }
            });
            
            // Obsługa kopiowania aktywnego kodu
            document.getElementById('copy-active-code-btn').addEventListener('click', function() {
                const activeCode = getActiveCode();
                if (!activeCode) return;
                
                const code = activeCode.code;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(code).then(() => {
                        showNotification('Kod skopiowany do schowka!', 'success');
                    });
                } else {
                    // Fallback dla starszych przeglądarek
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification('Kod skopiowany do schowka!', 'success');
                }
            });
            
            // Obsługa sprawdzania aktywnego kodu
            document.getElementById('check-active-code-btn').addEventListener('click', async function() {
                const activeCode = getActiveCode();
                if (!activeCode) {
                    showNotification('Brak aktywnego kodu do sprawdzenia!', 'warning');
                    return;
                }
                
                const button = this;
                const originalText = button.innerHTML;
                
                try {
                    // Pokaż loading
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sprawdzanie...';
                    button.disabled = true;
                    
                    // Sprawdź kod na serwerze
                    const serverCodeData = await getDataFromCode(activeCode.code);
                    
                    if (serverCodeData) {
                        showNotification('Kod jest nadal aktywny i ważny!', 'success');
                    } else {
                        showNotification('Kod został użyty lub wygasł na serwerze!', 'warning');
                        // Wyczyść lokalny kod
                        clearActiveCode();
                        updateActiveCodeDisplay();
                    }
                } catch (error) {
                    console.error('Błąd sprawdzania kodu:', error);
                    showNotification('Błąd podczas sprawdzania kodu!', 'danger');
                } finally {
                    // Przywróć przycisk
                    button.innerHTML = originalText;
                    button.disabled = false;
                }
            });



            // Obsługa wpisywania w input
            document.getElementById('import-code-input').addEventListener('input', async function() {
                const code = this.value.replace(/\D/g, ''); // Tylko cyfry
                this.value = code;
                
                this.classList.remove('error');
                const preview = document.getElementById('import-preview');
                const previewContent = document.getElementById('import-preview-content');
                preview.style.display = 'none';
                
                if (code.length === 6) {
                    try {
                        // Pokaż loading
                        previewContent.innerHTML = '<div style="text-align: center; padding: 1rem;"><i class="fas fa-spinner fa-spin"></i> Sprawdzanie kodu...</div>';
                        preview.style.display = 'block';
                        
                        // Sprawdź kod na GitHub
                        const transferData = await getDataFromCode(code);
                        
                        if (transferData) {
                            // Pokaż podgląd danych
                            const animeCount = transferData.animeList ? transferData.animeList.length : 0;
                            const plannerCount = transferData.plannerList ? transferData.plannerList.length : 0;
                            const activityDays = transferData.activityData ? Object.keys(transferData.activityData).length : 0;
                            
                            previewContent.innerHTML = `
                                <div style="margin: 0.5rem 0;">📺 Anime: ${animeCount}</div>
                                <div style="margin: 0.5rem 0;">📋 Planer: ${plannerCount}</div>
                                <div style="margin: 0.5rem 0;">📅 Dni aktywności: ${activityDays}</div>
                                <div style="margin: 0.5rem 0; font-size: 0.8rem; color: var(--gray);">
                                    Wygenerowano: ${new Date(transferData.createdAt).toLocaleString('pl-PL')}
                                </div>
                            `;
                            
                            preview.style.display = 'block';
                        } else {
                            // Błędny kod
                            this.classList.add('error');
                            preview.style.display = 'none';
                            showNotification('Nieprawidłowy lub wygasły kod!', 'danger');
                        }
                    } catch (error) {
                        console.error('Błąd sprawdzania kodu:', error);
                        this.classList.add('error');
                        preview.style.display = 'none';
                        showNotification('Błąd podczas sprawdzania kodu!', 'danger');
                    }
                }
            });

            // Obsługa potwierdzenia importu
            document.getElementById('confirm-import-btn').addEventListener('click', async function() {
                const code = document.getElementById('import-code-input').value;
                const button = this;
                
                try {
                    // Zablokuj przycisk i pokaż loading
                    button.disabled = true;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Importowanie...';
                    
                    const transferData = await getDataFromCode(code);
                    
                    if (!transferData) {
                        showNotification('Kod jest nieprawidłowy lub wygasł!', 'danger');
                        return;
                    }
                    
                    if (confirm('Czy na pewno chcesz wgrać te dane? Obecne dane zostaną połączone z importowanymi.')) {
                        // Połącz dane
                        if (transferData.animeList && Array.isArray(transferData.animeList)) {
                            // Dodaj nowe anime, unikając duplikatów po tytule
                            transferData.animeList.forEach(importedAnime => {
                                const exists = animeList.find(existing => existing.title === importedAnime.title);
                                if (!exists) {
                                    // Nadaj nowe ID żeby uniknąć konfliktów
                                    importedAnime.id = Date.now() + Math.random();
                                    animeList.push(importedAnime);
                                }
                            });
                        }
                        
                        if (transferData.plannerList && Array.isArray(transferData.plannerList)) {
                            // Dodaj nowe pozycje planera
                            transferData.plannerList.forEach(importedItem => {
                                const exists = plannerList.find(existing => existing.title === importedItem.title);
                                if (!exists) {
                                    importedItem.id = Date.now() + Math.random();
                                    plannerList.push(importedItem);
                                }
                            });
                        }
                        
                        if (transferData.activityData && typeof transferData.activityData === 'object') {
                            // Połącz dane aktywności
                            Object.keys(transferData.activityData).forEach(date => {
                                if (!activityData[date]) {
                                    activityData[date] = 0;
                                }
                                activityData[date] += transferData.activityData[date];
                            });
                        }
                        
                        if (transferData.activityDetails && typeof transferData.activityDetails === 'object') {
                            // Połącz szczegóły aktywności
                            Object.keys(transferData.activityDetails).forEach(date => {
                                if (!activityDetails[date]) {
                                    activityDetails[date] = [];
                                }
                                activityDetails[date] = activityDetails[date].concat(transferData.activityDetails[date] || []);
                            });
                        }
                        
                        // Zapisz wszystko lokalnie
                        saveAnimeList();
                        savePlannerList();
                        saveActivityData();
                        
                        // Usuń kod
                        await removeCode(code);
                        
                        // Sprawdź czy to był aktywny kod użytkownika i wyczyść go
                        const activeCode = getActiveCode();
                        console.log('🔍 Import - Sprawdzam czy to aktywny kod:', activeCode, 'vs kod użyty:', code);
                        if (activeCode && activeCode.code === code) {
                            console.log('🔍 Import - To jest aktywny kod, czyszczę go');
                            clearActiveCode();
                            updateActiveCodeDisplay();
                        } else {
                            console.log('🔍 Import - To nie jest aktywny kod lub nie ma aktywnego kodu');
                        }
                        
                        // Odśwież wyświetlanie
                        renderAnimeList();
                        renderPlannerList();
                        renderTierList();
                        updateProfileStats();
                        renderActivityCalendar();
                        
                        // Zamknij modal
                        document.getElementById('import-code-modal').classList.remove('show');
                        
                        showNotification('Dane zostały pomyślnie wgrane i kod został usunięty!', 'success');
                    }
                } catch (error) {
                    console.error('Błąd importowania:', error);
                    showNotification('Błąd podczas importowania danych: ' + error.message, 'danger');
                } finally {
                    // Przywróć przycisk
                    button.disabled = false;
                    button.innerHTML = '<i class="fas fa-check"></i> Potwierdź import danych';
                }
            });
            
            // Funkcja do śledzenia aktywnej sekcji
            function trackActiveSection() {
                const sections = document.querySelectorAll('.section');
                const navItems = document.querySelectorAll('.nav-item');
                
                let currentSection = '';
                
                sections.forEach(section => {
                    const sectionTop = section.offsetTop - 100;
                    const sectionBottom = sectionTop + section.offsetHeight;
                    
                    if (window.scrollY >= sectionTop && window.scrollY < sectionBottom) {
                        currentSection = section.id;
                    }
                });
                
                
                navItems.forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('href') === `#${currentSection}`) {
                        item.classList.add('active');
                    }
                });
            }

            // Nasłuchuj zdarzenia scroll
            window.addEventListener('scroll', trackActiveSection);

            // Wywołaj na początku, aby ustawić początkową sekcję
            trackActiveSection();
            
            // Funkcja do migracji istniejących anime - dodanie dat ukończenia
            function migrateExistingAnime() {
                let hasChanges = false;
                animeList.forEach(anime => {
                    // Usuń automatyczne ustawianie daty ukończenia - niech użytkownik sam decyduje
                    // if (anime.status === 'completed' && !anime.completedDate) {
                    //     anime.completedDate = anime.createdAt ? anime.createdAt.split('T')[0] : new Date().toISOString().split('T')[0];
                    //     hasChanges = true;
                    // }
                });
                
                if (hasChanges) {
                    saveAnimeList();
                }
            }
            
            // Obsługa zamykania modali
            document.getElementById('generate-code-close').addEventListener('click', function() {
                const modal = document.getElementById('generate-code-modal');
                const timer = modal.dataset.timer;
                if (timer) {
                    clearInterval(timer);
                }
                modal.classList.remove('show');
            });

            document.getElementById('import-code-close').addEventListener('click', function() {
                document.getElementById('import-code-modal').classList.remove('show');
            });

            // Zamykanie modali po kliknięciu poza nimi
            document.querySelectorAll('.transfer-modal').forEach(modal => {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        const timer = modal.dataset.timer;
                        if (timer) {
                            clearInterval(timer);
                        }
                        modal.classList.remove('show');
                    }
                });
            });
            
            // Zamykanie modalu edycji anime po kliknięciu poza nim
            document.getElementById('edit-anime-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideEditAnimeModal();
                }
            });

            // Zamykanie modalu szczegółów anime po kliknięciu poza nim
            document.getElementById('anime-details-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideAnimeDetailsModal();
                }
            });
            
            // Initial render
            calculateAverage();
            migrateExistingAnime(); // Migruj istniejące anime
            renderAnimeList();
            renderPlannerList();
            renderTierList();
            updateProfileStats();
            
            // Opóźnij inicjalizację nowoczesnego UI żeby elementy się załadowały
            setTimeout(() => {
                if (typeof initModernUI === 'function') {
                    initModernUI();
                }
            }, 1000);
            
            // Wyczyść przeterminowane kody przy starcie (asynchronicznie)
            cleanExpiredCodes().catch(error => {
                console.error('Błąd podczas czyszczenia przeterminowanych kodów:', error);
            });

            // Test połączenia z JSONBin.io już wywołany wyżej

            // === FUNKCJE POMOCNICZE DLA DEVELOPERÓW ===
            
            // Funkcja do testowania systemu transferu
            window.testTransferSystem = async function() {
                console.log('🧪 Testowanie systemu transferu danych...');
                
                try {
                    console.log('--- TEST LOCALSTORAGE ---');
                    const localData = getLocalStorageData();
                    console.log('LocalStorage data:', localData);
                    console.log('✅ localStorage działa, kody:', Object.keys(localData.transfer_codes || {}).length);
                    
                    console.log('--- TEST JSONBIN.IO ---');
                    if (jsonbinWorking) {
                        const jsonbinData = await getJsonbinData();
                        console.log('JSONBin data:', jsonbinData);
                        console.log('✅ JSONBin.io działa, kody:', Object.keys(jsonbinData.transfer_codes || {}).length);
                    } else {
                        console.log('❌ JSONBin.io niedostępny');
                    }
                    
                    console.log('--- TEST HYBRYDOWEJ FUNKCJI ---');
                    const hybridData = await getData();
                    console.log('Hybrid data:', hybridData);
                    console.log('✅ getData() zwraca kody:', Object.keys(hybridData.transfer_codes || {}).length);
                    
                    return true;
                } catch (error) {
                    console.error('❌ Błąd testowania:', error);
                    return false;
                }
            };
            
            // Funkcja do testowania konkretnego kodu
            window.testCode = async function(code) {
                console.log('🧪 Testowanie kodu:', code);
                const result = await getDataFromCode(code);
                console.log('Wynik:', result);
                return result;
            };
            
            // Funkcja do debugowania timestampów
            window.debugTime = function() {
                const now = Date.now();
                console.log('🕒 DEBUG aktualnego czasu:');
                console.log('Date.now():', now);
                console.log('Date object:', new Date(now));
                console.log('Oczekiwany zakres 2024:', '1700000000000 - 1750000000000');
                console.log('Czy w zakresie?', now >= 1700000000000 && now <= 1750000000000);
                
                // Sprawdź czy system ma prawidłowy czas
                const systemDate = new Date();
                console.log('System date:', systemDate);
                console.log('System year:', systemDate.getFullYear());
                
                return now;
            };
            
            // Informacja o dostępnych funkcjach
            console.log('🔧 Funkcje systemu transferu dostępne w konsoli:');
            console.log('• testTransferSystem() - przetestuj system transferu');
            console.log('• testJsonbinAPI() - przetestuj połączenie z JSONBin.io');
            console.log('• testCode("300227") - przetestuj konkretny kod transferu');
            console.log('• debugTime() - sprawdź czy timestampy są prawidłowe');
            
            // Udostępnij funkcje globalnie
            window.testJsonbinAPI = testJsonbinAPI;

            // Periodycznie sprawdzaj dostępność JSONBin.io API (co 5 minut)
            setInterval(async () => {
                if (!jsonbinWorking) {
                    try {
                        console.log('Testuję ponownie JSONBin.io API...');
                        await testJsonbinConnection();
                    } catch (error) {
                        // JSONBin.io wciąż niedostępny
                        console.log('JSONBin.io API wciąż niedostępne');
                    }
                }
            }, 5 * 60 * 1000); // 5 minut

            const seasonCountInput = document.getElementById('season-count');
            const seasonsContainer = document.getElementById('seasons-container');
            const totalEpisodesInput = document.getElementById('total-episodes');

            function renderSeasonInputs(count, values=[], rewatchValues=[], episodeLengths=[], seasonCompletedDates=[]) {
                seasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const rewatchVal = rewatchValues[i] || 0;
                    const episodeLength = episodeLengths[i] || '';
                    const seasonDate = seasonCompletedDates && seasonCompletedDates[i] ? seasonCompletedDates[i] : '';
                    seasonsContainer.innerHTML += `
                        <div style='margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:8px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                            <div style='margin-left:20px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-redo"></i> Rewatch:</label>
                                <input type='number' class='season-rewatch' min='0' value='${rewatchVal}' style='width:60px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);font-size:0.8rem;'>
                                <span style='margin-left:4px;color:var(--gray);font-size:0.8rem;'>razy</span>
                            </div>
                            <div style='margin-top:8px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-calendar-check"></i> Data ukończenia sezonu:</label>
                                <input type='date' class='season-completed-date' value='${seasonDate}' style='margin-left:8px;'>
                            </div>
                        </div>
                    `;
                }
                seasonsContainer.style.display = count > 1 ? '' : 'none';
                // Ustaw readonly na totalEpisodes jeśli jest więcej niż 1 sezon
                totalEpisodesInput.readOnly = count > 1;
            }

            function updateTotalEpisodesFromSeasons() {
                const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                totalEpisodesInput.value = sum > 0 ? sum : '';
            }

            seasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderSeasonInputs(count);
                } else {
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
                updateTotalEpisodesFromSeasons();
            });

            seasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('season-episodes')) {
                    updateTotalEpisodesFromSeasons();
                }
            });

            // Przy edycji anime, jeśli są sezony, wypełnij pola
            function fillSeasonInputsIfNeeded(anime) {
                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    seasonCountInput.value = anime.seasons.length;
                    const rewatchValues = anime.seasonRewatches || [];
                    const episodeLengthValues = anime.seasonEpisodeLengths || [];
                    const seasonCompletedDates = anime.seasonCompletedDates || [];
                    // Trigger the input event to ensure the season inputs are rendered
                    renderSeasonInputs(anime.seasons.length, anime.seasons, rewatchValues, episodeLengthValues, seasonCompletedDates);
                    // After the inputs are rendered, set the values
                    setTimeout(() => {
                        const seasonInputs = seasonsContainer.querySelectorAll('.season-episodes');
                        const rewatchInputs = seasonsContainer.querySelectorAll('.season-rewatch');
                        const episodeLengthInputs = seasonsContainer.querySelectorAll('.season-episode-length');
                        const seasonDateInputs = seasonsContainer.querySelectorAll('.season-completed-date');
                        seasonInputs.forEach((input, index) => {
                            if (anime.seasons[index]) {
                                input.value = anime.seasons[index];
                            }
                        });
                        rewatchInputs.forEach((input, index) => {
                            if (rewatchValues[index] !== undefined) {
                                input.value = rewatchValues[index];
                            }
                        });
                        episodeLengthInputs.forEach((input, index) => {
                            if (episodeLengthValues[index] !== undefined) {
                                input.value = episodeLengthValues[index];
                            } else {
                                input.value = anime.episodeLength || 24; // fallback do głównej długości odcinka
                            }
                        });
                        seasonDateInputs.forEach((input, index) => {
                            if (seasonCompletedDates[index]) {
                                input.value = seasonCompletedDates[index];
                            }
                        });
                        updateTotalEpisodesFromSeasons();
                    }, 10);
                } else {
                    seasonCountInput.value = 1;
                    seasonsContainer.innerHTML = '';
                    seasonsContainer.style.display = 'none';
                    totalEpisodesInput.readOnly = false;
                }
            }

            // Obsługa przycisku 'Pokaż sezony' (toggle)
            animeListContainer.addEventListener('click', function(e) {
                const row = e.target.closest('.odcinki-row');
                if (row) {
                    const id = row.dataset.id;
                    const el = document.getElementById('seasons-progress-' + id);
                    if (el) {
                        const isCurrentlyVisible = el.style.display !== 'none' && el.style.display !== '' ? true : el.style.display === '';
                        // Chowamy wszystkie inne
                        document.querySelectorAll("[id^='seasons-progress-']").forEach(function(other) {
                            if (other !== el) {
                                other.style.display = 'none';
                            }
                        });
                        // Jeśli kliknięty był widoczny, chowamy go; jeśli nie, pokazujemy
                        if (isCurrentlyVisible) {
                            el.style.display = 'none';
                        } else {
                            el.style.display = '';
                        }
                    }
                }
            });

            const sortSelect = document.getElementById('sort-select');
            const searchInput = document.getElementById('search-input');
            const collectionControls = document.getElementById('collection-controls');

            // Sortowanie select
            sortSelect.addEventListener('change', function() {
                currentSort = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Wyszukiwarka na bieżąco
            searchInput.addEventListener('input', function() {
                currentSearch = this.value;
                collectionPage = 1;
                showAllCollection = false;
                renderAnimeList();
            });

            // Obsługa przycisków
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.onclick = function() {
                    collectionPage++;
                    renderAnimeList();
                };
            }
            const showAllBtn = document.getElementById('show-all-btn');
            if (showAllBtn) {
                showAllBtn.onclick = function() {
                    showAllCollection = true;
                    renderAnimeList();
                };
            }
            const showLessBtn = document.getElementById('show-less-btn');
            if (showLessBtn) {
                showLessBtn.onclick = function() {
                    showAllCollection = false;
                    collectionPage = 1;
                    renderAnimeList();
                };
            }

            // Obsługa kliknięcia na statystyki profilu
            function renderProfileAnimeList(type) {
                let list = [];
                let label = '';
                let sortBy = 'title';
                let sortDir = 'asc';
                // Zapamiętaj sortowanie dla tej listy
                if (!renderProfileAnimeList.sortState) renderProfileAnimeList.sortState = {};
                if (renderProfileAnimeList.sortState[type]) {
                    sortBy = renderProfileAnimeList.sortState[type].by;
                    sortDir = renderProfileAnimeList.sortState[type].dir;
                }
                if (type === 'completed') {
                    list = animeList.filter(a => a.status === 'completed');
                    label = 'Obejrzane';
                } else if (type === 'watching') {
                    list = animeList.filter(a => a.status === 'watching');
                    label = 'Oglądane';
                } else if (type === 'upcoming') {
                    list = plannerList;
                    label = 'Planowane';
                } else if (type === 'all') {
                    list = animeList;
                    label = 'Wszystkie';
                }
                // Sortowanie
                if (type === 'upcoming') {
                    // Dla planera sortuj po priorytecie
                    const priorityOrder = { 'duży': 1, 'średni': 2, 'niski': 3 };
                    list = [...list].sort((a, b) => {
                        const cmp = priorityOrder[a.priority] - priorityOrder[b.priority];
                        return sortDir === 'asc' ? cmp : -cmp;
                    });
                } else {
                    // Dla głównej listy anime
                    if (sortBy === 'averageRating') {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.averageRating - b.averageRating : b.averageRating - a.averageRating);
                    } else if (sortBy === 'status') {
                        const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                        list = [...list].sort((a, b) => {
                            const cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            return sortDir === 'asc' ? cmp : -cmp;
                        });
                    } else {
                        list = [...list].sort((a, b) => sortDir === 'asc' ? a.title.localeCompare(b.title) : b.title.localeCompare(a.title));
                    }
                }
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kategorii "${label}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label} anime</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                
                if (type === 'upcoming') {
                    // Dla planera
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-priority'>Priorytet ${sortBy==='priority'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;'>Notatki</th>
                        ${type === 'completed' ? '<th style="text-align:left;padding:8px 4px;">Data ukończenia</th>' : ''}
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        const priorityClass = `priority-${a.priority}`;
                        const notes = a.notes && a.notes.trim() ? a.notes : '-';
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'><span class='priority-badge ${priorityClass}' style='font-size:0.7rem;padding:2px 8px;'>${a.priority}</span></td>
                            <td style='padding:8px 4px;font-size:0.9rem;color:var(--gray);'>${notes}</td>
                            ${type === 'completed' ? `<td style='padding:8px 4px;color:var(--accent);font-size:0.9rem;'>${a.completedDate ? formatDate(a.completedDate) : 'Brak daty'}</td>` : ''}
                        </tr>`;
                    });
                } else {
                    // Dla głównej listy anime
                    html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-avg-rating'>Średnia ocena ${sortBy==='averageRating'?(sortDir==='asc'?'▲':'▼'):''}</th>
                        ${type === 'completed' ? '<th style="text-align:left;padding:8px 4px;">Data ukończenia</th>' : ''}
                    </tr></thead><tbody>`;
                    list.forEach(a => {
                        html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                            <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                            <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                            <td style='padding:8px 4px;'>${a.averageRating}</td>
                            ${type === 'completed' ? `<td style='padding:8px 4px;color:var(--accent);font-size:0.9rem;'>${a.completedDate ? formatDate(a.completedDate) : 'Brak daty'}</td>` : ''}
                        </tr>`;
                    });
                }
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania po średniej ocenie
                document.getElementById('sort-avg-rating').onclick = function() {
                    if (sortBy === 'averageRating') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'averageRating';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-title').onclick = function() {
                    if (sortBy === 'title') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'title';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                document.getElementById('sort-status').onclick = function() {
                    if (sortBy === 'status') {
                        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortBy = 'status';
                        sortDir = 'asc';
                    }
                    renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                    renderProfileAnimeList(type);
                };
                
                // Dla planera dodaj sortowanie po priorytecie
                if (type === 'upcoming') {
                    document.getElementById('sort-priority').onclick = function() {
                        if (sortBy === 'priority') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'priority';
                            sortDir = 'asc';
                        }
                        renderProfileAnimeList.sortState[type] = {by: sortBy, dir: sortDir};
                        renderProfileAnimeList(type);
                    };
                }
            }
            
            // Render rating breakdown
            function renderRatingBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz statystyki ocen
                const ratedAnime = animeList.filter(a => a.averageRating > 0);
                
                if (ratedAnime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak ocenionych anime</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Oblicz średnie dla każdej kategorii
                const categories = ['graphics', 'music', 'characters', 'story', 'fun'];
                const categoryNames = {
                    'graphics': 'Grafika',
                    'music': 'Muzyka', 
                    'characters': 'Postacie',
                    'story': 'Fabuła',
                    'fun': 'Śmieszność'
                };
                
                const averages = {};
                categories.forEach(cat => {
                    const sum = ratedAnime.reduce((acc, anime) => acc + anime.ratings[cat], 0);
                    averages[cat] = (sum / ratedAnime.length).toFixed(2);
                });
                
                // Sortuj kategorie po średniej
                const sortedCategories = categories.sort((a, b) => parseFloat(averages[b]) - parseFloat(averages[a]));
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowe statystyki ocen</h3>`;
                html += `<div style='display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:1rem;margin-bottom:1rem;'>`;
                
                sortedCategories.forEach(cat => {
                    const avg = parseFloat(averages[cat]);
                    const percentage = (avg / 11) * 100;
                    const color = avg >= 8 ? 'var(--success)' : avg >= 6 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<div style='background:rgba(0,0,0,0.3);border-radius:8px;padding:1rem;text-align:center;'>
                        <div style='font-size:1.2rem;font-weight:600;color:${color};'>${avg}</div>
                        <div style='font-size:0.9rem;color:var(--gray);margin-bottom:0.5rem;'>${categoryNames[cat]}</div>
                        <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:6px;width:100%;'>
                            <div style='background:${color};height:100%;border-radius:4px;width:${percentage}%;'></div>
                        </div>
                    </div>`;
                });
                
                html += `</div>`;
                
                // Dodaj tabelę z najlepszymi anime w każdej kategorii
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Kategoria</th>
                    <th style='text-align:left;padding:8px 4px;'>Najlepsze anime</th>
                    <th style='text-align:left;padding:8px 4px;'>Ocena</th>
                </tr></thead><tbody>`;
                
                categories.forEach(cat => {
                    const bestAnime = ratedAnime.reduce((best, current) => 
                        current.ratings[cat] > best.ratings[cat] ? current : best
                    );
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${categoryNames[cat]}</td>
                        <td style='padding:8px 4px;'>${bestAnime.title}</td>
                        <td style='padding:8px 4px;color:var(--primary);font-weight:600;'>${bestAnime.ratings[cat]}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render progress breakdown
            function renderProgressBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz postęp dla każdego anime
                const animeWithProgress = animeList.map(anime => {
                    const progress = anime.status === 'completed' ? 100 : 
                                   Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);
                    return {
                        ...anime,
                        progress
                    };
                });
                
                if (animeWithProgress.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                
                // Sortuj po postępie (malejąco)
                animeWithProgress.sort((a, b) => b.progress - a.progress);
                
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Postęp oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Odcinki</th>
                    <th style='text-align:left;padding:8px 4px;'>Postęp</th>
                </tr></thead><tbody>`;
                
                animeWithProgress.forEach(anime => {
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : 
                                     anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const progressColor = anime.progress === 100 ? 'var(--success)' : 
                                        anime.progress >= 50 ? 'var(--warning)' : 'var(--danger)';
                    
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${anime.watchedEpisodes}/${anime.totalEpisodes}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressColor};height:100%;border-radius:4px;width:${anime.progress}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${anime.progress}%</span>
                            </div>
                        </td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }
            
            // Render time breakdown
            function renderTimeBreakdown() {
                const container = document.getElementById('profile-anime-list');
                
                // Oblicz czas dla każdego anime
                const animeWithTime = animeList.map(anime => {
                    let mainTime = 0;
                    let fullTime = 0;
                    
                    if (anime.seasons && anime.seasons.length > 1) {
                        // Oblicz czas dla każdego sezonu osobno
                        let watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        anime.seasons.forEach((episodeCount, index) => {
                            const watchedThis = Math.max(0, Math.min(watched, episodeCount));
                            const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                ? anime.seasonEpisodeLengths[index] 
                                : anime.episodeLength;
                            mainTime += watchedThis * episodeLength;
                            fullTime += episodeCount * episodeLength;
                            watched -= watchedThis;
                        });
                    } else {
                        // Standardowe obliczenie dla pojedynczego sezonu
                        const watchedEpisodes = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                        mainTime = watchedEpisodes * anime.episodeLength;
                        fullTime = anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    let rewatchTime = 0;
                    if (anime.seasonRewatches && anime.seasonRewatches.length > 0) {
                        anime.seasonRewatches.forEach((count, index) => {
                            if (count > 0 && anime.seasons && anime.seasons[index]) {
                                const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] 
                                    ? anime.seasonEpisodeLengths[index] 
                                    : anime.episodeLength;
                                rewatchTime += count * anime.seasons[index] * episodeLength;
                            }
                        });
                    } else if (anime.rewatchCount) {
                        rewatchTime = anime.rewatchCount * anime.totalEpisodes * anime.episodeLength;
                    }
                    
                    const totalTime = mainTime + rewatchTime;
                    
                    return {
                        ...anime,
                        mainTime,
                        rewatchTime,
                        totalTime,
                        fullTime
                    };
                }); // Pokaż wszystkie anime
                
                if (animeWithTime.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime w kolekcji</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                

                
                // Sortowanie dla czasu oglądania
                if (!renderTimeBreakdown.sortState) {
                    renderTimeBreakdown.sortState = { sortBy: 'totalTime', sortDir: 'desc' };
                }
                let sortBy = renderTimeBreakdown.sortState.sortBy;
                let sortDir = renderTimeBreakdown.sortState.sortDir;
                
                // Sortuj listę
                animeWithTime.sort((a, b) => {
                    let cmp = 0;
                    switch(sortBy) {
                        case 'title':
                            cmp = a.title.localeCompare(b.title);
                            break;
                        case 'status':
                            const statusOrder = { 'completed': 1, 'watching': 2, 'upcoming': 3 };
                            cmp = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                            break;
                        case 'totalTime':
                            cmp = a.totalTime - b.totalTime;
                            break;
                        case 'fullTime':
                            cmp = a.fullTime - b.fullTime;
                            break;
                        case 'progress':
                            const progressA = a.totalTime > 0 ? (a.totalTime / a.fullTime) * 100 : 0;
                            const progressB = b.totalTime > 0 ? (b.totalTime / b.fullTime) * 100 : 0;
                            cmp = progressA - progressB;
                            break;
                        case 'percentOfTotal':
                            cmp = a.percentOfTotal - b.percentOfTotal;
                            break;
                        default:
                            cmp = b.totalTime - a.totalTime;
                    }
                    return sortDir === 'asc' ? cmp : -cmp;
                });
                
                let totalWatchTime = animeWithTime.reduce((sum, anime) => sum + anime.totalTime, 0);
                // Dodaj percentOfTotal do każdego anime PRZED sortowaniem
                animeWithTime.forEach(anime => {
                    anime.percentOfTotal = totalWatchTime > 0 ? (anime.totalTime / totalWatchTime) * 100 : 0;
                });
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>Szczegółowy czas oglądania</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-title'>Tytuł ${sortBy==='title'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-status'>Status ${sortBy==='status'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-total-time'>Czas oglądany ${sortBy==='totalTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-full-time'>Pełna długość ${sortBy==='fullTime'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;cursor:pointer;text-decoration:underline;' id='sort-progress'>Postęp ${sortBy==='progress'?(sortDir==='asc'?'▲':'▼'):''}</th>
                    <th style='text-align:left;padding:8px 4px;'>% całości</th>
                </tr></thead><tbody>`;
                
                animeWithTime.forEach(anime => {
                    const progressPercent = anime.totalTime > 0 ? Math.round((anime.totalTime / anime.fullTime) * 100) : 0;
                    const statusText = anime.status === 'completed' ? 'Obejrzane' : anime.status === 'watching' ? 'Oglądane' : 'Nadchodzące';
                    const rewatchInfo = anime.rewatchTime > 0 ? ` <span style='color:var(--primary);font-size:0.8em;'>(+${formatTime(anime.rewatchTime)} rewatch)</span>` : '';
                    
                    // Dla anime z czasem 0, pokaż specjalny tekst
                    const timeDisplay = anime.totalTime > 0 ? `${formatTime(anime.totalTime)}${rewatchInfo}` : '0h';
                    const progressBarColor = anime.totalTime > 0 ? 'linear-gradient(90deg, var(--primary), var(--accent))' : 'rgba(255,255,255,0.2)';
                    const percentOfTotal = totalWatchTime > 0 ? ((anime.totalTime / totalWatchTime) * 100).toFixed(1) : '0.0';
                    anime.percentOfTotal = parseFloat(percentOfTotal); // for sorting
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${anime.title}</td>
                        <td style='padding:8px 4px;'>${statusText}</td>
                        <td style='padding:8px 4px;'>${timeDisplay}</td>
                        <td style='padding:8px 4px;'>${formatTime(anime.fullTime)}</td>
                        <td style='padding:8px 4px;'>
                            <div style='background:rgba(0,0,0,0.3);border-radius:4px;height:8px;width:100px;position:relative;'>
                                <div style='background:${progressBarColor};height:100%;border-radius:4px;width:${progressPercent}%;'></div>
                                <span style='position:absolute;top:-18px;right:0;font-size:0.8rem;color:var(--gray);'>${progressPercent}%</span>
                            </div>
                        </td>
                        <td style='padding:8px 4px;'>${anime.percentOfTotal.toFixed(1)}%</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
                
                // Obsługa sortowania
                function assignTimeBreakdownSortHandlers() {
                    document.getElementById('sort-title').onclick = function() {
                        if (sortBy === 'title') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'title';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-status').onclick = function() {
                        if (sortBy === 'status') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'status';
                            sortDir = 'asc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-total-time').onclick = function() {
                        if (sortBy === 'totalTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'totalTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-full-time').onclick = function() {
                        if (sortBy === 'fullTime') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'fullTime';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                    document.getElementById('sort-progress').onclick = function() {
                        if (sortBy === 'progress') {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortBy = 'progress';
                            sortDir = 'desc';
                        }
                        renderTimeBreakdown.sortState = {sortBy, sortDir};
                        renderTimeBreakdown();
                    };
                }
                assignTimeBreakdownSortHandlers();
            }
            
            // Podpinam kliknięcia na statystyki
            setTimeout(() => {
                document.getElementById('total-completed').parentElement.onclick = () => renderProfileAnimeList('completed');
                document.getElementById('total-upcoming').parentElement.onclick = () => renderProfileAnimeList('upcoming');
                document.getElementById('total-watching').parentElement.onclick = () => renderProfileAnimeList('watching');
                document.getElementById('total-all').parentElement.onclick = () => renderProfileAnimeList('all');

            }, 0);

            // Po wygenerowaniu kart anime w renderAnimeList:
            animeListContainer.querySelectorAll('.odcinki-row').forEach(row => {
                const clickable = row.querySelector('.rating-value');
                if (clickable) {
                    clickable.style.cursor = 'pointer';
                    clickable.onclick = function(e) {
                        e.stopPropagation();
                        const id = row.dataset.id;
                        const el = document.getElementById('seasons-progress-' + id);
                        if (el) {
                            el.style.display = (el.style.display === 'block') ? 'none' : 'block';
                        }
                    };
                }
            });
            
            // Planner functionality
            const addToPlannerBtn = document.getElementById('add-to-planner');
            const plannerTitleInput = document.getElementById('planner-title');
            const plannerPrioritySelect = document.getElementById('planner-priority');
            const plannerNotesTextarea = document.getElementById('planner-notes');
            const plannerTagsInput = document.getElementById('planner-tags');
            
            addToPlannerBtn.addEventListener('click', function() {
                const title = plannerTitleInput.value.trim();
                const priority = plannerPrioritySelect.value;
                const notes = plannerNotesTextarea.value.trim();
                const tagsRaw = plannerTagsInput.value.trim();
                const tags = tagsRaw ? tagsRaw.split(/;|\n/).map(t => t.trim()).filter(Boolean) : [];
                const seasonCount = parseInt(plannerSeasonCountInput.value);
                let seasons = [];
                let seasonEpisodeLengths = [];
                if (seasonCount > 1) {
                    const seasonInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episodes');
                    const episodeLengthInputs = document.querySelectorAll('#planner-seasons-container .planner-season-episode-length');
                    seasonInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasons.push(isNaN(v) ? 0 : v);
                    });
                    episodeLengthInputs.forEach(input => {
                        const v = parseInt(input.value);
                        seasonEpisodeLengths.push(isNaN(v) ? 24 : v);
                    });
                }
                const totalEpisodes = parseInt(plannerTotalEpisodesInput.value) || 12;
                if (!title) {
                    showNotification('Proszę wprowadzić tytuł anime!', 'danger');
                    return;
                }
                // Check if editing
                const editId = this.dataset.editId;
                if (editId) {
                    // Update existing item
                    const index = plannerList.findIndex(item => item.id === parseInt(editId));
                    if (index !== -1) {
                        plannerList[index] = {
                            ...plannerList[index],
                            title,
                            priority,
                            notes,
                            seasonCount,
                            seasons: seasons.length > 1 ? seasons : undefined,
                            seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                            totalEpisodes,
                            tags
                        };
                        savePlannerList();
                        renderPlannerList();
                        showNotification('Anime zostało zaktualizowane w planerze!', 'success');
                    }
                    // Reset form
                    this.innerHTML = '<i class="fas fa-plus"></i> Dodaj do planera';
                    delete this.dataset.editId;
                } else {
                    // Add new item
                    const plannerItem = {
                        id: Date.now(),
                        title,
                        priority,
                        notes,
                        createdAt: new Date().toISOString(),
                        seasonCount,
                        seasons: seasons.length > 1 ? seasons : undefined,
                        seasonEpisodeLengths: seasonEpisodeLengths.length > 1 ? seasonEpisodeLengths : undefined,
                        totalEpisodes,
                        tags
                    };
                    plannerList.push(plannerItem);
                    savePlannerList();
                    renderPlannerList();
                    showNotification('Anime zostało dodane do planera!', 'success');
                }
                // Clear form
                plannerTitleInput.value = '';
                plannerPrioritySelect.value = 'średni';
                plannerNotesTextarea.value = '';
                plannerTagsInput.value = '';
                plannerSeasonCountInput.value = 1;
                plannerSeasonsContainer.innerHTML = '';
                plannerSeasonsContainer.style.display = 'none';
                plannerTotalEpisodesInput.value = 12;
            });
            
            // Initial render of planner
            renderPlannerList();

            const plannerSeasonCountInput = document.getElementById('planner-season-count');
            const plannerSeasonsContainer = document.getElementById('planner-seasons-container');
            const plannerTotalEpisodesInput = document.getElementById('planner-total-episodes');

            function renderPlannerSeasonInputs(count, values=[], episodeLengths=[]) {
                plannerSeasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const episodeLength = episodeLengths[i] || '';
                    plannerSeasonsContainer.innerHTML += `
                        <div style='margin-bottom:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:4px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='planner-season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='planner-season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                        </div>
                    `;
                }
                plannerSeasonsContainer.style.display = count > 1 ? '' : 'none';
                plannerTotalEpisodesInput.readOnly = count > 1;
            }

            plannerSeasonCountInput.addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderPlannerSeasonInputs(count);
                } else {
                    plannerSeasonsContainer.innerHTML = '';
                    plannerSeasonsContainer.style.display = 'none';
                    plannerTotalEpisodesInput.readOnly = false;
                }
                updatePlannerTotalEpisodesFromSeasons();
            });

            plannerSeasonsContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('planner-season-episodes')) {
                    updatePlannerTotalEpisodesFromSeasons();
                }
            });

            function updatePlannerTotalEpisodesFromSeasons() {
                const seasonInputs = plannerSeasonsContainer.querySelectorAll('.planner-season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                plannerTotalEpisodesInput.value = sum > 0 ? sum : '';
            }

            // Funkcje kalendarza aktywności
            function saveActivityData() {
                localStorage.setItem('activityData', JSON.stringify(activityData));
                localStorage.setItem('activityDetails', JSON.stringify(activityDetails));
            }
            
            function getActivityLevel(episodes) {
                if (episodes === 0) return 0;
                if (episodes <= 2) return 1;
                if (episodes <= 4) return 2;
                if (episodes <= 6) return 3;
                if (episodes <= 8) return 4;
                return 5;
            }

            // Funkcje obliczające watch streak
            function getCurrentStreak() {
                const today = new Date();
                let currentStreak = 0;
                let checkDate = new Date(today);
                
                while (true) {
                    const dateStr = checkDate.toISOString().split('T')[0];
                    
                    if (activityData[dateStr] && activityData[dateStr] > 0) {
                        currentStreak++;
                        checkDate.setDate(checkDate.getDate() - 1);
                    } else {
                        break;
                    }
                }
                
                return currentStreak;
            }

            function getLongestStreak() {
                const dates = Object.keys(activityData).filter(date => activityData[date] > 0).sort();
                
                if (dates.length === 0) {
                    return { length: 0, startDate: null, endDate: null };
                }

                let longestStreak = 0;
                let longestStartDate = null;
                let longestEndDate = null;
                
                let currentStreak = 1;
                let currentStartDate = dates[0];
                let currentEndDate = dates[0];

                for (let i = 1; i < dates.length; i++) {
                    const prevDate = new Date(dates[i - 1]);
                    const currentDate = new Date(dates[i]);
                    
                    // Sprawdź czy daty są kolejne (różnica 1 dzień)
                    const dayDiff = (currentDate - prevDate) / (1000 * 60 * 60 * 24);
                    
                    if (dayDiff === 1) {
                        currentStreak++;
                        currentEndDate = dates[i];
                    } else {
                        // Zakończ obecny streak i sprawdź czy to najdłuższy
                        if (currentStreak > longestStreak) {
                            longestStreak = currentStreak;
                            longestStartDate = currentStartDate;
                            longestEndDate = currentEndDate;
                        }
                        
                        // Rozpocznij nowy streak
                        currentStreak = 1;
                        currentStartDate = dates[i];
                        currentEndDate = dates[i];
                    }
                }
                
                // Sprawdź ostatni streak
                if (currentStreak > longestStreak) {
                    longestStreak = currentStreak;
                    longestStartDate = currentStartDate;
                    longestEndDate = currentEndDate;
                }

                return {
                    length: longestStreak,
                    startDate: longestStartDate,
                    endDate: longestEndDate
                };
            }
            
            // Zmienne dla widoku miesięcznego
            let currentMonth = new Date().getMonth();
            let isMobileView = window.innerWidth <= 768;
            let selectedMonth = null; // null = widok lat, number = widok konkretnego miesiąca
            
            function renderActivityCalendar() {
                const container = document.getElementById('calendar-container');
                if (!container) return;
                
                // Sprawdź czy to mobile
                isMobileView = window.innerWidth <= 768;
                
                if (isMobileView) {
                    renderMobileCalendar(container);
                } else {
                    if (selectedMonth !== null) {
                        renderDesktopMonthView(container);
                    } else {
                        renderDesktopCalendar(container);
                    }
                }
            }
            
            function renderDesktopMonthView(container) {
                const months = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                const days = ['Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob', 'Nie'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-month-title clickable" id="month-title-clickable" title="Kliknij aby wrócić do lat">${months[selectedMonth]} ${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-month">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-month">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <div class="desktop-month-grid">
                        ${days.map(day => `<div class="desktop-month-label">${day}</div>`).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-month').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth--;
                        if (selectedMonth < 0) {
                            selectedMonth = 11;
                            currentYear--;
                        }
                        renderActivityCalendar();
                    });
                });
                
                document.getElementById('next-month').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth++;
                        if (selectedMonth > 11) {
                            selectedMonth = 0;
                            currentYear++;
                        }
                        renderActivityCalendar();
                    });
                });
                
                // Dodaj event listener dla kliknięcia na tytuł miesiąca
                document.getElementById('month-title-clickable').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth = null;
                        renderActivityCalendar();
                    });
                });
                
                // Renderuj dni miesięcznego widoku
                renderDesktopMonthDays();
                
                // Dodaj obsługę swipe
                addSwipeSupport(container);
            }
            
            function renderDesktopCalendar(container) {
                const months = ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'];
                const days = ['Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob', 'Nie'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-year clickable" id="year-clickable" title="Kliknij aby zobaczyć aktualny miesiąc">${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-year">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-year">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>

                    </div>
                    <div class="calendar-grid">
                        <div class="calendar-labels">
                            ${days.map(day => `<div>${day}</div>`).join('')}
                        </div>
                        <div>
                            <div class="calendar-months">
                                ${months.map(month => `<div class="calendar-month">${month}</div>`).join('')}
                            </div>
                            <div class="calendar-days" id="calendar-days">
                            </div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-year').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        currentYear--;
                        renderActivityCalendar();
                    });
                });
                
                document.getElementById('next-year').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        currentYear++;
                        renderActivityCalendar();
                    });
                });
                

                
                // Dodaj event listener dla kliknięcia na rok
                document.getElementById('year-clickable').addEventListener('click', () => {
                    animateCalendarTransition(() => {
                        selectedMonth = new Date().getMonth(); // Aktualny miesiąc
                        renderActivityCalendar();
                    });
                });
                

                
                // Renderuj dni
                renderCalendarDays();
                
                // Dodaj obsługę swipe dla mobile
                addSwipeSupport(container);
            }
            
            function renderMobileCalendar(container) {
                const months = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                const days = ['Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob', 'Nie'];
                
                let html = `
                    <div class="calendar-header">
                        <div class="calendar-month-title clickable" id="mobile-month-title" title="Kliknij aby zobaczyć podsumowanie miesiąca">${months[currentMonth]} ${currentYear}</div>
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="prev-month">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="calendar-nav-btn" id="next-month">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mobile-calendar-grid">
                        <div class="mobile-calendar-labels">
                            ${days.map(day => `<div class="mobile-calendar-label">${day}</div>`).join('')}
                        </div>
                        <div class="mobile-calendar-days" id="mobile-calendar-days">
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Dodaj event listeners dla nawigacji
                document.getElementById('prev-month').addEventListener('click', () => {
                    currentMonth--;
                    if (currentMonth < 0) {
                        currentMonth = 11;
                        currentYear--;
                    }
                    renderActivityCalendar();
                });
                
                document.getElementById('next-month').addEventListener('click', () => {
                    currentMonth++;
                    if (currentMonth > 11) {
                        currentMonth = 0;
                        currentYear++;
                    }
                    renderActivityCalendar();
                });
                
                // Dodaj event listener dla kliknięcia na tytuł miesiąca (podsumowanie)
                document.getElementById('mobile-month-title').addEventListener('click', () => {
                    showMonthDetails(currentMonth);
                });
                
                // Renderuj dni mobilnego kalendarza
                renderMobileCalendarDays();
                
                // Dodaj obsługę swipe dla mobile
                addSwipeSupport(container);
            }
            
            function renderMobileCalendarDays() {
                const daysContainer = document.getElementById('mobile-calendar-days');
                if (!daysContainer) return;
                
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
                const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
                const startDayOfWeek = firstDayOfMonth.getDay(); // 0 = niedziela, 1 = poniedziałek, itd.
                
                // Dostosuj do układu poniedziałek-niedziela
                const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
                
                let html = '';
                
                // Dodaj puste dni z poprzedniego miesiąca
                for (let i = 0; i < adjustedStartDay; i++) {
                    html += '<div class="mobile-calendar-day empty other-month"></div>';
                }
                
                // Dodaj dni bieżącego miesiąca
                for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
                    const date = new Date(currentYear, currentMonth, day);
                    // Użyj lokalnej daty zamiast ISO string aby uniknąć przesunięcia czasowego
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                    const episodes = activityData[dateStr] || 0;
                    const level = getActivityLevel(episodes);
                    
                    const tooltip = episodes > 0 ? 
                        `${dateStr}: ${episodes} odcinków` : 
                        `${dateStr}: Brak aktywności`;
                    
                    html += `
                        <div class="mobile-calendar-day level-${level}" data-date="${dateStr}" data-episodes="${episodes}">
                            ${day}
                            <div class="mobile-calendar-tooltip">${tooltip}</div>
                        </div>
                    `;
                }
                
                // Dodaj puste dni z następnego miesiąca, żeby wypełnić grid
                const totalDays = adjustedStartDay + lastDayOfMonth.getDate();
                const remainingDays = 42 - totalDays; // 6 tygodni * 7 dni = 42
                
                for (let i = 0; i < remainingDays; i++) {
                    html += '<div class="mobile-calendar-day empty other-month"></div>';
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.mobile-calendar-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
            }
            
            function animateCalendarTransition(callback) {
                const daysContainer = document.getElementById('calendar-days');
                if (!daysContainer) {
                    callback();
                    return;
                }
                
                // Animacja fade out
                daysContainer.classList.add('fade-out');
                
                setTimeout(() => {
                    callback();
                    
                    // Animacja fade in
                    setTimeout(() => {
                        daysContainer.classList.remove('fade-out');
                        daysContainer.classList.add('fade-in');
                        
                        setTimeout(() => {
                            daysContainer.classList.remove('fade-in');
                        }, 400);
                    }, 50);
                }, 200);
            }
            
            function renderDesktopMonthDays() {
                const daysContainer = document.querySelector('.desktop-month-grid');
                if (!daysContainer) return;
                
                const firstDayOfMonth = new Date(currentYear, selectedMonth, 1);
                const lastDayOfMonth = new Date(currentYear, selectedMonth + 1, 0);
                const startDayOfWeek = firstDayOfMonth.getDay(); // 0 = niedziela, 1 = poniedziałek, itd.
                
                // Dostosuj do układu poniedziałek-niedziela
                const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
                
                let html = '';
                
                // Dodaj puste dni z poprzedniego miesiąca
                for (let i = 0; i < adjustedStartDay; i++) {
                    html += '<div class="desktop-month-day empty other-month"></div>';
                }
                
                // Dodaj dni bieżącego miesiąca
                for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
                    const date = new Date(currentYear, selectedMonth, day);
                    // Użyj lokalnej daty zamiast ISO string aby uniknąć przesunięcia czasowego
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                    const episodes = activityData[dateStr] || 0;
                    const level = getActivityLevel(episodes);
                    
                    const tooltip = episodes > 0 ? 
                        `${dateStr}: ${episodes} odcinków` : 
                        `${dateStr}: Brak aktywności`;
                    
                    html += `
                        <div class="desktop-month-day level-${level}" data-date="${dateStr}" data-episodes="${episodes}">
                            ${day}
                            <div class="desktop-month-tooltip">${tooltip}</div>
                        </div>
                    `;
                }
                
                // Dodaj puste dni z następnego miesiąca, żeby wypełnić grid
                const totalDays = adjustedStartDay + lastDayOfMonth.getDate();
                const remainingDays = 42 - totalDays; // 6 tygodni * 7 dni = 42
                
                for (let i = 0; i < remainingDays; i++) {
                    html += '<div class="desktop-month-day empty other-month"></div>';
                }
                
                // Usuń istniejące dni (zachowaj etykiety)
                const existingDays = daysContainer.querySelectorAll('.desktop-month-day');
                existingDays.forEach(day => day.remove());
                
                // Dodaj nowe dni na końcu kontenera
                daysContainer.insertAdjacentHTML('beforeend', html);
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.desktop-month-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
            }
            

            
            function renderCalendarDays() {
                const daysContainer = document.getElementById('calendar-days');
                if (!daysContainer) return;
                
                renderYearlyView(daysContainer);
            }
            
            function renderYearlyView(daysContainer) {
                const startDate = new Date(currentYear, 0, 1);
                const endDate = new Date(currentYear, 11, 31);
                
                // Znajdź pierwszy poniedziałek roku
                const firstMonday = new Date(startDate);
                while (firstMonday.getDay() !== 1) {
                    firstMonday.setDate(firstMonday.getDate() - 1);
                }
                
                // Oblicz liczbę tygodni potrzebnych dla całego roku
                const totalDays = Math.ceil((endDate - firstMonday) / (1000 * 60 * 60 * 24)) + 1;
                const weeks = Math.ceil(totalDays / 7);
                
                // Przygotuj tablicę 2D: [dzień_tygodnia][tydzień]
                const calendarGrid = Array(7).fill().map(() => Array(weeks).fill(null));
                
                // Wypełnij grid datami
                for (let week = 0; week < weeks; week++) {
                    for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
                        const currentDate = new Date(firstMonday);
                        currentDate.setDate(firstMonday.getDate() + (week * 7) + dayOfWeek);
                        
                        // dayOfWeek = 0 to poniedziałek (firstMonday), dayOfWeek = 1 to wtorek, itd.
                        // Chcemy: 0=poniedziałek, 1=wtorek, 2=środa, 3=czwartek, 4=piątek, 5=sobota, 6=niedziela
                        const mappedDayOfWeek = dayOfWeek;
                        
                        // Użyj lokalnej daty zamiast ISO string aby uniknąć przesunięcia czasowego
                        const dateStr = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}`;
                        const episodes = activityData[dateStr] || 0;
                        const level = getActivityLevel(episodes);
                        const isCurrentYear = currentDate.getFullYear() === currentYear;
                        
                        calendarGrid[mappedDayOfWeek][week] = {
                            date: dateStr,
                            episodes: episodes,
                            level: level,
                            isCurrentYear: isCurrentYear
                        };
                    }
                }
                
                // Renderuj HTML - każdy rząd to jeden dzień tygodnia
                let html = '';
                // Renderuj każdy tydzień osobno, żeby poniedziałek był pierwszy
                for (let week = 0; week < weeks; week++) {
                    for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
                        const day = calendarGrid[dayOfWeek][week];
                        
                        if (day.isCurrentYear) {
                            const tooltip = day.episodes > 0 ? 
                                `${day.date}: ${day.episodes} odcinków` : 
                                `${day.date}: Brak aktywności`;
                            
                            html += `
                                <div class="calendar-day level-${day.level}" data-date="${day.date}" data-episodes="${day.episodes}" style="grid-row: ${dayOfWeek + 1}; grid-column: ${week + 1};">
                                    <div class="calendar-tooltip">${tooltip}</div>
                                </div>
                            `;
                        } else {
                            html += `<div class="calendar-day empty" style="grid-row: ${dayOfWeek + 1}; grid-column: ${week + 1};"></div>`;
                        }
                    }
                }
                
                daysContainer.innerHTML = html;
                
                // Dodaj event listeners dla kliknięć na dni
                document.querySelectorAll('.calendar-day[data-date]').forEach(day => {
                    day.addEventListener('click', () => {
                        const date = day.dataset.date;
                        const episodes = parseInt(day.dataset.episodes) || 0;
                        showDayDetails(date, episodes);
                    });
                });
                
                // Dodaj event listeners dla hover na etykiety dni
                const dayLabels = document.querySelectorAll('.calendar-labels > div');
                dayLabels.forEach((label, index) => {
                    label.addEventListener('mouseenter', () => {
                        // Przyciemnij wszystkie kwadraty
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.add('dimmed');
                        });
                        
                        // Podświetl kwadraty dla tego dnia tygodnia
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            const dayElement = day;
                            const computedStyle = window.getComputedStyle(dayElement);
                            const gridRow = computedStyle.gridRow;
                            if (gridRow === `${index + 1}`) {
                                dayElement.classList.remove('dimmed');
                            }
                        });
                    });
                    
                    label.addEventListener('mouseleave', () => {
                        // Usuń przyciemnienie ze wszystkich kwadratów
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.remove('dimmed');
                        });
                    });
                });
                
                // Dodaj event listeners dla hover na etykiety miesięcy
                const monthLabels = document.querySelectorAll('.calendar-months > div');
                monthLabels.forEach((label, index) => {
                    label.addEventListener('mouseenter', () => {
                        // Przyciemnij wszystkie kwadraty
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.add('dimmed');
                        });
                        
                        // Podświetl kwadraty dla tego miesiąca
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            const dayElement = day;
                            if (dayElement.dataset.date) {
                                const date = new Date(dayElement.dataset.date);
                                const month = date.getMonth(); // 0-11 (styczeń=0, luty=1, itd.)
                                
                                if (month === index) {
                                    dayElement.classList.remove('dimmed');
                                }
                            }
                        });
                    });
                    
                    label.addEventListener('mouseleave', () => {
                        // Usuń przyciemnienie ze wszystkich kwadratów
                        document.querySelectorAll('.calendar-day').forEach(day => {
                            day.classList.remove('dimmed');
                        });
                    });
                    
                    // Dodaj event listener dla kliknięcia na miesiąc
                    label.addEventListener('click', () => {
                        showMonthDetails(index);
                    });
                });
            }
            
            function showMonthDetails(monthIndex) {
                const modal = document.getElementById('day-summary-modal');
                const dateEl = document.getElementById('day-summary-date');
                const statsEl = document.getElementById('day-summary-stats');
                const animeListEl = document.getElementById('day-summary-anime-list');
                
                // Nazwy miesięcy
                const monthNames = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                                   'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
                
                // Formatuj nagłówek
                dateEl.textContent = `${monthNames[monthIndex]} ${currentYear}`;
                
                // Zbierz dane dla całego miesiąca
                let totalEpisodes = 0;
                let totalMinutes = 0;
                let monthDetails = [];
                let animeStats = {};
                let tagStats = {};
                let mostActiveDayDate = null;
                let mostActiveEpisodes = 0;
                
                // Przejdź przez wszystkie dni miesiąca
                const startDate = new Date(currentYear, monthIndex, 1);
                const endDate = new Date(currentYear, monthIndex + 1, 0); // Ostatni dzień miesiąca
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    // Użyj lokalnej daty zamiast ISO string aby uniknąć przesunięcia czasowego
                    const dateStr = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
                    const episodes = activityData[dateStr] || 0;
                    const details = activityDetails[dateStr] || [];
                    
                    totalEpisodes += episodes;
                    
                    // Znajdź dzień z największą aktywnością
                    if (episodes > mostActiveEpisodes) {
                        mostActiveEpisodes = episodes;
                        mostActiveDayDate = dateStr;
                    }
                    
                    if (episodes > 0) {
                        monthDetails.push(...details);
                        
                        // Oblicz czas oglądania dla tego dnia
                        details.forEach(detail => {
                            const anime = animeList.find(a => a.id === detail.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            totalMinutes += detail.episodes * episodeLength;
                            
                            // Zbierz statystyki anime
                            const title = detail.title;
                            if (!animeStats[title]) {
                                animeStats[title] = {
                                    title: title,
                                    episodes: 0,
                                    animeId: detail.animeId
                                };
                            }
                            animeStats[title].episodes += detail.episodes;
                            
                            // Zbierz statystyki tagów
                            if (anime && anime.tags && Array.isArray(anime.tags)) {
                                anime.tags.forEach(tag => {
                                    if (!tagStats[tag]) {
                                        tagStats[tag] = {
                                            name: tag,
                                            episodes: 0,
                                            animeCount: 0,
                                            animeIds: new Set()
                                        };
                                    }
                                    tagStats[tag].episodes += detail.episodes;
                                    tagStats[tag].animeIds.add(detail.animeId);
                                    tagStats[tag].animeCount = tagStats[tag].animeIds.size;
                                });
                            }
                        });
                    }
                }
                
                if (totalEpisodes > 0) {
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    const timeString = hours > 0 ? 
                        `${hours}h ${minutes > 0 ? minutes + 'm' : ''}` : 
                        `${minutes}m`;
                    
                    // Statystyki miesiąca
                    const uniqueMonthAnime = new Set(monthDetails.map(d => d.animeId)).size;
                    
                    // Przygotuj dane dnia z największą aktywnością
                    let mostActiveDayHtml = '';
                    if (mostActiveDayDate && mostActiveEpisodes > 0) {
                        const date = new Date(mostActiveDayDate);
                        const dayNames = ['niedziela', 'poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek', 'sobota'];
                        const dayName = dayNames[date.getDay()];
                        const day = date.getDate();
                        const month = date.getMonth() + 1;
                        const year = date.getFullYear();
                        
                        mostActiveDayHtml = `
                            <div class="day-summary-stat">
                                <div class="day-summary-stat-value" style="font-size: 1rem; text-transform: capitalize;">${dayName}</div>
                                <div style="font-size: 0.75rem; color: var(--gray); margin-top: 0.25rem;">${day}.${String(month).padStart(2, '0')}.${year}</div>
                                <div style="font-size: 0.8rem; color: var(--lighter); margin-top: 0.25rem; font-weight: 500;">${mostActiveEpisodes} ${mostActiveEpisodes === 1 ? 'odcinek' : mostActiveEpisodes <= 4 ? 'odcinki' : 'odcinków'}</div>
                                <div class="day-summary-stat-label">Dzień z największą aktywnością</div>
                            </div>
                        `;
                    } else {
                        mostActiveDayHtml = `
                            <div class="day-summary-stat">
                                <div class="day-summary-stat-value" style="font-size: 1rem;">-</div>
                                <div style="font-size: 0.75rem; color: var(--gray); margin-top: 0.25rem;">Brak aktywności</div>
                                <div style="font-size: 0.8rem; color: var(--lighter); margin-top: 0.25rem; font-weight: 500;">0 odcinków</div>
                                <div class="day-summary-stat-label">Dzień z największą aktywnością</div>
                            </div>
                        `;
                    }
                    
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${totalEpisodes}</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${timeString}</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${uniqueMonthAnime}</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                        ${mostActiveDayHtml}
                    `;
                    
                    // Lista anime z podsumowaniem
                    if (Object.keys(animeStats).length > 0) {
                        let animeHtml = '';
                        Object.values(animeStats).forEach(group => {
                            const anime = animeList.find(a => a.id === group.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            const animeTime = group.episodes * episodeLength;
                            const animeHours = Math.floor(animeTime / 60);
                            const animeMinutes = animeTime % 60;
                            const animeTimeString = animeHours > 0 ? 
                                `${animeHours}h ${animeMinutes > 0 ? animeMinutes + 'm' : ''}` : 
                                `${animeMinutes}m`;
                            
                            animeHtml += `
                                <div class="day-summary-anime-item">
                                    <div class="day-summary-anime-title">${group.title}</div>
                                    <div class="day-summary-anime-details">
                                        <span class="day-summary-anime-episodes">
                                            <i class="fas fa-play-circle"></i> ${group.episodes} odcinków
                                        </span>
                                        <span class="day-summary-anime-time">
                                            <i class="fas fa-clock"></i> ${animeTimeString}
                                        </span>
                                    </div>
                                </div>
                            `;
                        });
                        animeListEl.innerHTML = animeHtml;
                    } else {
                        animeListEl.innerHTML = `
                            <div class="day-summary-empty">
                                <i class="fas fa-info-circle"></i>
                                Brak szczegółów oglądanych anime
                            </div>
                        `;
                    }
                } else {
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0h</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value" style="font-size: 1rem;">-</div>
                            <div style="font-size: 0.75rem; color: var(--gray); margin-top: 0.25rem;">Brak aktywności</div>
                            <div style="font-size: 0.8rem; color: var(--lighter); margin-top: 0.25rem; font-weight: 500;">0 odcinków</div>
                            <div class="day-summary-stat-label">Dzień z największą aktywnością</div>
                        </div>
                    `;
                    
                    animeListEl.innerHTML = `
                        <div class="day-summary-empty">
                            <i class="fas fa-calendar-times"></i>
                            Brak aktywności w tym miesiącu
                        </div>
                    `;
                }
                
                // Dodaj sekcję z tagami jeśli są jakieś
                if (Object.keys(tagStats).length > 0) {
                    // Sortuj tagi według liczby odcinków (malejąco)
                    const sortedTags = Object.values(tagStats).sort((a, b) => b.episodes - a.episodes);
                    
                    let tagsHtml = `
                        <div class="day-summary-section">
                            <h4 style="margin: 1.5rem 0 1rem 0; color: var(--lighter); font-size: 1.1rem;">
                                <i class="fas fa-tags"></i> Najpopularniejsze tagi
                            </h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                    `;
                    
                    sortedTags.forEach(tag => {
                        const tagTime = tag.episodes * 24; // Przybliżony czas na odcinek
                        const tagHours = Math.floor(tagTime / 60);
                        const tagMinutes = tagTime % 60;
                        const tagTimeString = tagHours > 0 ? 
                            `${tagHours}h ${tagMinutes > 0 ? tagMinutes + 'm' : ''}` : 
                            `${tagMinutes}m`;
                        
                        tagsHtml += `
                            <div class="day-summary-tag-item">
                                <span class="anime-tag">${tag.name}</span>
                                <div class="day-summary-tag-stats">
                                    <span class="day-summary-tag-episodes">
                                        <i class="fas fa-play-circle"></i> ${tag.episodes} odc.
                                    </span>
                                    <span class="day-summary-tag-anime">
                                        <i class="fas fa-film"></i> ${tag.animeCount} anime
                                    </span>
                                    <span class="day-summary-tag-time">
                                        <i class="fas fa-clock"></i> ~${tagTimeString}
                                    </span>
                                </div>
                            </div>
                        `;
                    });
                    
                    tagsHtml += `
                            </div>
                        </div>
                    `;
                    
                    animeListEl.innerHTML += tagsHtml;
                }
                
                modal.classList.add('show');
            }
            
            function showDayDetails(date, episodes) {
                const modal = document.getElementById('day-summary-modal');
                const dateEl = document.getElementById('day-summary-date');
                const statsEl = document.getElementById('day-summary-stats');
                const animeListEl = document.getElementById('day-summary-anime-list');
                
                // Formatuj datę
                const dateObj = new Date(date);
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                dateEl.textContent = dateObj.toLocaleDateString('pl-PL', options);
                
                if (episodes > 0) {
                    const level = getActivityLevel(episodes);
                    const details = activityDetails[date] || [];
                    
                    // Oblicz rzeczywisty czas oglądania na podstawie szczegółów
                    let totalMinutes = 0;
                    details.forEach(detail => {
                        const anime = animeList.find(a => a.id === detail.animeId);
                        const episodeLength = anime ? anime.episodeLength : 24;
                        totalMinutes += detail.episodes * episodeLength;
                    });
                    
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    const timeString = hours > 0 ? 
                        `${hours}h ${minutes > 0 ? minutes + 'm' : ''}` : 
                        `${minutes}m`;
                    
                    // Statystyki
                    const uniqueAnimeCount = new Set(details.map(d => d.animeId)).size;
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${episodes}</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${timeString}</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">${uniqueAnimeCount}</div>
                            <div class="day-summary-stat-label">Anime</div>
                        </div>
                    `;
                    
                    // Lista anime - grupuj według tytułu
                    if (details.length > 0) {
                        // Grupuj odcinki według tytułu anime
                        const groupedAnime = {};
                        details.forEach(detail => {
                            const title = detail.title;
                            if (!groupedAnime[title]) {
                                groupedAnime[title] = {
                                    title: title,
                                    episodes: 0,
                                    animeId: detail.animeId
                                };
                            }
                            groupedAnime[title].episodes += detail.episodes;
                        });
                        
                        let animeHtml = '';
                        Object.values(groupedAnime).forEach(group => {
                            const anime = animeList.find(a => a.id === group.animeId);
                            const episodeLength = anime ? anime.episodeLength : 24;
                            const animeTime = group.episodes * episodeLength;
                            const animeHours = Math.floor(animeTime / 60);
                            const animeMinutes = animeTime % 60;
                            const animeTimeString = animeHours > 0 ? 
                                `${animeHours}h ${animeMinutes > 0 ? animeMinutes + 'm' : ''}` : 
                                `${animeMinutes}m`;
                            
                            animeHtml += `
                                <div class="day-summary-anime-item">
                                    <div class="day-summary-anime-title">${group.title}</div>
                                    <div class="day-summary-anime-details">
                                        <span class="day-summary-anime-episodes">
                                            <i class="fas fa-play-circle"></i> ${group.episodes} odcinków
                                        </span>
                                        <span class="day-summary-anime-time">
                                            <i class="fas fa-clock"></i> ${animeTimeString}
                                        </span>
                                    </div>
                                </div>
                            `;
                        });
                        animeListEl.innerHTML = animeHtml;
                    } else {
                        animeListEl.innerHTML = `
                            <div class="day-summary-empty">
                                <i class="fas fa-info-circle"></i>
                                Brak szczegółów oglądanych anime
                            </div>
                        `;
                    }
                } else {
                    statsEl.innerHTML = `
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0</div>
                            <div class="day-summary-stat-label">Odcinki</div>
                        </div>
                        <div class="day-summary-stat">
                            <div class="day-summary-stat-value">0h</div>
                            <div class="day-summary-stat-label">Czas oglądania</div>
                        </div>

                    `;
                    
                    animeListEl.innerHTML = `
                        <div class="day-summary-empty">
                            <i class="fas fa-calendar-times"></i>
                            Brak aktywności tego dnia
                        </div>
                    `;
                }
                
                modal.classList.add('show');
            }
            
            function getAnimeForDate(date) {
                // Zwraca dane aktywności dla danego dnia
                const episodes = activityData[date] || 0;
                if (episodes > 0) {
                    return [{
                        title: 'Aktywność oglądania',
                        episodes: episodes
                    }];
                }
                return [];
            }
            
            function addActivity(date, episodes, animeId = null) {
                console.log('addActivity:', { date, episodes, animeId }); // Debug
                
                if (!activityData[date]) {
                    activityData[date] = 0;
                    activityDetails[date] = [];
                }
                activityData[date] += episodes;
                
                // Dodaj szczegóły aktywności
                if (animeId) {
                    const anime = animeList.find(a => a.id === animeId);
                    if (anime) {
                        activityDetails[date].push({
                            animeId: animeId,
                            title: anime.title,
                            episodes: episodes
                        });
                        
                        // Aktualizuj datę ostatniego oglądania tylko jeśli to nie jest dodawanie nowego anime
                        if (anime.lastWatchedDate !== date) {
                            anime.lastWatchedDate = date;
                            saveAnimeList();
                        }
                    }
                } else {
                    activityDetails[date].push({
                        animeId: null,
                        title: 'Dodane ręcznie',
                        episodes: episodes
                    });
                }
                
                saveActivityData();
                renderActivityCalendar();
                updateProfileStats();
            }
            
            // Modal do dodawania odcinków
            let currentAnimeId = null;
            
            function showEpisodeModal(animeId) {
                currentAnimeId = animeId;
                const modal = document.getElementById('episode-modal');
                const anime = animeList.find(a => a.id === animeId);
                
                if (anime) {
                    document.getElementById('episode-modal-title').textContent = `Dodaj odcinki - ${anime.title}`;
                }
                
                // Ustaw dzisiejszą datę w lokalnej strefie czasowej
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const todayString = `${year}-${month}-${day}`;
                document.getElementById('episode-date').value = todayString;
                document.getElementById('episode-count').textContent = '1';
                document.getElementById('activity-only').checked = false;
                
                modal.classList.add('show');
            }
            
            function hideEpisodeModal() {
                document.getElementById('episode-modal').classList.remove('show');
                currentAnimeId = null;
            }
            
            // Modal edycji anime
            let editCurrentImageData = null;
            const editImageUpload = document.getElementById('edit-image-upload');
            const editImagePreview = document.getElementById('edit-image-preview');
            
            function showEditAnimeModal(animeId) {
                const anime = animeList.find(a => a.id === animeId);
                if (!anime) return;
                
                const modal = document.getElementById('edit-anime-modal');
                
                // Wypełnij formularz
                document.getElementById('edit-anime-id').value = anime.id;
                document.getElementById('edit-title').value = anime.title;
                document.getElementById('edit-status').value = anime.status;
                document.getElementById('edit-total-episodes').value = anime.totalEpisodes;
                document.getElementById('edit-episode-length').value = anime.episodeLength;
                document.getElementById('edit-watched-episodes').value = anime.watchedEpisodes;
                document.getElementById('edit-graphics').value = anime.ratings.graphics;
                document.getElementById('edit-music').value = anime.ratings.music;
                document.getElementById('edit-characters').value = anime.ratings.characters;
                document.getElementById('edit-story').value = anime.ratings.story;
                document.getElementById('edit-fun').value = anime.ratings.fun;
                document.getElementById('edit-anime-tags').value = anime.tags ? anime.tags.join('; ') : '';
                
                // Wypełnij datę ukończenia jeśli istnieje
                if (anime.completedDate) {
                    document.getElementById('edit-completed-date').value = anime.completedDate;
                } else {
                    document.getElementById('edit-completed-date').value = '';
                }
                
                // Pokaż/ukryj pole daty ukończenia
                toggleEditCompletedDateField();
                
                // Wypełnij pola sezonów jeśli są
                fillEditSeasonInputsIfNeeded(anime);
                
                // Ustaw obrazek jeśli istnieje
                if (anime.image) {
                    editCurrentImageData = anime.image;
                    showEditImagePreview(editCurrentImageData);
                } else {
                    editCurrentImageData = null;
                    showEditImagePlaceholder();
                }
                
                // Oblicz i pokaż średnią
                calculateEditAverage();
                
                modal.classList.add('show');
            }
            
            function hideEditAnimeModal() {
                document.getElementById('edit-anime-modal').classList.remove('show');
            }

            // Modal szczegółów anime
            function showAnimeDetailsModal(animeId) {
                const anime = animeList.find(a => a.id === animeId);
                if (!anime) return;

                const modal = document.getElementById('anime-details-modal');
                document.getElementById('anime-details-modal-title').textContent = anime.title;

                // Calculate watch progress
                const watchProgress = anime.status === 'completed' ? 100 : 
                                    Math.round((anime.watchedEpisodes / anime.totalEpisodes) * 100);

                // Status styling
                let statusClass = '';
                let statusText = '';
                switch(anime.status) {
                    case 'watching':
                        statusClass = 'status-watching';
                        statusText = 'Oglądane';
                        break;
                    case 'completed':
                        statusClass = 'status-completed';
                        statusText = 'Obejrzane';
                        break;
                    case 'upcoming':
                        statusClass = 'status-upcoming';
                        statusText = 'Nadchodzące';
                        break;
                }

                // Format time
                function formatTime(minutes, format = 'mixed') {
                    if (format === 'hours') {
                        const hours = Math.floor(minutes / 60);
                        const mins = minutes % 60;
                        return hours > 0 ? `${hours}h ${mins}min` : `${mins}min`;
                    }
                    
                    const days = Math.floor(minutes / 1440);
                    const hours = Math.floor((minutes % 1440) / 60);
                    const mins = minutes % 60;
                    
                    if (days > 0) {
                        return `${days}d ${hours}h ${mins}min`;
                    } else if (hours > 0) {
                        return `${hours}h ${mins}min`;
                    } else {
                        return `${mins}min`;
                    }
                }

                // Calculate total time
                let totalTime = 0;
                let rewatchCount = 0;
                let mainTime = 0;
                let rewatchTime = 0;

                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    anime.seasons.forEach((eps, seasonIndex) => {
                        const episodeLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[seasonIndex] ? 
                                            anime.seasonEpisodeLengths[seasonIndex] : anime.episodeLength;
                        const seasonRewatches = anime.seasonRewatches && anime.seasonRewatches[seasonIndex] ? 
                                              anime.seasonRewatches[seasonIndex] : 0;
                        
                        mainTime += eps * episodeLength;
                        rewatchTime += eps * episodeLength * seasonRewatches;
                        rewatchCount += seasonRewatches;
                    });
                } else {
                    const watched = anime.status === 'completed' ? anime.totalEpisodes : anime.watchedEpisodes;
                    mainTime = watched * anime.episodeLength;
                    const animeRewatches = anime.rewatches || 0;
                    rewatchTime = watched * anime.episodeLength * animeRewatches;
                    rewatchCount = animeRewatches;
                }

                totalTime = mainTime + rewatchTime;

                // Tags HTML
                let tagsHtml = '';
                if (anime.tags && anime.tags.length) {
                    tagsHtml = `
                        <div style="margin: 1rem 0;">
                            <strong style="color: var(--primary);">Tagi:</strong>
                            <div style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 6px;">
                                ${anime.tags.map(tag => `<span class="anime-tag">${tag}</span>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Seasons info
                let seasonsHtml = '';
                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    seasonsHtml = `
                        <div style="margin: 1rem 0;">
                            <strong style="color: var(--primary);">Sezony (${anime.seasons.length}):</strong>
                            <div style="margin-top: 0.5rem;">
                                ${anime.seasons.map((eps, index) => {
                                    const seasonRewatch = anime.seasonRewatches && anime.seasonRewatches[index] ? anime.seasonRewatches[index] : 0;
                                    const seasonLength = anime.seasonEpisodeLengths && anime.seasonEpisodeLengths[index] ? anime.seasonEpisodeLengths[index] : anime.episodeLength;
                                    return `
                                        <div style="background: rgba(0,0,0,0.2); padding: 8px; margin: 4px 0; border-radius: 6px; border-left: 3px solid var(--accent);">
                                            Sezon ${index + 1}: ${eps} odcinków (${seasonLength}min/odcinek)
                                            ${seasonRewatch > 0 ? `<span style="color: var(--warning);">• ${seasonRewatch}x rewatch</span>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                const content = `
                    <div style="padding: 1rem;">
                        ${anime.image ? `
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <img src="${anime.image}" alt="${anime.title}" style="max-width: 100%; max-height: 200px; border-radius: 12px; object-fit: cover;">
                            </div>
                        ` : ''}
                        
                        <div style="text-align: center; margin-bottom: 1.5rem;">
                            <span class="anime-status ${statusClass}" style="font-size: 1.1rem; padding: 8px 16px; border-radius: 20px; border: 2px solid;">${statusText}</span>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.9rem; color: var(--gray);">Postęp</div>
                                <div style="font-size: 1.3rem; font-weight: bold; color: var(--primary);">${anime.watchedEpisodes}/${anime.totalEpisodes}</div>
                                <div style="font-size: 0.8rem; color: var(--gray);">${watchProgress}%</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 0.9rem; color: var(--gray);">Czas oglądania</div>
                                <div style="font-size: 1.3rem; font-weight: bold; color: var(--accent);">${formatTime(totalTime, 'hours')}</div>
                                ${rewatchCount > 0 ? `<div style="font-size: 0.8rem; color: var(--warning);">${rewatchCount}x rewatch</div>` : ''}
                            </div>
                        </div>

                        ${seasonsHtml}

                        <div style="margin: 1rem 0;">
                            <strong style="color: var(--primary);">Oceny:</strong>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 0.5rem;">
                                <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                                    <strong>Grafika:</strong> <span style="color: var(--accent);">${anime.ratings.graphics}/11</span>
                                </div>
                                <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                                    <strong>Muzyka:</strong> <span style="color: var(--accent);">${anime.ratings.music}/11</span>
                                </div>
                                <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                                    <strong>Postacie:</strong> <span style="color: var(--accent);">${anime.ratings.characters}/11</span>
                                </div>
                                <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                                    <strong>Fabuła:</strong> <span style="color: var(--accent);">${anime.ratings.story}/11</span>
                                </div>
                                <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                                    <strong>Śmieszność:</strong> <span style="color: var(--accent);">${anime.ratings.fun}/11</span>
                                </div>
                                <div style="background: linear-gradient(135deg, var(--primary), var(--accent)); padding: 8px; border-radius: 6px; text-align: center;">
                                    <strong style="color: white;">ŚREDNIA: ${anime.averageRating}/11</strong>
                                </div>
                            </div>
                        </div>

                        ${tagsHtml}

                        ${anime.completedDate ? `
                            <div style="margin: 1rem 0; background: rgba(0,184,148,0.2); padding: 12px; border-radius: 8px; border-left: 3px solid var(--success);">
                                <strong style="color: var(--success);"><i class="fas fa-calendar-check"></i> Ukończono:</strong> ${new Date(anime.completedDate).toLocaleDateString('pl-PL')}
                            </div>
                        ` : ''}

                        ${anime.lastWatchedDate ? `
                            <div style="margin: 1rem 0; background: rgba(9,132,227,0.2); padding: 12px; border-radius: 8px; border-left: 3px solid var(--info);">
                                <strong style="color: var(--info);"><i class="fas fa-clock"></i> Ostatnio oglądano:</strong> ${new Date(anime.lastWatchedDate).toLocaleDateString('pl-PL')}
                            </div>
                        ` : ''}

                        <div style="text-align: center; margin-top: 1.5rem;">
                            <button onclick="showEditAnimeModal(${anime.id}); hideAnimeDetailsModal();" class="btn-primary" style="margin-right: 0.5rem;">
                                <i class="fas fa-edit"></i> Edytuj
                            </button>
                            <button onclick="showEpisodeModal(${anime.id}); hideAnimeDetailsModal();" class="btn-success">
                                <i class="fas fa-plus"></i> Dodaj odcinki
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById('anime-details-content').innerHTML = content;
                modal.classList.add('show');
            }

            function hideAnimeDetailsModal() {
                document.getElementById('anime-details-modal').classList.remove('show');
            }
            
            function toggleEditCompletedDateField() {
                const status = document.getElementById('edit-status').value;
                const completedDateGroup = document.getElementById('edit-completed-date-group');
                if (status === 'completed') {
                    completedDateGroup.style.display = 'block';
                } else {
                    completedDateGroup.style.display = 'none';
                }
            }
            
            function calculateEditAverage() {
                const graphics = parseInt(document.getElementById('edit-graphics').value);
                const music = parseInt(document.getElementById('edit-music').value);
                const characters = parseInt(document.getElementById('edit-characters').value);
                const story = parseInt(document.getElementById('edit-story').value);
                const fun = parseInt(document.getElementById('edit-fun').value);
                
                const average = (graphics + music + characters + story + fun) / 5;
                document.getElementById('edit-average-display').textContent = average.toFixed(1);
            }
            
            // Funkcje obsługi sezonów w modalu edycji
            function renderEditSeasonInputs(count, values=[], rewatchValues=[], episodeLengths=[], seasonCompletedDates=[]) {
                const editSeasonsContainer = document.getElementById('edit-seasons-container');
                const editTotalEpisodesInput = document.getElementById('edit-total-episodes');
                
                editSeasonsContainer.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const val = values[i] || '';
                    const rewatchVal = rewatchValues[i] || 0;
                    const episodeLength = episodeLengths[i] || '';
                    const seasonDate = seasonCompletedDates && seasonCompletedDates[i] ? seasonCompletedDates[i] : '';
                    editSeasonsContainer.innerHTML += `
                        <div style='margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;border:1px solid var(--glass-border);'>
                            <div style='margin-bottom:8px;'>
                                <label style='font-weight:600;color:var(--lighter);'>Sezon ${i+1}:</label>
                                <input type='number' class='edit-season-episodes' min='1' value='${val}' style='width:80px;display:inline-block;margin-left:8px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>odcinków</span>
                                <input type='number' class='edit-season-episode-length' min='1' value='${episodeLength}' placeholder='24' style='width:80px;display:inline-block;margin-left:12px;padding:6px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);'>
                                <span style='margin-left:8px;color:var(--gray);font-size:0.9rem;'>min</span>
                            </div>
                            <div style='margin-left:20px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-redo"></i> Rewatch:</label>
                                <input type='number' class='edit-season-rewatch' min='0' value='${rewatchVal}' style='width:60px;display:inline-block;margin-left:8px;padding:4px;border-radius:4px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);color:var(--lighter);font-size:0.8rem;'>
                                <span style='margin-left:4px;color:var(--gray);font-size:0.8rem;'>razy</span>
                            </div>
                            <div style='margin-top:8px;'>
                                <label style='font-size:0.9rem;color:var(--gray);'><i class="fas fa-calendar-check"></i> Data ukończenia sezonu:</label>
                                <input type='date' class='edit-season-completed-date' value='${seasonDate}' style='margin-left:8px;'>
                            </div>
                        </div>
                    `;
                }
                editSeasonsContainer.style.display = count > 1 ? '' : 'none';
                editTotalEpisodesInput.readOnly = count > 1;
            }
            
            function updateEditTotalEpisodesFromSeasons() {
                const editSeasonsContainer = document.getElementById('edit-seasons-container');
                const editTotalEpisodesInput = document.getElementById('edit-total-episodes');
                const seasonInputs = editSeasonsContainer.querySelectorAll('.edit-season-episodes');
                let sum = 0;
                seasonInputs.forEach(input => {
                    const v = parseInt(input.value);
                    if (!isNaN(v)) sum += v;
                });
                editTotalEpisodesInput.value = sum > 0 ? sum : '';
            }
            
            function fillEditSeasonInputsIfNeeded(anime) {
                const editSeasonCountInput = document.getElementById('edit-season-count');
                if (anime.seasons && Array.isArray(anime.seasons) && anime.seasons.length > 1) {
                    editSeasonCountInput.value = anime.seasons.length;
                    const rewatchValues = anime.seasonRewatches || [];
                    const episodeLengthValues = anime.seasonEpisodeLengths || [];
                    const seasonCompletedDates = anime.seasonCompletedDates || [];
                    renderEditSeasonInputs(anime.seasons.length, anime.seasons, rewatchValues, episodeLengthValues, seasonCompletedDates);
                } else {
                    editSeasonCountInput.value = 1;
                    renderEditSeasonInputs(1);
                }
            }
            
            // Funkcje obsługi zdjęć w modalu edycji
            function showEditImagePreview(imageData) {
                editImagePreview.innerHTML = `
                    <img src="${imageData}" alt="Podgląd obrazka">
                    <button type='button' id='edit-remove-image-btn' class='btn-danger' style='width:100%;margin-top:8px;'>
                        <i class='fas fa-trash'></i> Usuń zdjęcie
                    </button>
                `;
                
                // Dodaj event listener do przycisku usuwania
                document.getElementById('edit-remove-image-btn').onclick = function() {
                    if (confirm('Czy na pewno chcesz usunąć zdjęcie?')) {
                        editCurrentImageData = null;
                        showEditImagePlaceholder();
                    }
                };
            }
            
            function showEditImagePlaceholder() {
                editImagePreview.innerHTML = `
                    <div class="image-preview-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Brak wybranego obrazka</span>
                    </div>
                `;
            }
            
            function resetEditImageUpload() {
                editCurrentImageData = null;
                showEditImagePlaceholder();
                editImageUpload.value = '';
            }
            
            // Event listeners dla modala
            document.getElementById('episode-modal-close').addEventListener('click', hideEpisodeModal);
            document.getElementById('day-summary-close').addEventListener('click', () => {
                document.getElementById('day-summary-modal').classList.remove('show');
            });
            
            // Event listeners dla modalu edycji anime
            document.getElementById('edit-anime-modal-close').addEventListener('click', hideEditAnimeModal);
            document.getElementById('edit-status').addEventListener('change', toggleEditCompletedDateField);
            document.getElementById('edit-clear-date-btn').addEventListener('click', function() {
                document.getElementById('edit-completed-date').value = '';
            });

            // Event listener dla modalu szczegółów anime
            document.getElementById('anime-details-modal-close').addEventListener('click', hideAnimeDetailsModal);
            
            // Event listeners dla obliczania średniej w modalu edycji
            ['edit-graphics', 'edit-music', 'edit-characters', 'edit-story', 'edit-fun'].forEach(id => {
                document.getElementById(id).addEventListener('input', calculateEditAverage);
            });
            
            // Event listeners dla sezonów w modalu edycji
            document.getElementById('edit-season-count').addEventListener('input', function() {
                const count = parseInt(this.value);
                if (count > 1) {
                    renderEditSeasonInputs(count);
                } else {
                    document.getElementById('edit-seasons-container').innerHTML = '';
                    document.getElementById('edit-seasons-container').style.display = 'none';
                    document.getElementById('edit-total-episodes').readOnly = false;
                }
                updateEditTotalEpisodesFromSeasons();
            });
            
            document.getElementById('edit-seasons-container').addEventListener('input', function(e) {
                if (e.target.classList.contains('edit-season-episodes')) {
                    updateEditTotalEpisodesFromSeasons();
                }
            });
            
            // Event listeners dla zdjęć w modalu edycji
            document.getElementById('edit-select-image-btn').addEventListener('click', function() {
                editImageUpload.value = '';
                editImageUpload.click();
            });
            
            editImageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        editCurrentImageData = ev.target.result;
                        showEditImagePreview(editCurrentImageData);
                    };
                    reader.readAsDataURL(file);
                }
                editImageUpload.value = '';
            });

            document.getElementById('episode-decrease').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                if (count > 1) {
                    countEl.textContent = count - 1;
                }
            });
            
            document.getElementById('episode-increase').addEventListener('click', () => {
                const countEl = document.getElementById('episode-count');
                let count = parseInt(countEl.textContent);
                countEl.textContent = count + 1;
            });
            
            document.getElementById('add-episode-btn').addEventListener('click', () => {
                const count = parseInt(document.getElementById('episode-count').textContent);
                const date = document.getElementById('episode-date').value;
                const activityOnly = document.getElementById('activity-only').checked;
                
                console.log('Dodawanie odcinków:', { count, date, currentAnimeId, activityOnly }); // Debug
                
                if (!date) {
                    alert('Proszę wybrać datę');
                    return;
                }
                
                addActivity(date, count, currentAnimeId);
                
                // Zaktualizuj anime tylko jeśli NIE jest zaznaczony "tylko aktywność"
                if (currentAnimeId && !activityOnly) {
                    const anime = animeList.find(a => a.id === currentAnimeId);
                    if (anime) {
                        console.log('Przed dodaniem odcinków:', { 
                            title: anime.title, 
                            watchedEpisodes: anime.watchedEpisodes, 
                            totalEpisodes: anime.totalEpisodes,
                            status: anime.status 
                        });
                        
                        // Sprawdź czy anime było już ukończone PRZED dodaniem nowych odcinków
                        const wasCompletedBefore = checkAnimeCompletion(anime);
                        console.log('Czy było ukończone przed:', wasCompletedBefore);
                        
                        if (wasCompletedBefore) {
                            // To jest rewatch - dodaj do rewatchCount
                            if (!anime.rewatchCount) {
                                anime.rewatchCount = 0;
                            }
                            anime.rewatchCount += count;
                            console.log('Dodano do rewatch:', count);
                        } else {
                            // Normalne dodawanie odcinków
                            anime.watchedEpisodes += count;
                            if (anime.watchedEpisodes > anime.totalEpisodes) {
                                anime.watchedEpisodes = anime.totalEpisodes;
                            }
                            console.log('Po dodaniu odcinków:', { 
                                watchedEpisodes: anime.watchedEpisodes, 
                                totalEpisodes: anime.totalEpisodes 
                            });
                            
                            // Sprawdź czy anime zostało ukończone PO dodaniu nowych odcinków
                            const isNowCompleted = checkAnimeCompletion(anime);
                            console.log('Czy jest ukończone po:', isNowCompleted);
                            if (isNowCompleted && anime.status === 'watching') {
                                anime.status = 'completed';
                                // Usuń automatyczne ustawianie daty ukończenia - niech użytkownik sam decyduje
                                // anime.completedDate = date; // Ustaw datę ukończenia na datę aktywności
                                console.log('Anime zostało ukończone!');
                            }
                            // Zawsze aktualizuj datę ostatniego oglądania
                            anime.lastWatchedDate = date;
                        }
                        
                        console.log('Przed saveAnimeList - animeList length:', animeList.length);
                        saveAnimeList();
                        console.log('Po saveAnimeList - animeList length:', animeList.length);
                        renderAnimeList();
                        renderTierList();
                        updateProfileStats();
                    }
                }
                
                hideEpisodeModal();
                const message = activityOnly ? 'Aktywność została dodana!' : 'Odcinki zostały dodane!';
                showNotification(message, 'success');
            });
            
            // Obsługa formularza edycji anime
            document.getElementById('edit-anime-form').addEventListener('submit', function(e) {
                e.preventDefault();
                
                const animeId = parseInt(document.getElementById('edit-anime-id').value);
                const anime = animeList.find(a => a.id === animeId);
                if (!anime) return;
                
                // Pobierz dane z formularza
                const title = document.getElementById('edit-title').value.trim();
                if (!title) {
                    alert('Proszę wprowadzić tytuł anime');
                    return;
                }
                
                const status = document.getElementById('edit-status').value;
                const seasonCount = parseInt(document.getElementById('edit-season-count').value);
                let totalEpisodes = parseInt(document.getElementById('edit-total-episodes').value);
                const episodeLength = parseInt(document.getElementById('edit-episode-length').value);
                const watchedEpisodes = parseInt(document.getElementById('edit-watched-episodes').value);
                const completedDate = document.getElementById('edit-completed-date').value;
                
                // Obsługa sezonów
                let seasons = [];
                let seasonRewatches = [];
                let seasonEpisodeLengths = [];
                let seasonCompletedDates = [];
                
                if (seasonCount > 1) {
                    const editSeasonsContainer = document.getElementById('edit-seasons-container');
                    const seasonInputs = editSeasonsContainer.querySelectorAll('.edit-season-episodes');
                    const rewatchInputs = editSeasonsContainer.querySelectorAll('.edit-season-rewatch');
                    const episodeLengthInputs = editSeasonsContainer.querySelectorAll('.edit-season-episode-length');
                    const seasonDateInputs = editSeasonsContainer.querySelectorAll('.edit-season-completed-date');
                    
                    seasonInputs.forEach((input, index) => {
                        const episodes = parseInt(input.value) || 0;
                        seasons.push(episodes);
                        
                        const rewatch = parseInt(rewatchInputs[index]?.value) || 0;
                        seasonRewatches.push(rewatch);
                        
                        const length = parseInt(episodeLengthInputs[index]?.value) || episodeLength;
                        seasonEpisodeLengths.push(length);
                        
                        const date = seasonDateInputs[index]?.value || '';
                        seasonCompletedDates.push(date);
                    });
                    
                    // Przelicz totalEpisodes z sezonów
                    totalEpisodes = seasons.reduce((sum, eps) => sum + eps, 0);
                }
                
                // Pobierz tagi
                const tagsRaw = document.getElementById('edit-anime-tags').value.trim();
                let tags = [];
                if (tagsRaw) {
                    tags = tagsRaw.split(/[;\n]/).map(tag => tag.trim()).filter(tag => tag.length > 0);
                }
                
                // Aktualizuj anime
                anime.title = title;
                anime.status = status;
                anime.totalEpisodes = totalEpisodes;
                anime.episodeLength = episodeLength;
                anime.watchedEpisodes = Math.min(watchedEpisodes, totalEpisodes);
                anime.ratings.graphics = parseInt(document.getElementById('edit-graphics').value);
                anime.ratings.music = parseInt(document.getElementById('edit-music').value);
                anime.ratings.characters = parseInt(document.getElementById('edit-characters').value);
                anime.ratings.story = parseInt(document.getElementById('edit-story').value);
                anime.ratings.fun = parseInt(document.getElementById('edit-fun').value);
                anime.tags = tags;
                anime.averageRating = parseFloat(((anime.ratings.graphics + anime.ratings.music + anime.ratings.characters + anime.ratings.story + anime.ratings.fun) / 5).toFixed(1));
                
                // Zapisz dane sezonów
                if (seasonCount > 1) {
                    anime.seasons = seasons;
                    anime.seasonRewatches = seasonRewatches;
                    anime.seasonEpisodeLengths = seasonEpisodeLengths;
                    anime.seasonCompletedDates = seasonCompletedDates;
                } else {
                    // Usuń dane sezonów jeśli przeszło na pojedynczy sezon
                    delete anime.seasons;
                    delete anime.seasonRewatches;
                    delete anime.seasonEpisodeLengths;
                    delete anime.seasonCompletedDates;
                }
                
                // Ustaw datę ukończenia
                if (status === 'completed' && completedDate) {
                    anime.completedDate = completedDate;
                } else if (status !== 'completed') {
                    anime.completedDate = null;
                }
                
                // Zapisz zdjęcie
                if (editCurrentImageData) {
                    anime.image = editCurrentImageData;
                } else {
                    anime.image = null;
                }
                
                // Zapisz zmiany
                saveAnimeList();
                renderAnimeList();
                renderTierList();
                updateProfileStats();
                
                hideEditAnimeModal();
                showNotification('Anime zostało zaktualizowane!', 'success');
            });
            
            // Dodaj funkcję do wyświetlania anime z danym tagiem
            function renderProfileAnimeListByTag(tag) {
                const list = animeList.filter(a => a.tags && a.tags.includes(tag));
                const label = `Anime z tagiem: <span class='anime-tag'>${tag}</span>`;
                const container = document.getElementById('profile-anime-list');
                if (list.length === 0) {
                    container.innerHTML = `<div style='text-align:center;color:var(--gray);'>Brak anime z tagiem "${tag}"</div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div>`;
                    container.style.display = '';
                    document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none'; };
                    return;
                }
                let html = `<div style='background:rgba(0,0,0,0.2);border-radius:12px;padding:1rem;'><h3 style='text-align:center;margin-bottom:1rem;'>${label}</h3>`;
                html += `<div style='overflow-x:auto;'><table style='width:100%;border-collapse:collapse;'>`;
                html += `<thead><tr style='border-bottom:2px solid var(--glass-border);'>
                    <th style='text-align:left;padding:8px 4px;'>Tytuł</th>
                    <th style='text-align:left;padding:8px 4px;'>Status</th>
                    <th style='text-align:left;padding:8px 4px;'>Średnia ocena</th>
                </tr></thead><tbody>`;
                list.forEach(a => {
                    html += `<tr style='border-bottom:1px solid var(--glass-border);'>
                        <td style='padding:8px 4px;font-weight:600;'>${a.title}</td>
                        <td style='padding:8px 4px;'>${a.status === 'completed' ? 'Obejrzane' : a.status === 'watching' ? 'Oglądane' : 'Nadchodzące'}</td>
                        <td style='padding:8px 4px;'>${a.averageRating}</td>
                    </tr>`;
                });
                html += `</tbody></table></div><div style='text-align:center;margin-top:1rem;'><button id='close-profile-list' class='btn-accent'>Zamknij</button></div></div>`;
                container.innerHTML = html;
                container.style.display = '';
                document.getElementById('close-profile-list').onclick = () => { container.style.display = 'none' };
                
                // Przewiń do miejsca gdzie się otwiera lista
                setTimeout(() => {
                    container.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            }

            // Obsługa czyszczenia daty ukończenia
            document.getElementById('clear-completed-date').addEventListener('click', function() {
                document.getElementById('completed-date').value = '';
            });
            
            // Initial render of activity calendar
            renderActivityCalendar();
            
            // Initialize active code display
            updateActiveCodeDisplay();
            
            // Check if active code still exists on server
            checkActiveCodeOnServer();

            // Obsługa pokazywania QR kodu
            document.getElementById('show-qr-btn').addEventListener('click', function() {
                console.log('🔍 show-qr-btn clicked');
                const activeCode = getActiveCode();
                console.log('🔍 activeCode:', activeCode);
                if (!activeCode) {
                    showNotification('Brak aktywnego kodu do wyświetlenia!', 'warning');
                    return;
                }

                const qrInline = document.getElementById('qr-code-inline');
                const qrDisplay = document.getElementById('qr-code-display-inline');
                console.log('🔍 qrInline:', qrInline);
                console.log('🔍 qrDisplay:', qrDisplay);

                if (!qrInline || !qrDisplay) {
                    console.error('🔍 Nie znaleziono elementów QR');
                    showNotification('Błąd: Nie znaleziono elementów QR!', 'danger');
                    return;
                }

                // Wyczyść poprzedni QR
                qrDisplay.innerHTML = '';

                // Generuj pełny URL z kodem jako parametr
                const fullUrl = `https://eppcpl.github.io/anilista/anilista.html?code=${activeCode.code}`;
                console.log('🔍 Generuję QR dla URL:', fullUrl);
                
                // Funkcja do generowania QR kodu z fallback
                function generateQR() {
                    // Spróbuj różne metody generowania QR
                    if (typeof QRCode !== 'undefined') {
                        console.log('🔍 Używam QRCode library');
                        QRCode.toCanvas(qrDisplay, fullUrl, {
                            width: 200,
                            margin: 2,
                            color: {
                                dark: '#000000',
                                light: '#FFFFFF'
                            }
                        }, function(error) {
                            if (error) {
                                console.error('🔍 Błąd generowania QR:', error);
                                tryAlternativeQR();
                            } else {
                                console.log('🔍 QR wygenerowany pomyślnie');
                                showQRAndButton();
                            }
                        });
                    } else if (typeof qrcode !== 'undefined') {
                        console.log('🔍 Używam qrcode-generator library');
                        try {
                            const qr = qrcode(0, 'L');
                            qr.addData(fullUrl);
                            qr.make();
                            const qrImage = qr.createImgTag(5);
                            qrDisplay.innerHTML = qrImage;
                            console.log('🔍 QR wygenerowany pomyślnie (qrcode-generator)');
                            showQRAndButton();
                        } catch (error) {
                            console.error('🔍 Błąd generowania QR (qrcode-generator):', error);
                            tryAlternativeQR();
                        }
                    } else {
                        console.log('🔍 Brak dostępnych bibliotek QR, używam fallback');
                        tryAlternativeQR();
                    }
                }

                // Funkcja fallback dla QR
                function tryAlternativeQR() {
                    // Fallback: wyświetl kod jako tekst z linkiem
                    const fallbackDiv = document.createElement('div');
                    fallbackDiv.style.cssText = `
                        text-align: center;
                        padding: 20px;
                        border: 2px dashed #ccc;
                        border-radius: 8px;
                        background: #f9f9f9;
                        margin: 10px 0;
                    `;
                    fallbackDiv.innerHTML = `
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #333;">
                            Kod: <span style="color: #007bff;">${activeCode.code}</span>
                        </div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 15px;">
                            URL: <span style="color: #007bff; word-break: break-all;">${fullUrl}</span>
                        </div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 15px;">
                            Zeskanuj QR kod lub skopiuj URL
                        </div>
                        <button class="btn-secondary" onclick="navigator.clipboard.writeText('${fullUrl}').then(() => showNotification('URL skopiowany!', 'success')).catch(() => showNotification('Błąd kopiowania!', 'danger'))" style="margin: 5px;">
                            <i class="fas fa-copy"></i> Skopiuj URL
                        </button>
                    `;
                    qrDisplay.appendChild(fallbackDiv);
                    console.log('🔍 Fallback wyświetlony pomyślnie');
                    showQRAndButton();
                }

                // Funkcja do pokazania QR i przycisku
                function showQRAndButton() {
                    // Pokaż QR inline
                    qrInline.style.display = 'block';
                    
                    // Usuń poprzedni przycisk jeśli istnieje
                    const existingBtn = qrInline.querySelector('button');
                    if (existingBtn) {
                        existingBtn.remove();
                    }
                    
                    // Dodaj przycisk do otwarcia URL
                    const openUrlBtn = document.createElement('button');
                    openUrlBtn.className = 'btn-secondary';
                    openUrlBtn.style.cssText = 'margin-top: 1rem; width: 100%;';
                    openUrlBtn.innerHTML = '<i class="fas fa-external-link-alt"></i> Otwórz i wgraj kod';
                    openUrlBtn.onclick = function() {
                        const url = 'https://eppcpl.github.io/anilista/anilista.html?code=' + activeCode.code;
                        window.open(url, '_blank');
                    };
                    qrInline.appendChild(openUrlBtn);
                    console.log('🔍 QR i przycisk dodane pomyślnie');
                }

                // Spróbuj wygenerować QR
                generateQR();
            });

            // Obsługa zamykania modala QR
            document.getElementById('qr-code-close').addEventListener('click', function() {
                const qrModal = document.getElementById('qr-code-modal');
                const timer = qrModal.dataset.timer;
                if (timer) {
                    clearInterval(parseInt(timer));
                    delete qrModal.dataset.timer;
                }
                qrModal.classList.remove('show');
            });



            // Obsługa zamykania modala skanera QR
            document.getElementById('qr-scanner-close').addEventListener('click', function() {
                const qrScannerModal = document.getElementById('qr-scanner-modal');
                const scanner = qrScannerModal.dataset.scanner;
                if (scanner) {
                    scanner.clear();
                    delete qrScannerModal.dataset.scanner;
                }
                qrScannerModal.classList.remove('show');
            });

            // Obsługa wpisywania kodu w polu inline
            document.getElementById('import-code-input-inline').addEventListener('input', function() {
                const code = this.value.replace(/\D/g, ''); // Tylko cyfry
                this.value = code;
                
                if (code.length === 6) {
                    checkImportCode(code);
                    // Automatycznie wykonaj import po 6 cyfrach
                    setTimeout(() => performImport(code), 500);
                } else {
                    // Ukryj podgląd jeśli kod jest niepełny
                    document.getElementById('import-preview-inline').style.display = 'none';
                }
            });



            // Funkcja sprawdzania kodu importu
            async function checkImportCode(code) {
                const preview = document.getElementById('import-preview-inline');
                const previewContent = document.getElementById('import-preview-content-inline');
                
                try {
                    // Pokaż loading
                    previewContent.innerHTML = '<div style="text-align: center; padding: 0.5rem;"><i class="fas fa-spinner fa-spin"></i> Sprawdzanie kodu...</div>';
                    preview.style.display = 'block';
                    
                    // Sprawdź kod na serwerze
                    const transferData = await getDataFromCode(code);
                    
                    if (transferData) {
                        // Pokaż podgląd danych
                        const animeCount = transferData.animeList ? transferData.animeList.length : 0;
                        const plannerCount = transferData.plannerList ? transferData.plannerList.length : 0;
                        const activityDays = transferData.activityData ? Object.keys(transferData.activityData).length : 0;
                        
                        previewContent.innerHTML = `
                            <div style="margin: 0.25rem 0;">📺 Anime: ${animeCount}</div>
                            <div style="margin: 0.25rem 0;">📋 Planer: ${plannerCount}</div>
                            <div style="margin: 0.25rem 0;">📅 Dni aktywności: ${activityDays}</div>
                            <div style="margin: 0.25rem 0; font-size: 0.7rem; color: var(--gray);">
                                Wygenerowano: ${new Date(transferData.createdAt).toLocaleString('pl-PL')}
                            </div>
                        `;
                        
                        preview.style.display = 'block';
                    } else {
                        // Błędny kod
                        previewContent.innerHTML = '<div style="color: var(--danger);">Nieprawidłowy lub wygasły kod!</div>';
                        preview.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Błąd sprawdzania kodu:', error);
                    previewContent.innerHTML = '<div style="color: var(--danger);">Błąd podczas sprawdzania kodu!</div>';
                    preview.style.display = 'block';
                }
            }

            // Funkcja wykonująca import
            async function performImport(code) {
                try {
                    // Pokaż loading w polu input
                    const input = document.getElementById('import-code-input-inline');
                    const originalValue = input.value;
                    input.value = 'Importowanie...';
                    input.disabled = true;
                    
                    const transferData = await getDataFromCode(code);
                    
                    if (!transferData) {
                        showNotification('Kod jest nieprawidłowy lub wygasł!', 'danger');
                        return;
                    }
                    
                    if (confirm('Czy na pewno chcesz wgrać te dane? Obecne dane zostaną połączone z importowanymi.')) {
                        // Połącz dane
                        if (transferData.animeList && Array.isArray(transferData.animeList)) {
                            // Dodaj nowe anime, unikając duplikatów po tytule
                            transferData.animeList.forEach(importedAnime => {
                                const exists = animeList.find(existing => existing.title === importedAnime.title);
                                if (!exists) {
                                    // Nadaj nowe ID żeby uniknąć konfliktów
                                    importedAnime.id = Date.now() + Math.random();
                                    animeList.push(importedAnime);
                                }
                            });
                        }
                        
                        if (transferData.plannerList && Array.isArray(transferData.plannerList)) {
                            // Dodaj nowe pozycje planera
                            transferData.plannerList.forEach(importedItem => {
                                const exists = plannerList.find(existing => existing.title === importedItem.title);
                                if (!exists) {
                                    importedItem.id = Date.now() + Math.random();
                                    plannerList.push(importedItem);
                                }
                            });
                        }
                        
                        if (transferData.activityData && typeof transferData.activityData === 'object') {
                            // Połącz dane aktywności
                            Object.keys(transferData.activityData).forEach(date => {
                                if (!activityData[date]) {
                                    activityData[date] = 0;
                                }
                                activityData[date] += transferData.activityData[date];
                            });
                        }
                        
                        if (transferData.activityDetails && typeof transferData.activityDetails === 'object') {
                            // Połącz szczegóły aktywności
                            Object.keys(transferData.activityDetails).forEach(date => {
                                if (!activityDetails[date]) {
                                    activityDetails[date] = [];
                                }
                                activityDetails[date] = activityDetails[date].concat(transferData.activityDetails[date] || []);
                            });
                        }
                        
                        // Zapisz wszystko lokalnie
                        saveAnimeList();
                        savePlannerList();
                        saveActivityData();
                        
                        // Usuń kod
                        await removeCode(code);
                        
                        // Sprawdź czy to był aktywny kod użytkownika i wyczyść go
                        const activeCode = getActiveCode();
                        if (activeCode && activeCode.code === code) {
                            clearActiveCode();
                            updateActiveCodeDisplay();
                        }
                        
                        // Wyczyść pole tekstowe i podgląd
                        document.getElementById('import-code-input-inline').value = '';
                        document.getElementById('import-preview-inline').style.display = 'none';
                        
                        // Odśwież widoki
                        renderAnimeList();
                        renderPlannerList();
                        renderActivityCalendar();
                        
                        showNotification('Dane zostały pomyślnie zaimportowane!', 'success');
                    }
                } catch (error) {
                    console.error('Błąd importu:', error);
                    showNotification('Błąd podczas importu danych!', 'danger');
                } finally {
                    // Przywróć pole input
                    const input = document.getElementById('import-code-input-inline');
                    input.disabled = false;
                    input.value = '';
                }
            }
            
            // Obsługa zmiany rozmiaru okna
            window.addEventListener('resize', () => {
                const wasMobile = isMobileView;
                isMobileView = window.innerWidth <= 768;
                
                // Przełącz widok tylko jeśli się zmienił
                if (wasMobile !== isMobileView) {
                    renderActivityCalendar();
                }
            });
            
            // Funkcja do obsługi swipe na kalendarzu
            function addSwipeSupport(container) {
                let startX = 0;
                let startY = 0;
                let endX = 0;
                let endY = 0;
                
                container.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                }, { passive: true });
                
                container.addEventListener('touchend', (e) => {
                    endX = e.changedTouches[0].clientX;
                    endY = e.changedTouches[0].clientY;
                    
                    const diffX = startX - endX;
                    const diffY = startY - endY;
                    
                    // Sprawdź czy swipe jest bardziej poziomy niż pionowy i ma odpowiednią długość
                    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                        if (isMobileView) {
                            // Na mobile - nawigacja miesięczna
                            if (diffX > 0) {
                                // Swipe w lewo - następny miesiąc
                                currentMonth++;
                                if (currentMonth > 11) {
                                    currentMonth = 0;
                                    currentYear++;
                                }
                            } else {
                                // Swipe w prawo - poprzedni miesiąc
                                currentMonth--;
                                if (currentMonth < 0) {
                                    currentMonth = 11;
                                    currentYear--;
                                }
                            }
                        } else {
                            // Na desktop - nawigacja roczna
                            if (diffX > 0) {
                                // Swipe w lewo - następny rok
                                currentYear++;
                            } else {
                                // Swipe w prawo - poprzedni rok
                                currentYear--;
                            }
                        }
                        renderActivityCalendar();
                    }
                }, { passive: true });
            }
            
            // Sprawdź czy jest kod w URL i automatycznie go wgraj
            const urlParams = new URLSearchParams(window.location.search);
            const codeFromUrl = urlParams.get('code');
            if (codeFromUrl && /^\d{6}$/.test(codeFromUrl)) {
                console.log('Znaleziono kod w URL:', codeFromUrl);
                // Krótkie opóźnienie żeby strona się załadowała
                setTimeout(() => {
                    document.getElementById('import-code-input-inline').value = codeFromUrl;
                    checkImportCode(codeFromUrl);
                    setTimeout(() => performImport(codeFromUrl), 1000);
                }, 500);
            }
        });

        // ================================
        // 🎨 ANIMATION HELPERS
        // ================================

        // Function to add success animation
        function showSuccessAnimation(element) {
            element.style.animation = 'successBounce 0.6s ease-out';
            setTimeout(() => {
                element.style.animation = '';
            }, 600);
        }

        // Function to add error animation
        function showErrorAnimation(element) {
            element.style.animation = 'errorShake 0.5s ease-in-out';
            setTimeout(() => {
                element.style.animation = '';
            }, 500);
        }

        // Function to animate stats counter
        function animateCounter(element, start, end, duration = 1000) {
            const range = end - start;
            const increment = end > start ? 1 : -1;
            const stepTime = Math.abs(Math.floor(duration / range));
            let current = start;
            
            const timer = setInterval(() => {
                current += increment;
                element.textContent = current;
                
                if (current === end) {
                    clearInterval(timer);
                }
            }, stepTime);
        }



        // Function to animate calendar days with activity
        function animateActivityDays() {
            const activityDays = document.querySelectorAll('.calendar-day[style*="background"]');
            activityDays.forEach(day => {
                if (!day.classList.contains('has-activity')) {
                    day.classList.add('has-activity');
                }
            });
        }

        // Function to add stagger animation to lists
        function staggerAnimate(selector, animationClass = 'animate-fadeIn') {
            const elements = document.querySelectorAll(selector);
            elements.forEach((el, index) => {
                el.style.animationDelay = `${index * 0.1}s`;
                el.classList.add(animationClass);
            });
        }

        // Function to animate tier list items during drag
        function startDragAnimation(element) {
            element.classList.add('dragging');
        }

        function stopDragAnimation(element) {
            element.classList.remove('dragging');
        }

        // Function to add button ripple effect
        function addRippleEffect(button, event) {
            const ripple = document.createElement('span');
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event.clientX - rect.left - size / 2;
            const y = event.clientY - rect.top - size / 2;
            
            ripple.style.cssText = `
                position: absolute;
                width: ${size}px;
                height: ${size}px;
                left: ${x}px;
                top: ${y}px;
                background: rgba(255,255,255,0.3);
                border-radius: 50%;
                transform: scale(0);
                animation: rippleEffect 0.6s ease-out;
                pointer-events: none;
            `;
            
            button.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        // Add ripple effect keyframe
        const animationStyle = document.createElement('style');
        animationStyle.textContent = `
            @keyframes rippleEffect {
                to {
                    transform: scale(2);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(animationStyle);

        // Apply animations on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize modern UI effects
            initModernUI();
            
            // Add stagger animations to initial elements
            setTimeout(() => {
                staggerAnimate('.stat-card', 'animate-fadeIn');
                animateActivityDays();
            }, 500);

            // Add ripple effect to all buttons
            document.querySelectorAll('.btn-accent, .btn-primary, .btn-success, .btn-danger').forEach(button => {
                button.addEventListener('click', function(e) {
                    addRippleEffect(this, e);
                });
            });

            // Add success/error animations to form submissions
            const forms = document.querySelectorAll('form');
            forms.forEach(form => {
                form.addEventListener('submit', function(e) {
                    const submitButton = this.querySelector('[type="submit"]');
                    if (submitButton) {
                        showSuccessAnimation(submitButton);
                    }
                });
            });
        });

        // ================================
        // 🚀 MODERN UI EFFECTS
        // ================================

        // Create particle background
        function createParticleBackground() {
            const particlesContainer = document.createElement('div');
            particlesContainer.className = 'particles';
            document.body.appendChild(particlesContainer);

            // Create floating particles
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Enhanced loading states
        function showLoadingShimmer(element) {
            element.classList.add('loading-shimmer');
            setTimeout(() => {
                element.classList.remove('loading-shimmer');
            }, 2000);
        }

        // Create floating action button
        function createFloatingActionButton() {
            const fab = document.createElement('div');
            fab.className = 'floating-element';
            fab.style.bottom = '20px';
            fab.style.right = '20px';
            fab.innerHTML = '<i class="fas fa-arrow-up" style="color: white;"></i>';
            fab.title = 'Przewiń do góry';
            
            fab.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });

            document.body.appendChild(fab);

            // Show/hide based on scroll
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    fab.style.display = 'flex';
                    fab.style.opacity = '1';
                } else {
                    fab.style.opacity = '0';
                    setTimeout(() => {
                        if (window.scrollY <= 300) {
                            fab.style.display = 'none';
                        }
                    }, 300);
                }
            });

            fab.style.display = 'none';
        }

        // Simple, clean hover effects for cards (tier-item has its own CSS hover)
        function enhanceCardInteractions() {
            const cards = document.querySelectorAll('.stat-card, .anime-card');
            
            cards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-3px) scale(1.02)';
                    this.style.filter = 'brightness(1.05)';
                });

                card.addEventListener('mouseleave', function() {
                    this.style.filter = '';
                    this.style.transform = '';
                });
            });
        }

        // Dynamic color theme based on time
        function setDynamicTheme() {
            const hour = new Date().getHours();
            const root = document.documentElement;
            
            if (hour >= 6 && hour < 12) {
                // Morning theme
                root.style.setProperty('--primary', '#667eea');
                root.style.setProperty('--accent', '#764ba2');
            } else if (hour >= 12 && hour < 18) {
                // Afternoon theme  
                root.style.setProperty('--primary', '#f093fb');
                root.style.setProperty('--accent', '#f5576c');
            } else if (hour >= 18 && hour < 22) {
                // Evening theme
                root.style.setProperty('--primary', '#4facfe');
                root.style.setProperty('--accent', '#00f2fe');
            } else {
                // Night theme
                root.style.setProperty('--primary', '#a8edea');
                root.style.setProperty('--accent', '#fed6e3');
            }
        }

        // Progressive loading of sections
        function progressiveLoad() {
            const sections = document.querySelectorAll('.section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                        
                        // Add stagger animation to children
                        const children = entry.target.querySelectorAll('.stat-card, .anime-card, .form-group');
                        children.forEach((child, index) => {
                            setTimeout(() => {
                                child.style.opacity = '1';
                                child.style.transform = 'translateY(0)';
                            }, index * 100);
                        });
                    }
                });
            }, { threshold: 0.1 });

            sections.forEach(section => {
                section.style.opacity = '0';
                section.style.transform = 'translateY(30px)';
                section.style.transition = 'all 0.6s cubic-bezier(0.25, 0.8, 0.25, 1)';
                observer.observe(section);
            });
        }

        // Clean, elegant navigation without chaotic indicators
        function enhanceNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach(item => {
                item.addEventListener('mouseenter', () => {
                    item.style.transform = 'translateY(-3px) scale(1.05)';
                    item.style.filter = 'brightness(1.2)';
                });
                
                item.addEventListener('mouseleave', () => {
                    if (!item.classList.contains('active')) {
                        item.style.transform = '';
                        item.style.filter = '';
                    }
                });
            });
        }

        // Parallax effect for background elements
        function addParallaxEffect() {
            window.addEventListener('scroll', () => {
                const scrolled = window.pageYOffset;
                const parallaxElements = document.querySelectorAll('.particles');
                
                parallaxElements.forEach(element => {
                    const speed = 0.5;
                    element.style.transform = `translateY(${scrolled * speed}px)`;
                });
            });
        }

        // Apply consistent, elegant neon effects
        function applyNeonEffects() {
            // Add subtle neon glow to main headers only
            const mainHeaders = document.querySelectorAll('h1');
            mainHeaders.forEach(header => {
                if (!header.classList.contains('neon-text')) {
                    header.classList.add('neon-text');
                }
            });

            // Tier items now have their own built-in color hierarchy (RGB/Gold/Silver)

            // Add subtle holographic effect to modal headers only
            const modalHeaders = document.querySelectorAll('.episode-modal-header, .modal-header');
            modalHeaders.forEach(header => {
                header.classList.add('holographic');
            });

            // NO random glitch effects - they're chaotic
        }

        // Enhanced text readability
        function enhanceTextReadability() {
            // Add better text shadows to all text elements
            const textElements = document.querySelectorAll('p, span, div, label, input, select, textarea');
            textElements.forEach(el => {
                if (!el.style.textShadow && el.offsetParent) {
                    el.style.textShadow = '0 1px 3px rgba(0, 0, 0, 0.5)';
                }
            });

            // Ensure white text for important elements
            const importantText = document.querySelectorAll('.stat-value, .anime-title, h3, .nav-item span');
            importantText.forEach(el => {
                el.style.color = 'rgba(255, 255, 255, 0.95)';
                el.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.8)';
            });
        }

        // Elegant glow for special elements
        function addElegantGlow() {
            // Only active nav items get subtle pulse
            const activeNavItems = document.querySelectorAll('.nav-item.active');
            activeNavItems.forEach(el => {
                el.style.animation = 'subtleNeonPulse 4s ease-in-out infinite alternate';
            });
            
            // Tier items already have their own animations via CSS
        }

        // Initialize all modern UI effects
        function initModernUI() {
            createParticleBackground();
            createFloatingActionButton();
            enhanceCardInteractions();
            setDynamicTheme();
            progressiveLoad();
            enhanceNavigation();
            addParallaxEffect();
            
            // Apply elegant effects
            setTimeout(() => {
                applyNeonEffects();
                enhanceTextReadability();
                addElegantGlow();
            }, 500);

            // Apply loading shimmers to initial cards
            setTimeout(() => {
                const cards = document.querySelectorAll('.stat-card, .anime-card');
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        showLoadingShimmer(card);
                    }, index * 200);
                });
            }, 1000);

            // Reapply effects when content changes
            const observer = new MutationObserver(() => {
                setTimeout(() => {
                    enhanceTextReadability();
                    addElegantGlow();
                }, 100);
            });

            observer.observe(document.body, {
                childList: true,
                subtree: true
            });

            // Update theme every hour
            setInterval(setDynamicTheme, 3600000);
        }

        // ================================
        // END MODERN UI EFFECTS 🚀
        // ================================

        // ================================
        // END ANIMATION HELPERS 🎨
        // ================================
    </script>
    
    <!-- Modal do dodawania odcinków -->
    <div class="episode-modal" id="episode-modal">
        <div class="episode-modal-content">
            <div class="episode-modal-header">
                <h3 id="episode-modal-title">Dodaj odcinki</h3>
                <button class="episode-modal-close" id="episode-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="episode-counter">
                <button class="episode-counter-btn" id="episode-decrease">
                    <i class="fas fa-minus"></i>
                </button>
                <div class="episode-counter-value" id="episode-count">1</div>
                <button class="episode-counter-btn" id="episode-increase">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div class="form-group">
                <label for="episode-date">Data oglądania</label>
                <input type="date" id="episode-date" required>
            </div>
            <div class="form-group" style="margin-bottom: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="activity-only" style="width: auto; margin: 0;">
                    <span style="color: var(--gray); font-size: 0.9rem;">
                        <i class="fas fa-calendar-check"></i> Tylko aktywność (nie zmieniaj postępu anime)
                    </span>
                </label>
            </div>
            <button class="add-episode-btn" id="add-episode-btn">
                <i class="fas fa-plus"></i>
                Dodaj odcinki
            </button>
        </div>
    </div>
    
    <!-- Modal podsumowania dnia -->
    <div class="day-summary-modal" id="day-summary-modal">
        <div class="day-summary-content">
            <div class="day-summary-header">
                <div class="day-summary-date" id="day-summary-date">Data</div>
                <button class="day-summary-close" id="day-summary-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="day-summary-stats" id="day-summary-stats">
                <!-- Statystyki będą dodawane dynamicznie -->
            </div>
            <div class="day-summary-anime-list" id="day-summary-anime-list">
                <!-- Lista anime będzie dodawana dynamicznie -->
            </div>
        </div>
    </div>

    <!-- Modal generowania kodu -->
    <div class="transfer-modal" id="generate-code-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-qrcode"></i> Generuj kod transferu
                </h3>
                <button class="transfer-modal-close" id="generate-code-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Kod umożliwi przeniesienie wszystkich twoich danych anime oraz aktywności na inne urządzenie. Kod jest ważny przez 1 godzinę.
            </div>
            <div class="transfer-code-display" id="generated-code">
                Generowanie...
            </div>
            <div class="transfer-timer" id="code-timer">
                Kod wygaśnie za: <span id="time-remaining">59:59</span>
            </div>
            <div style="text-align: center; padding: 1rem; display: none;" id="qr-code-inline">
                <div id="qr-code-display-inline" style="display: inline-block; padding: 1rem; background: white; border-radius: 8px;"></div>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 1rem;">
                <button class="copy-button" id="copy-code-btn" style="flex: 1;">
                    <i class="fas fa-copy"></i> Skopiuj kod
                </button>
                <button class="btn-secondary" id="show-qr-btn" style="flex: 1;">
                    <i class="fas fa-qrcode"></i> Pokaż QR
                </button>
            </div>
        </div>
    </div>

    <!-- Modal wpisywania kodu -->
    <div class="transfer-modal" id="import-code-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-download"></i> Wgraj kod transferu
                </h3>
                <button class="transfer-modal-close" id="import-code-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Wpisz 6-cyfrowy kod aby wgrać dane. Po wgraniu dane zostaną automatycznie połączone z obecnymi.
            </div>
            <input type="text" 
                   class="transfer-code-input" 
                   id="import-code-input" 
                   placeholder="000000"
                   maxlength="6"
                   autocomplete="off">
            <div style="display: none;" id="import-preview">
                <div class="transfer-info" style="border-left-color: var(--success);">
                    <strong>Znaleziono dane:</strong>
                    <div id="import-preview-content"></div>
                </div>
                <button class="btn-success" id="confirm-import-btn" style="width: 100%; margin-top: 1rem;">
                    <i class="fas fa-check"></i> Potwierdź import danych
                </button>
            </div>
        </div>
    </div>

    <!-- Modal QR kodu eksportu -->
    <div class="transfer-modal" id="qr-code-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-qrcode"></i> Kod QR eksportu
                </h3>
                <button class="transfer-modal-close" id="qr-code-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Zeskanuj ten kod QR aby wgrać dane na innym urządzeniu.
            </div>
            <div style="text-align: center; padding: 1rem;">
                <div id="qr-code-display" style="display: inline-block; padding: 1rem; background: white; border-radius: 8px;"></div>
            </div>
            <div style="text-align: center; margin-top: 1rem;">
                <div style="font-size: 1.2rem; color: var(--primary); font-weight: bold;" id="qr-code-text"></div>
                <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;" id="qr-code-timer"></div>
            </div>
        </div>
    </div>

    <!-- Modal skanowania QR -->
    <div class="transfer-modal" id="qr-scanner-modal">
        <div class="transfer-modal-content">
            <div class="transfer-modal-header">
                <h3 style="margin: 0; color: var(--lighter);">
                    <i class="fas fa-qrcode"></i> Skanuj kod QR
                </h3>
                <button class="transfer-modal-close" id="qr-scanner-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="transfer-info">
                <i class="fas fa-info-circle"></i>
                Skieruj kamerę na kod QR aby automatycznie wgrać dane.
            </div>
            <div style="text-align: center; padding: 1rem;">
                <div id="qr-reader" style="width: 100%; max-width: 400px; margin: 0 auto;"></div>
            </div>
        </div>
    </div>

    <!-- Modal edycji anime -->
    <div class="episode-modal" id="edit-anime-modal">
        <div class="episode-modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="episode-modal-header">
                <h3 id="edit-anime-modal-title">Edytuj anime</h3>
                <button class="episode-modal-close" id="edit-anime-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="edit-anime-form">
                <input type="hidden" id="edit-anime-id">
                
                <div class="form-group">
                    <label for="edit-title"><i class="fas fa-heading"></i> Tytuł anime</label>
                    <input type="text" id="edit-title" required placeholder="Wpisz tytuł anime">
                </div>
                
                <div class="form-group">
                    <label for="edit-anime-tags"><i class="fas fa-tags"></i> Tagi (oddziel średnikiem ; lub enterem)</label>
                    <input type="text" id="edit-anime-tags" placeholder="np. isekai; komedia; sport">
                </div>
                
                <div class="form-group">
                    <label for="edit-status"><i class="fas fa-bookmark"></i> Status</label>
                    <select id="edit-status" required>
                        <option value="watching">Oglądane</option>
                        <option value="completed">Obejrzane</option>
                        <option value="upcoming">Nadchodzące</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="edit-season-count"><i class="fas fa-layer-group"></i> Liczba sezonów</label>
                    <input type="number" id="edit-season-count" min="1" value="1">
                </div>
                <div class="form-group" id="edit-seasons-container" style="display:none;"></div>
                <div class="form-group">
                    <label for="edit-total-episodes"><i class="fas fa-list-ol"></i> Łączna liczba odcinków</label>
                    <input type="number" id="edit-total-episodes" min="1" value="12">
                </div>
                
                <div class="form-group">
                    <label for="edit-episode-length"><i class="fas fa-clock"></i> Długość odcinka (minuty)</label>
                    <input type="number" id="edit-episode-length" min="1" value="24">
                </div>
                
                <div class="form-group">
                    <label for="edit-watched-episodes"><i class="fas fa-eye"></i> Obejrzane odcinki</label>
                    <input type="number" id="edit-watched-episodes" min="0" value="0">
                </div>
                
                <div class="form-group" id="edit-completed-date-group" style="display:none;">
                    <label for="edit-completed-date"><i class="fas fa-calendar-check"></i> Data ukończenia</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="date" id="edit-completed-date" style="flex: 1;">
                        <button type="button" id="edit-clear-date-btn" class="btn-secondary" style="padding: 0.5rem;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--gray);">
                        <i class="fas fa-info-circle"></i> Daty ukończenia i ostatniego oglądania będą automatycznie śledzone przy zwiększaniu aktywności.
                    </div>
                </div>
                
                <div class="form-group image-upload-container">
                    <label><i class="fas fa-image"></i> Obrazek anime</label>
                    <input type="file" id="edit-image-upload" accept="image/*" style="display: none;">
                    <button type="button" id="edit-select-image-btn" class="btn-accent" style="width: 100%; margin-bottom: 1rem;">
                        <i class="fas fa-upload"></i> Wybierz obrazek
                    </button>
                    <div class="image-preview" id="edit-image-preview">
                        <div class="image-preview-placeholder">
                            <i class="fas fa-image"></i>
                            <span>Brak wybranego obrazka</span>
                        </div>
                    </div>
                </div>
                
                <div class="ratings-container">
                    <h3 style="margin: 1.5rem 0 1rem 0;"><i class="fas fa-star"></i> Oceny (1-11)</h3>
                    <div class="ratings-grid">
                        <div class="rating-item">
                            <label for="edit-graphics">Grafika</label>
                            <input type="number" id="edit-graphics" min="1" max="11" value="5">
                        </div>
                        <div class="rating-item">
                            <label for="edit-music">Muzyka</label>
                            <input type="number" id="edit-music" min="1" max="11" value="5">
                        </div>
                        <div class="rating-item">
                            <label for="edit-characters">Postacie</label>
                            <input type="number" id="edit-characters" min="1" max="11" value="5">
                        </div>
                        <div class="rating-item">
                            <label for="edit-story">Fabuła</label>
                            <input type="number" id="edit-story" min="1" max="11" value="5">
                        </div>
                        <div class="rating-item">
                            <label for="edit-fun">Śmieszność</label>
                            <input type="number" id="edit-fun" min="1" max="11" value="5">
                        </div>
                        <div class="rating-item">
                            <label>Średnia</label>
                            <span id="edit-average-display" class="average-display">5.0</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group" style="margin-top: 2rem;">
                    <button type="submit" class="btn-success" style="width: 100%;">
                        <i class="fas fa-save"></i> Zapisz zmiany
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal szczegółów anime -->
    <div class="episode-modal" id="anime-details-modal">
        <div class="episode-modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
            <div class="episode-modal-header">
                <h3 id="anime-details-modal-title">Szczegóły anime</h3>
                <button class="episode-modal-close" id="anime-details-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="anime-details-content">
                <!-- Content will be dynamically filled -->
            </div>
        </div>
    </div>
</body>
</html>
